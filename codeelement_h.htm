<PRE><B><FONT color="#000080">#ifndef</FONT></B> __CODEELEMENT_H__
<B><FONT color="#000080">#define</FONT></B> __CODEELEMENT_H__
<I><FONT color="#008080">//+---------------------------------------------------------------------------------------+</FONT></I>
<I><FONT color="#008080">//This file codeelement.h is copyright 1999 2000 by Saul Scudder</FONT></I>
<I><FONT color="#008080">//It is distributed for non-profit use as freeware and no warranty is given with the use of</FONT></I>
<I><FONT color="#008080">//this source for any purpose whatsoever.</FONT></I>
<I><FONT color="#008080">//This copyright notice is to remain unmodified in the file</FONT></I>
<I><FONT color="#008080">//A license for commercial use of the _Zen_Soft programmers tools may be obtained by sending</FONT></I>
<I><FONT color="#008080">//a check for $40.00 to </FONT></I>
<I><FONT color="#008080">//_Zen_Soft c/o </FONT></I>
<I><FONT color="#008080">//Saul Scudder</FONT></I>
<I><FONT color="#008080">//5106 W. Crocus Dr.</FONT></I>
<I><FONT color="#008080">//Glendale AZ 85306</FONT></I>
<I><FONT color="#008080">//+---------------------------------------------------------------------------------------+</FONT></I>

<B><FONT color="#000080">#include</FONT></B> &lt;io.h&gt;
<B><FONT color="#000080">#include</FONT></B> &lt;cmath&gt;
<B><FONT color="#000080">#include</FONT></B> &lt;cfloat&gt;
<B><FONT color="#000080">#include</FONT></B> &lt;ctime&gt;
<B><FONT color="#000080">#include</FONT></B> &lt;cstdlib&gt;
<B><FONT color="#000080">#include</FONT></B> &lt;cstdio&gt;
<B><FONT color="#000080">#include</FONT></B> &lt;cctype&gt;
<B><FONT color="#000080">#include</FONT></B> &lt;cstddef&gt; 

<I><FONT color="#008080">// #define USING_GCC </FONT></I>
<B><FONT color="#000080">#define</FONT></B> USING_WINDOWS

<B><FONT color="#000080">#ifdef</FONT></B> USING_WINDOWS
<B><FONT color="#000080">#include</FONT></B> &lt;windows.h&gt;
<B><FONT color="#000080">#endif</FONT></B>

<B><FONT color="#000080">#pragma</FONT></B> warning(disable: <FONT color="#800000">4786</FONT>)

<B><FONT color="#000080">#include</FONT></B> &lt;vector&gt;
<B><FONT color="#000080">#include</FONT></B> &lt;list&gt;
<B><FONT color="#000080">#include</FONT></B> &lt;map&gt;
<B><FONT color="#000080">#include</FONT></B> &lt;stack&gt;
<B><FONT color="#000080">#include</FONT></B> &lt;deque&gt;
<B><FONT color="#000080">#include</FONT></B> &lt;algorithm&gt;
<B><FONT color="#000080">#include</FONT></B> &lt;string&gt;
<B><FONT color="#000080">#include</FONT></B> &lt;fstream&gt;
<B><FONT color="#000080">#include</FONT></B> &lt;iostream&gt;
<B><FONT color="#000080">#include</FONT></B> &lt;strstream&gt;

using namespace std;

<B><FONT color="#000080">class</FONT></B> InterpreterData;      <I><FONT color="#008080">// interpreter instance data</FONT></I>
<B><FONT color="#000080">class</FONT></B> Word;                 <I><FONT color="#008080">// the defined words in the language</FONT></I>
<B><FONT color="#000080">class</FONT></B> Parser;               <I><FONT color="#008080">// a parser with a stack for includes</FONT></I>
<B><FONT color="#000080">class</FONT></B> Primitives;           <I><FONT color="#008080">// primitive fuction definitions</FONT></I>
<B><FONT color="#000080">class</FONT></B> Language;             <I><FONT color="#008080">// the top level class</FONT></I>
<B><FONT color="#000080">class</FONT></B> Element;              <I><FONT color="#008080">// parts of words</FONT></I>

<B><FONT color="#000080">class</FONT></B> ClassMethod;          <I><FONT color="#008080">// methods in classes</FONT></I>
<B><FONT color="#000080">class</FONT></B> ClassData;            <I><FONT color="#008080">// data in class objects</FONT></I>
<B><FONT color="#000080">class</FONT></B> ClassDescription;     <I><FONT color="#008080">// class description data for forth classes</FONT></I>
<B><FONT color="#000080">class</FONT></B> ClassDescriptions;    <I><FONT color="#008080">// all class descriptions </FONT></I>

<B><FONT color="#000080">#define</FONT></B> ERRLISTMAX <FONT color="#800000">4</FONT>  <I><FONT color="#008080">// save last 5 errors</FONT></I>

<I><FONT color="#008080">// errordata is the error text and an int ID</FONT></I>

<B><FONT color="#000080">class</FONT></B> ErrorData
{
  string text;
  <B><FONT color="#000080">int</FONT></B> number;
<B><FONT color="#000080">public</FONT></B>:

    ErrorData()
    {
      text.reserve(<FONT color="#800000">120</FONT>);
      text = <FONT color="#800000">"None"</FONT>;
      number = <FONT color="#800000">0</FONT>;
    }

    ErrorData(<B><FONT color="#000080">const</FONT></B> ErrorData & ed)
    {
      text.reserve(<FONT color="#800000">120</FONT>);  
      text = ed.text;
      number = ed.number;
    }

   ErrorData(<B><FONT color="#000080">int</FONT></B> num, string& ee)
   {
     text.reserve(<FONT color="#800000">120</FONT>);     
     text = ee;
     number = num;
   }

   ErrorData & <B><FONT color="#000080">operator</FONT></B> = (<B><FONT color="#000080">const</FONT></B> ErrorData & ed)
    {
      text.reserve(<FONT color="#800000">120</FONT>);  
      text = ed.text;
      number = ed.number;
      <B><FONT color="#000080">return</FONT></B>(*<B><FONT color="#000080">this</FONT></B>);
    }

   string& Text()
   {
     <B><FONT color="#000080">return</FONT></B>(text);
   }

   <B><FONT color="#000080">int</FONT></B> Number()
   {
     <B><FONT color="#000080">return</FONT></B>(number);
   }

   <B><FONT color="#000080">bool</FONT></B> NumberEqual(<B><FONT color="#000080">int</FONT></B> nn)
   {
      <B><FONT color="#000080">return</FONT></B>((nn == number));
   }
};

<I><FONT color="#008080">// Errors is an array of error data</FONT></I>
<I><FONT color="#008080">// it can lookup errors and add them to the output stream and the tracing stream</FONT></I>
<I><FONT color="#008080">// currently any language error stops interpretation </FONT></I>

<B><FONT color="#000080">class</FONT></B> Errors <I><FONT color="#008080">// the list of usage errors</FONT></I>
{
  vector&lt; ErrorData &gt; errors;
  ErrorData Euse;
  string ErrPrompt;
  string LastError[<FONT color="#800000">5</FONT>];
  <B><FONT color="#000080">int</FONT></B> ErrIndex;
  <B><FONT color="#000080">bool</FONT></B> fatal;

<B><FONT color="#000080">public</FONT></B>:
  Errors();

  Errors(<B><FONT color="#000080">const</FONT></B> Errors& er)
  {
    <B><FONT color="#000080">for</FONT></B>(<B><FONT color="#000080">int</FONT></B> qq = <FONT color="#800000">0</FONT>;qq &lt; <FONT color="#800000">5</FONT>;qq++)
    {
      LastError[qq].reserve(<FONT color="#800000">120</FONT>);
    }

   ErrPrompt.reserve(<FONT color="#800000">120</FONT>);
   errors = er.errors;
   Euse = er.Euse;
   fatal = er.fatal;
  }

  ~Errors();

 Errors& <B><FONT color="#000080">operator</FONT></B> = (<B><FONT color="#000080">const</FONT></B> Errors& er)
  {
   <B><FONT color="#000080">for</FONT></B>(<B><FONT color="#000080">int</FONT></B> qq = <FONT color="#800000">0</FONT>;qq &lt; <FONT color="#800000">5</FONT>;qq++)
   {
      LastError[qq].reserve(<FONT color="#800000">120</FONT>);
   }

   ErrPrompt.reserve(<FONT color="#800000">120</FONT>);
   errors = er.errors;
   Euse = er.Euse;
   fatal = er.fatal;
   <B><FONT color="#000080">return</FONT></B>(*<B><FONT color="#000080">this</FONT></B>);
  }

  <B><FONT color="#000080">bool</FONT></B> FindError(<B><FONT color="#000080">int</FONT></B> index)
  {
    <B><FONT color="#000080">for</FONT></B>(<B><FONT color="#000080">int</FONT></B> ii = <FONT color="#800000">0</FONT>;ii &lt; errors.size();ii++)
    {
       <B><FONT color="#000080">if</FONT></B>(errors[ii].NumberEqual(index))
       {
          Euse = errors[ii];
          <B><FONT color="#000080">return</FONT></B>(true);
       }
    }
    <B><FONT color="#000080">return</FONT></B>(false);
  }

  string & Error(<B><FONT color="#000080">int</FONT></B> index)
  {
    <B><FONT color="#000080">if</FONT></B>(index &lt; errors.size())
    {
      <B><FONT color="#000080">if</FONT></B>(FindError(index))
      {
        <B><FONT color="#000080">return</FONT></B>(Euse.Text());
      }
    }
    Euse = errors[errors.size() - <FONT color="#800000">1</FONT>];
    <B><FONT color="#000080">return</FONT></B>(Euse.Text());
  }

  <B><FONT color="#000080">bool</FONT></B> Fatal()
  {
    <B><FONT color="#000080">return</FONT></B>(fatal);
  }

  <B><FONT color="#000080">void</FONT></B> FatalError(<B><FONT color="#000080">void</FONT></B>)
  {
    fatal = true;
  }

  <B><FONT color="#000080">void</FONT></B> ResetFatal(<B><FONT color="#000080">void</FONT></B>)
  {
    fatal = false;
  }

  <B><FONT color="#000080">void</FONT></B> AddError(<B><FONT color="#000080">int</FONT></B> ii, string & ee)
  {
    ErrorData aerr(ii, ee);
    errors.push_back(aerr);
  }

  <B><FONT color="#000080">void</FONT></B> AddErr(<B><FONT color="#000080">int</FONT></B> ii, <B><FONT color="#000080">char</FONT></B> * cc)
  {
    string cs;
    cs.reserve(<FONT color="#800000">120</FONT>);
    cs = cc;
    AddError(ii, cs);
  }

  <B><FONT color="#000080">void</FONT></B> ShowError(<B><FONT color="#000080">int</FONT></B> ii, InterpreterData & intpr, string& extra);

  <B><FONT color="#000080">enum</FONT></B> ErrorIDS
  {
    NO_TRAILING_QUOTE,
    SYNTAX_ERROR,
    NO_SUCH_WORD,
    IS_NUMBER,
    WORD_EXISTS,
    BUFFER_END,
    STACK_UNDERFLOW,
    AUX_STACK_UNDERFLOW,
    ONLY_COMPILED,
    NO_BEGIN,
    NO_DO,
    PRIMITIVE_EXISTS,
    RETURN_STACK_UNDERFLOW,
    ILLEGALDEFINING,
    DIVIDEBYZERO,
    NO_CLOSINGPAREN,
    NO_EOL,
    BAD_STACKPOSITION,
    BAD_POINTER,
    NO_CREATE,
    STL_ERROR,
    NO_CLASS_EXISTS,
    CLASS_EXISTS,
    NO_MEMBER_FOUND,
    METHOD_EXISTED,
    COMPILING_METHOD,
    NOT_COMPILING_METHOD,
    MEMBER_EXISTS,
    PRIVATE_METHOD,
    PRIVATE_MEMBER,
    AMBIGUIOUS_MEMBER,
    SYSTEM_EXECPTION,
    UNKNOWNERROR                <I><FONT color="#008080">// always last</FONT></I>
  };

};

<B><FONT color="#000080">class</FONT></B> Vocabulary
{
   map&lt;string, <B><FONT color="#000080">int</FONT></B>, less&lt;string&gt; &gt; vocabulary;
   string name;

<B><FONT color="#000080">public</FONT></B>:

   Vocabulary(string & nam)
   {
      name.reserve(<FONT color="#800000">50</FONT>);
      name = nam;
   }

   Vocabulary(<B><FONT color="#000080">const</FONT></B> Vocabulary & voc) 
   {
      name.reserve(<FONT color="#800000">50</FONT>);
      vocabulary = voc.vocabulary;
      name = voc.name;
   }

   
  Vocabulary & <B><FONT color="#000080">operator</FONT></B> = (<B><FONT color="#000080">const</FONT></B> Vocabulary & voc) 
   {
      name.reserve(<FONT color="#800000">50</FONT>);
      vocabulary = voc.vocabulary;
      name = voc.name;
      <B><FONT color="#000080">return</FONT></B>(*<B><FONT color="#000080">this</FONT></B>);
   }

  <B><FONT color="#000080">bool</FONT></B> <B><FONT color="#000080">operator</FONT></B> &lt; (<B><FONT color="#000080">const</FONT></B> Vocabulary & voc) 
   {
      <B><FONT color="#000080">if</FONT></B>(name &lt; voc.name)
      {
          <B><FONT color="#000080">return</FONT></B>(true);
      }
      <B><FONT color="#000080">return</FONT></B>(false);
   }

  <B><FONT color="#000080">bool</FONT></B> <B><FONT color="#000080">operator</FONT></B> == (<B><FONT color="#000080">const</FONT></B> Vocabulary & voc) 
   {
      <B><FONT color="#000080">if</FONT></B>(name == voc.name)
      {
          <B><FONT color="#000080">return</FONT></B>(true);
      }
      <B><FONT color="#000080">return</FONT></B>(false);
   }

  <B><FONT color="#000080">void</FONT></B> AddWord(string& ss, <B><FONT color="#000080">int</FONT></B> ii)
  {
     vocabulary[ss] = ii;
  }

  <B><FONT color="#000080">int</FONT></B> Find(string& ss)
  {
      map&lt;string, <B><FONT color="#000080">int</FONT></B>, less&lt;string&gt; &gt; ::iterator jj;

      jj = vocabulary.find(ss);

      <B><FONT color="#000080">if</FONT></B>(jj != vocabulary.end())
      {
        <B><FONT color="#000080">return</FONT></B>((*jj).second);
      }
    <B><FONT color="#000080">return</FONT></B>(-<FONT color="#800000">1</FONT>);
  }

  <B><FONT color="#000080">int</FONT></B> Find(<B><FONT color="#000080">char</FONT></B>* ss)
  {
      string gg;
      gg.reserve(<FONT color="#800000">50</FONT>);
      gg = ss;
      <B><FONT color="#000080">return</FONT></B>(Find(gg));
  }

  string & Name()
  {
    <B><FONT color="#000080">return</FONT></B>(name);
  }

};

<I><FONT color="#008080">// The dictonary class is an array all defined word objects</FONT></I>
<B><FONT color="#000080">class</FONT></B> Dictonary
{
  vector&lt;Word&gt; words;        <I><FONT color="#008080">// stores actual use instances of word class</FONT></I>
  vector&lt;Vocabulary&gt; vocs;   <I><FONT color="#008080">// stores vocabulary instances</FONT></I>
  list&lt;<B><FONT color="#000080">int</FONT></B>&gt; vocorder;        <I><FONT color="#008080">// search order</FONT></I>
  <B><FONT color="#000080">int</FONT></B> context;
  <B><FONT color="#000080">int</FONT></B> current;
  <B><FONT color="#000080">int</FONT></B> forthindex;


<B><FONT color="#000080">public</FONT></B>:
  Dictonary()
  {
    words.reserve(<FONT color="#800000">1000</FONT>);
    vocs.reserve(<FONT color="#800000">25</FONT>);
    string vn;
    vn.reserve(<FONT color="#800000">120</FONT>);
    vn = <FONT color="#800000">"forth"</FONT>;
    Vocabulary * vv = <B><FONT color="#000080">new</FONT></B> Vocabulary(vn);
    vocs.push_back((*vv));
    vocorder.push_front(FindVocIndex(vn));
    <B><FONT color="#000080">delete</FONT></B> vv;
    forthindex = FindVocIndex(vn);
    context = current = forthindex;   
  }

  Dictonary(<B><FONT color="#000080">const</FONT></B> Dictonary& dict)
  {
     words.reserve(<FONT color="#800000">1000</FONT>);
     vocs.reserve(<FONT color="#800000">25</FONT>);

     words = dict.words;
     vocs = dict.vocs;
     vocorder = dict.vocorder;
     context = dict.context;
     current = dict.current;
  }

  ~Dictonary()
  {
    
  }

  Dictonary& <B><FONT color="#000080">operator</FONT></B> = (<B><FONT color="#000080">const</FONT></B> Dictonary& dict)
  {
     words.reserve(<FONT color="#800000">1000</FONT>);
     vocs.reserve(<FONT color="#800000">25</FONT>);

     words = dict.words;
     vocs = dict.vocs;
     vocorder = dict.vocorder;
     context = dict.context;
     current = dict.current;
     <B><FONT color="#000080">return</FONT></B>(*<B><FONT color="#000080">this</FONT></B>);
  }

 <B><FONT color="#000080">int</FONT></B> FindVocIndex(string & ss)
 {
   <B><FONT color="#000080">int</FONT></B> ii;
   <B><FONT color="#000080">for</FONT></B>(ii = <FONT color="#800000">0</FONT>; ii &lt; vocs.size();ii++)
   {
      <B><FONT color="#000080">if</FONT></B>(ss == vocs[ii].Name())
      {
        <B><FONT color="#000080">return</FONT></B>(ii);
      }
   }
   <B><FONT color="#000080">return</FONT></B>(-<FONT color="#800000">1</FONT>);
 }

 <B><FONT color="#000080">int</FONT></B> FindVocIndex(<B><FONT color="#000080">char</FONT></B> * ss)
 {
   string sv;
   sv.reserve(<FONT color="#800000">120</FONT>);
   sv = ss;
   <B><FONT color="#000080">return</FONT></B>(FindVocIndex(sv));
 }

 <B><FONT color="#000080">bool</FONT></B> MakeContext(string & st)
 {
    <B><FONT color="#000080">int</FONT></B> rr = FindVocIndex(st);
    <B><FONT color="#000080">if</FONT></B>(rr &gt;= <FONT color="#800000">0</FONT>)
    {
        list&lt;<B><FONT color="#000080">int</FONT></B>&gt; ::iterator ii;
        ii = find(vocorder.begin(), vocorder.end(), rr);
        <B><FONT color="#000080">if</FONT></B>(ii != vocorder.end())
        {           
           vocorder.splice(vocorder.begin(), vocorder, ii);
           context = rr;
           <B><FONT color="#000080">return</FONT></B>(true);
           
        }
       <B><FONT color="#000080">else</FONT></B>
       {
           vocorder.push_front(rr);
           context = rr;
           <B><FONT color="#000080">return</FONT></B>(true);
       }
    }
   <B><FONT color="#000080">return</FONT></B>(false);
 }

 <B><FONT color="#000080">bool</FONT></B> MakeCurrent(string & st)
 {
    <B><FONT color="#000080">int</FONT></B> ii;
    <B><FONT color="#000080">if</FONT></B>( (ii = FindVocIndex(st)) != -<FONT color="#800000">1</FONT>)
    {
      current = ii;
      <B><FONT color="#000080">return</FONT></B>(true);
    }
    <B><FONT color="#000080">else</FONT></B>
    {
      <B><FONT color="#000080">return</FONT></B>(false);
    }
 }


<I><FONT color="#008080">// Function name    : ContextToCurrent</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : void</FONT></I>
 <B><FONT color="#000080">void</FONT></B> ContextToCurrent(<B><FONT color="#000080">void</FONT></B>)
 {
   current = context;
 }


<I><FONT color="#008080">// Function name    : RemoveVocSearch</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : bool </FONT></I>
<I><FONT color="#008080">// Argument         : string & st</FONT></I>
 <B><FONT color="#000080">bool</FONT></B> RemoveVocSearch(string & st)
 {
    <B><FONT color="#000080">int</FONT></B> ii;

    <B><FONT color="#000080">if</FONT></B>( (ii = FindVocIndex(st)) != -<FONT color="#800000">1</FONT>)
    {    
      <B><FONT color="#000080">if</FONT></B>(ii != forthindex)       <I><FONT color="#008080">// can't remove forth from search completly</FONT></I>
      {
        vocorder.remove(ii);
        <B><FONT color="#000080">if</FONT></B>(context == ii)
        {
          context = vocorder.front();
          <B><FONT color="#000080">return</FONT></B>(true);
        }
      }
    }
    <B><FONT color="#000080">return</FONT></B>(false);
 }

 <B><FONT color="#000080">bool</FONT></B> AddVoc(string & st)
 {
    <B><FONT color="#000080">int</FONT></B> ii;

    <B><FONT color="#000080">if</FONT></B>( (ii = FindVocIndex(st)) == -<FONT color="#800000">1</FONT>)
    {   
      Vocabulary * vv = <B><FONT color="#000080">new</FONT></B> Vocabulary(st);
      vocs.push_back((*vv));
      <B><FONT color="#000080">delete</FONT></B> vv;
      <B><FONT color="#000080">return</FONT></B>(true);
    }
    <B><FONT color="#000080">return</FONT></B>(false);
 }

 <B><FONT color="#000080">int</FONT></B> Exists(string& nam);
 <B><FONT color="#000080">int</FONT></B> Find(string& nam);
 Word* FindInContext(string& nam);
 Word* FindAddress(string& nam);
 Word* Address(<B><FONT color="#000080">int</FONT></B> nn);
 Word* Address(string& nam);
 Word* Address(<B><FONT color="#000080">char</FONT></B>* namw);
 Word* MostRecent(<B><FONT color="#000080">void</FONT></B>);
 <B><FONT color="#000080">bool</FONT></B> VocNameForWord(Word * ww , string& result);
 <B><FONT color="#000080">void</FONT></B> Add(Word & wrd);
 <B><FONT color="#000080">void</FONT></B> Execute(<B><FONT color="#000080">int</FONT></B> wordindex, InterpreterData & idat);
};

<I><FONT color="#008080">// class RSData is a object placed on our return stack</FONT></I>
<I><FONT color="#008080">// it contains a pointer to the word and the element index that was executing</FONT></I>
<I><FONT color="#008080">// when the word called some other word and was placed on the return stack</FONT></I>

<B><FONT color="#000080">class</FONT></B> RSData
{
  <B><FONT color="#000080">union</FONT></B>
  {
    Word *wp;
    ClassMethod * mp;
  };
  <B><FONT color="#000080">bool</FONT></B> wrd;
  <B><FONT color="#000080">long</FONT></B> wind;

<B><FONT color="#000080">public</FONT></B>:
  RSData(<B><FONT color="#000080">void</FONT></B>)
  {
    wp = NULL;
    wind = <FONT color="#800000">0</FONT>;
  }

  RSData(<B><FONT color="#000080">const</FONT></B> RSData& ret)
  {
    wp = ret.wp;
    wind = ret.wind;
  }

  RSData(Word * ww)
  {
    wp = ww;
    wind = <FONT color="#800000">0</FONT>;
  }

  RSData(ClassMethod * mm)
  {
    mp = mm;
    wind = <FONT color="#800000">0</FONT>;
  }

  RSData & <B><FONT color="#000080">operator</FONT></B> = (<B><FONT color="#000080">const</FONT></B> RSData& ret)
  {
    wp = ret.wp;
    wind = ret.wind;
    <B><FONT color="#000080">return</FONT></B>(*<B><FONT color="#000080">this</FONT></B>);
  }

  <B><FONT color="#000080">void</FONT></B> IncWind()
  {
    wind++;
  }

  <B><FONT color="#000080">void</FONT></B> SetIndex(<B><FONT color="#000080">int</FONT></B> ind)
  {
    wind = ind;
  }

  <B><FONT color="#000080">int</FONT></B> Index()
  {
    <B><FONT color="#000080">return</FONT></B>(wind);
  }

  Word * Code()
  {
    <B><FONT color="#000080">return</FONT></B>(wp);
  }

  <B><FONT color="#000080">void</FONT></B> SetCode(ClassMethod * mm)
  {
   mp = mm;
  }

 <B><FONT color="#000080">void</FONT></B> SetCode(Word * ww)
  {
   wp = ww;
  }
};

<B><FONT color="#000080">class</FONT></B> STLVect
{
   vector&lt;<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>&gt; stlvect;

<B><FONT color="#000080">public</FONT></B>:
   STLVect()
   {

   }

   STLVect (<B><FONT color="#000080">const</FONT></B> STLVect & v)
   {
     stlvect = v.stlvect;
   }

   STLVect & <B><FONT color="#000080">operator</FONT></B> = (<B><FONT color="#000080">const</FONT></B> STLVect & v)
   {
     stlvect = v.stlvect;
     <B><FONT color="#000080">return</FONT></B>(*<B><FONT color="#000080">this</FONT></B>);
   }   

   <B><FONT color="#000080">long</FONT></B> Size()
   {
     <B><FONT color="#000080">return</FONT></B>(stlvect.size());
   }

   <B><FONT color="#000080">long</FONT></B> Capacity()
   {
     <B><FONT color="#000080">return</FONT></B>(stlvect.capacity());
   }

   <B><FONT color="#000080">void</FONT></B> Clear()
   {
     stlvect.clear();
   }

   <B><FONT color="#000080">bool</FONT></B> Empty()
   {
     <B><FONT color="#000080">return</FONT></B>(stlvect.empty());
   }

 vector&lt;<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>&gt;::iterator Find(<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> qq)
   {
<I><FONT color="#008080">//     vector&lt;unsigned long&gt;::iterator aa;</FONT></I>
     <B><FONT color="#000080">return</FONT></B>((find(stlvect.begin(), stlvect.end(), qq)));
   }

 vector&lt;<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>&gt;::iterator Begin()
   {
     vector&lt;<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>&gt;::iterator aa;
     <B><FONT color="#000080">return</FONT></B>((aa = stlvect.begin()));
   }

 vector&lt;<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>&gt;::iterator End()
   {
     vector&lt;<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>&gt;::iterator aa;
     <B><FONT color="#000080">return</FONT></B>((aa = stlvect.end()));
   }

 vector&lt;<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>&gt;::reverse_iterator RBegin()
   {
     vector&lt;<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>&gt;::reverse_iterator aa;
     <B><FONT color="#000080">return</FONT></B>((aa = stlvect.rbegin()));
   }

 vector&lt;<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>&gt;::reverse_iterator REnd()
   {
     vector&lt;<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>&gt;::reverse_iterator aa;
     <B><FONT color="#000080">return</FONT></B>((aa = stlvect.rend()));
   }

 <B><FONT color="#000080">void</FONT></B> Pop_Back()
 {
    stlvect.pop_back();
 }

 <B><FONT color="#000080">void</FONT></B> Push_Back(<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> nn)
 {
    stlvect.push_back(nn);
 }

 <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> Back()
 {
    <B><FONT color="#000080">return</FONT></B>(stlvect.back());
 }

 <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> Front()
 {
    <B><FONT color="#000080">return</FONT></B>(stlvect.front());
 }
 
 vector&lt;<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>&gt;::iterator Insert(vector&lt;<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>&gt;::iterator ii, <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> d)
 {
    <B><FONT color="#000080">return</FONT></B>(stlvect.insert(ii, d));
 }

};

<B><FONT color="#000080">class</FONT></B> STLVectIterator
{
    vector&lt;<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>&gt;:: iterator ii;

<B><FONT color="#000080">public</FONT></B>:
   STLVectIterator()
   {

   }

   STLVectIterator (<B><FONT color="#000080">const</FONT></B> STLVectIterator & i)
   {
     ii = i.ii;
   }

   STLVectIterator & <B><FONT color="#000080">operator</FONT></B> = (<B><FONT color="#000080">const</FONT></B> STLVectIterator & i)
   {
     ii = i.ii;
     <B><FONT color="#000080">return</FONT></B>(*<B><FONT color="#000080">this</FONT></B>);
   } 

   STLVectIterator & <B><FONT color="#000080">operator</FONT></B> = (vector&lt;<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>&gt;::iterator i)
   {
     ii = i;
     <B><FONT color="#000080">return</FONT></B>(*<B><FONT color="#000080">this</FONT></B>);
   }

   <B><FONT color="#000080">bool</FONT></B> <B><FONT color="#000080">operator</FONT></B> == (vector&lt;<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>&gt;::iterator i)
   {
       <B><FONT color="#000080">if</FONT></B>(ii == i)
       {
         <B><FONT color="#000080">return</FONT></B>(true);
       }
     <B><FONT color="#000080">return</FONT></B>(false);
   }

   <B><FONT color="#000080">bool</FONT></B> <B><FONT color="#000080">operator</FONT></B> == (<B><FONT color="#000080">const</FONT></B> STLVectIterator & i)
   {
       <B><FONT color="#000080">if</FONT></B>(ii == i.ii)
       {
         <B><FONT color="#000080">return</FONT></B>(true);
       }
     <B><FONT color="#000080">return</FONT></B>(false);
   }

   vector&lt;<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>&gt;:: iterator& GetIt()
   {
     <B><FONT color="#000080">return</FONT></B>(ii);
   }
};

<B><FONT color="#000080">class</FONT></B> NamedSTLVect
{
   map&lt; string, STLVect, less&lt;string&gt; &gt; stlvects;

<B><FONT color="#000080">public</FONT></B>:
   NamedSTLVect()
   {

   }

   NamedSTLVect (<B><FONT color="#000080">const</FONT></B> NamedSTLVect & v)
   {
     stlvects = v.stlvects;
   }

   NamedSTLVect & <B><FONT color="#000080">operator</FONT></B> = (<B><FONT color="#000080">const</FONT></B> NamedSTLVect & v)
   {
     stlvects = v.stlvects;
     <B><FONT color="#000080">return</FONT></B>(*<B><FONT color="#000080">this</FONT></B>);
   }   

   <B><FONT color="#000080">long</FONT></B> Size()
   {
     <B><FONT color="#000080">return</FONT></B>(stlvects.size());
   }

   STLVect * Find(string s)
   {
     <B><FONT color="#000080">if</FONT></B>(stlvects.find(s) != stlvects.end())
     {
       <B><FONT color="#000080">return</FONT></B>(&stlvects[s]);
     }
     <B><FONT color="#000080">return</FONT></B>(NULL);
   }

   <B><FONT color="#000080">bool</FONT></B> Insert(string gg, STLVect * v)
   {
       pair&lt;map&lt;string, STLVect, less&lt;string&gt; &gt;::iterator, <B><FONT color="#000080">bool</FONT></B>&gt; bb;
       bb = stlvects.insert(map&lt;string, STLVect, less&lt;string&gt; &gt;::value_type(gg, *v));
       <B><FONT color="#000080">return</FONT></B>(bb.second);
   }
};

<B><FONT color="#000080">class</FONT></B> STLMap
{
   map&lt;<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>, <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>, less&lt;<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>&gt; &gt; stlmap;

<B><FONT color="#000080">public</FONT></B>:
   STLMap()
   {

   }

   STLMap (<B><FONT color="#000080">const</FONT></B> STLMap & m)
   {
     stlmap = m.stlmap;
   }

   STLMap & <B><FONT color="#000080">operator</FONT></B> = (<B><FONT color="#000080">const</FONT></B> STLMap & m)
   {
     stlmap = m.stlmap;
     <B><FONT color="#000080">return</FONT></B>(*<B><FONT color="#000080">this</FONT></B>);
   }   

   <B><FONT color="#000080">long</FONT></B> Size()
   {
     <B><FONT color="#000080">return</FONT></B>(stlmap.size());
   }

   <B><FONT color="#000080">void</FONT></B> Clear()
   {
     stlmap.clear();
   }

   <B><FONT color="#000080">bool</FONT></B> Empty()
   {
     <B><FONT color="#000080">return</FONT></B>(stlmap.empty());
   }

   map&lt;<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>, <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>, less&lt;<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>&gt; &gt;::iterator Find(<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> qq)
   {
     map&lt;<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>, <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>, less&lt;<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>&gt; &gt;::iterator aa;
     <B><FONT color="#000080">return</FONT></B>((aa = stlmap.find(qq)));
   }

  map&lt;<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>, <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>, less&lt;<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>&gt; &gt;::iterator Begin()
   {
     map&lt;<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>, <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>, less&lt;<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>&gt; &gt;::iterator aa;
     <B><FONT color="#000080">return</FONT></B>((aa = stlmap.begin()));
   }

 map&lt;<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>, <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>, less&lt;<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>&gt; &gt;::iterator End()
   {
     map&lt;<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>, <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>, less&lt;<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>&gt; &gt;::iterator aa;
     <B><FONT color="#000080">return</FONT></B>((aa = stlmap.end()));
   }

 map&lt;<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>, <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>, less&lt;<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>&gt; &gt;::reverse_iterator RBegin()
   {
     map&lt;<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>, <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>, less&lt;<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>&gt; &gt;::reverse_iterator aa;
     <B><FONT color="#000080">return</FONT></B>((aa = stlmap.rbegin()));
   }

 map&lt;<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>, <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>, less&lt;<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>&gt; &gt;::reverse_iterator REnd()
   {
     map&lt;<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>, <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>, less&lt;<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>&gt; &gt;::reverse_iterator aa;
     <B><FONT color="#000080">return</FONT></B>((aa = stlmap.rend()));
   }

   <B><FONT color="#000080">bool</FONT></B> Insert(<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> lk, <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> ld)
   {
       pair&lt;map&lt;<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>, <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>, less&lt;<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>&gt; &gt;::iterator, <B><FONT color="#000080">bool</FONT></B>&gt; bb;
       bb = stlmap.insert(map&lt;<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>, <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>, less&lt;<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>&gt; &gt;::value_type(lk, ld));
       <B><FONT color="#000080">return</FONT></B>(bb.second);
   }
};

<B><FONT color="#000080">class</FONT></B> STLMapIterator
{
    map&lt;<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>, <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>, less&lt;<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>&gt; &gt;::iterator ii;

<B><FONT color="#000080">public</FONT></B>:
   STLMapIterator()
   {

   }

   STLMapIterator (<B><FONT color="#000080">const</FONT></B> STLMapIterator & i)
   {
     ii = i.ii;
   }

   STLMapIterator & <B><FONT color="#000080">operator</FONT></B> = (<B><FONT color="#000080">const</FONT></B> STLMapIterator & i)
   {
     ii = i.ii;
     <B><FONT color="#000080">return</FONT></B>(*<B><FONT color="#000080">this</FONT></B>);
   } 

   STLMapIterator & <B><FONT color="#000080">operator</FONT></B> = (map&lt;<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>, <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>, less&lt;<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>&gt; &gt;::iterator& i)
   {
     ii = i;
     <B><FONT color="#000080">return</FONT></B>(*<B><FONT color="#000080">this</FONT></B>);
   }

   <B><FONT color="#000080">bool</FONT></B> <B><FONT color="#000080">operator</FONT></B> == (map&lt;<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>, <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>, less&lt;<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>&gt; &gt;::iterator& i)
   {
       <B><FONT color="#000080">if</FONT></B>(ii == i)
       {
         <B><FONT color="#000080">return</FONT></B>(true);
       }
     <B><FONT color="#000080">return</FONT></B>(false);
   }

   map&lt;<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>, <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>, less&lt;<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>&gt; &gt;::iterator& GetIt()
   {
     <B><FONT color="#000080">return</FONT></B>(ii);
   }
};



<B><FONT color="#000080">class</FONT></B> NamedSTLMap
{
   map&lt;string, STLMap, less&lt;string&gt; &gt; stlmaps;

<B><FONT color="#000080">public</FONT></B>:
   NamedSTLMap()
   {

   }

   NamedSTLMap (<B><FONT color="#000080">const</FONT></B> NamedSTLMap & m)
   {
     stlmaps = m.stlmaps;
   }

   NamedSTLMap & <B><FONT color="#000080">operator</FONT></B> = (<B><FONT color="#000080">const</FONT></B> NamedSTLMap & m)
   {
     stlmaps = m.stlmaps;
     <B><FONT color="#000080">return</FONT></B>(*<B><FONT color="#000080">this</FONT></B>);
   }   

   <B><FONT color="#000080">long</FONT></B> Size(<B><FONT color="#000080">void</FONT></B>)
   {
     <B><FONT color="#000080">return</FONT></B>(stlmaps.size());
   }

   STLMap * Find(string s)
   {
     <B><FONT color="#000080">if</FONT></B>(stlmaps.find(s) != stlmaps.end())
     {
       <B><FONT color="#000080">return</FONT></B>(&stlmaps[s]);
     }
     <B><FONT color="#000080">return</FONT></B>(NULL);
   }

   <B><FONT color="#000080">bool</FONT></B> Insert(string gg, STLMap * p)
   {
       pair&lt;map&lt;string, STLMap, less&lt;string&gt; &gt;::iterator, <B><FONT color="#000080">bool</FONT></B>&gt; bb;
       bb = stlmaps.insert(map&lt;string, STLMap, less&lt;string&gt; &gt;::value_type(gg, *p));
       <B><FONT color="#000080">return</FONT></B>(bb.second);
   }
};

<I><FONT color="#008080">// MemInstDat is an object used in the memory manager's array</FONT></I>
<I><FONT color="#008080">// The memory manager for user allocated memory keeps track of memory addresss</FONT></I>
<I><FONT color="#008080">// and types so they may be deleted with c++ syntax</FONT></I>

<B><FONT color="#000080">class</FONT></B> MemInstDat
{
  <B><FONT color="#000080">void</FONT></B> * memadr;
  <B><FONT color="#000080">int</FONT></B> memtype;
  <B><FONT color="#000080">long</FONT></B> memsize;
  <B><FONT color="#000080">long</FONT></B> destruct_hint;  <I><FONT color="#008080">//</FONT></I>

<B><FONT color="#000080">public</FONT></B>:

   MemInstDat()
   {
     memadr = NULL;
     memtype = <FONT color="#800000">0</FONT>;
     memsize = <FONT color="#800000">0</FONT>;
     destruct_hint = <FONT color="#800000">0</FONT>;
   }

   MemInstDat(<B><FONT color="#000080">const</FONT></B> MemInstDat& md)
   {
     memadr = md.memadr;
     memtype = md.memtype;
     memsize = md.memsize;
     destruct_hint = md.destruct_hint;
   }

  MemInstDat(<B><FONT color="#000080">void</FONT></B> *anadr, <B><FONT color="#000080">int</FONT></B> type, <B><FONT color="#000080">long</FONT></B> memsi, <B><FONT color="#000080">long</FONT></B> dst = <FONT color="#800000">0</FONT>)
   {
     memadr = anadr;
     memtype = type;
     memsize = memsi;
     destruct_hint = dst;
   }

   <B><FONT color="#000080">enum</FONT></B> MemType
   {
     m_Empty,
     m_CharArray,
     m_Short,
     m_Long,
     m_ShortArray,
     m_LongArray,
     m_string,
     m_Class,
     m_RSData,
     m_STLVectIterator,
     m_STLVect,
     m_STLMapIterator,
     m_STLMap,
     m_UserTypes = <FONT color="#800000">100</FONT>,
   };

   MemInstDat& <B><FONT color="#000080">operator</FONT></B> = (<B><FONT color="#000080">const</FONT></B> MemInstDat& md)
   {
     memadr = md.memadr;
     memtype = md.memtype;
     memsize = md.memsize;
     <B><FONT color="#000080">return</FONT></B>(*<B><FONT color="#000080">this</FONT></B>);
   }

   <B><FONT color="#000080">int</FONT></B> Type(<B><FONT color="#000080">void</FONT></B>)
   {
     <B><FONT color="#000080">return</FONT></B>(memtype);
   }

   <B><FONT color="#000080">void</FONT></B> * Addr(<B><FONT color="#000080">void</FONT></B>)
   {
     <B><FONT color="#000080">return</FONT></B>(memadr);
   }

   <B><FONT color="#000080">long</FONT></B> Size(<B><FONT color="#000080">void</FONT></B>)
   {
     <B><FONT color="#000080">return</FONT></B>(memsize);
   }

   <B><FONT color="#000080">long</FONT></B> Hint()
   {
     <B><FONT color="#000080">return</FONT></B>(destruct_hint);
   }

   <B><FONT color="#000080">bool</FONT></B> SameAdr(<B><FONT color="#000080">void</FONT></B> * vv)
   {
     <B><FONT color="#000080">if</FONT></B>(vv == memadr)
     {
       <B><FONT color="#000080">return</FONT></B>(true);
     }
     <B><FONT color="#000080">return</FONT></B>(false);
   }

};


<I><FONT color="#008080">// MemoryMung is the  memory manager for user allocated memory</FONT></I>
<I><FONT color="#008080">// It keeps track of memory addresss and types so they may be deleted </FONT></I>
<I><FONT color="#008080">// with c++ syntax</FONT></I>
<B><FONT color="#000080">class</FONT></B> MemoryMung
{
  vector&lt;MemInstDat&gt; memdata;
  MemInstDat wrkmid;
 
<B><FONT color="#000080">public</FONT></B>:
  MemoryMung()
  {
    memdata.reserve(<FONT color="#800000">400</FONT>);
  }

 MemoryMung(MemoryMung & mm)
  {
    memdata = mm.memdata;
  }

 MemoryMung& <B><FONT color="#000080">operator</FONT></B> = (<B><FONT color="#000080">const</FONT></B> MemoryMung & mm)
  {
    memdata = mm.memdata;
    <B><FONT color="#000080">return</FONT></B>(*<B><FONT color="#000080">this</FONT></B>);
  }

  ~MemoryMung()
  {
    <B><FONT color="#000080">while</FONT></B>(memdata.size() != <FONT color="#800000">0</FONT>)
    {
      MemInstDat aa = memdata[<FONT color="#800000">0</FONT>];
      DeleteMem(aa.Addr(), aa.Type());
    }
  }

 <B><FONT color="#000080">int</FONT></B> FindMem(<B><FONT color="#000080">void</FONT></B>* vv)
 {
   <B><FONT color="#000080">for</FONT></B> (<B><FONT color="#000080">int</FONT></B> ii = <FONT color="#800000">0</FONT>;ii &lt; memdata.size();ii++)
   {
     <B><FONT color="#000080">if</FONT></B>(memdata[ii].SameAdr(vv))
     {
       <B><FONT color="#000080">return</FONT></B>(ii);
     }
   }
   <B><FONT color="#000080">return</FONT></B>(-<FONT color="#800000">1</FONT>);
 }

 <B><FONT color="#000080">int</FONT></B> InsertMem(<B><FONT color="#000080">void</FONT></B> * vv, <B><FONT color="#000080">int</FONT></B> ty, <B><FONT color="#000080">long</FONT></B> sz, <B><FONT color="#000080">long</FONT></B> hint = <FONT color="#800000">0</FONT>)
 {
    <B><FONT color="#000080">if</FONT></B>(FindMem(vv) &gt;= <FONT color="#800000">0</FONT>)
    {
<I><FONT color="#008080">//     error address already allocated and not de-alocated</FONT></I>
        <B><FONT color="#000080">return</FONT></B>(false);
    }
    <B><FONT color="#000080">else</FONT></B>
    {
      MemInstDat* mid = <B><FONT color="#000080">new</FONT></B> MemInstDat(vv, ty, sz, hint);
      <B><FONT color="#000080">if</FONT></B>((memdata.capacity() - memdata.size()) &lt; <FONT color="#800000">20</FONT>)
      {
        memdata.reserve((memdata.size() + <FONT color="#800000">50</FONT>));

      }
      memdata.push_back(*mid);
      <B><FONT color="#000080">delete</FONT></B> mid;
      <B><FONT color="#000080">return</FONT></B>(true);
    }
 }

 <B><FONT color="#000080">bool</FONT></B> RemoveMem(<B><FONT color="#000080">void</FONT></B> * vv, <B><FONT color="#000080">int</FONT></B> ty)
 {
    <B><FONT color="#000080">int</FONT></B> mm;
    <B><FONT color="#000080">if</FONT></B>((mm = FindMem(vv)) != (-<FONT color="#800000">1</FONT>))
    {
      wrkmid = memdata[mm];
      <B><FONT color="#000080">if</FONT></B>(wrkmid.Type() == ty)
      {
         memdata.erase(memdata.begin() + mm);
      }
      <B><FONT color="#000080">return</FONT></B>(true);
    }
    <B><FONT color="#000080">else</FONT></B>
    {  
<I><FONT color="#008080">//      error memory not found </FONT></I>
        <B><FONT color="#000080">return</FONT></B>(false);
    }
 }

 <B><FONT color="#000080">bool</FONT></B> IsMem(<B><FONT color="#000080">void</FONT></B> * vv, <B><FONT color="#000080">int</FONT></B> ty)
 {
    <B><FONT color="#000080">int</FONT></B> mm;
    <B><FONT color="#000080">if</FONT></B>((mm = FindMem(vv)) != (-<FONT color="#800000">1</FONT>))
    {
      wrkmid = memdata[mm];
      <B><FONT color="#000080">if</FONT></B>(wrkmid.Type() == ty)
      {
         <B><FONT color="#000080">return</FONT></B>(true);
      }
      <B><FONT color="#000080">return</FONT></B>(false);
    }
    <B><FONT color="#000080">else</FONT></B>
    {  
<I><FONT color="#008080">//     memory not found </FONT></I>
        <B><FONT color="#000080">return</FONT></B>(false);
    }
 }

 <B><FONT color="#000080">long</FONT></B> MemSize(<B><FONT color="#000080">void</FONT></B> * vv)
 {
    <B><FONT color="#000080">int</FONT></B> mm;
    <B><FONT color="#000080">if</FONT></B>((mm = FindMem(vv)) != (-<FONT color="#800000">1</FONT>))
    {
      wrkmid = memdata[mm];      
      <B><FONT color="#000080">return</FONT></B>(wrkmid.Size());
    }
    <B><FONT color="#000080">else</FONT></B>
    {  
<I><FONT color="#008080">//     memory not found </FONT></I>
        <B><FONT color="#000080">return</FONT></B>(0l);
    }
 }

 <B><FONT color="#000080">int</FONT></B> DeleteMem(<B><FONT color="#000080">void</FONT></B> * vv, <B><FONT color="#000080">int</FONT></B> ty)
 {
    <B><FONT color="#000080">bool</FONT></B> rmv = RemoveMem(vv, ty);
    <B><FONT color="#000080">if</FONT></B>(rmv == true)
    {
       <B><FONT color="#000080">char</FONT></B> * ar;

       <B><FONT color="#000080">switch</FONT></B>(wrkmid.Type())
       {
        <B><FONT color="#000080">case</FONT></B> MemInstDat::m_Empty:
           <B><FONT color="#000080">break</FONT></B>;
        <B><FONT color="#000080">case</FONT></B> MemInstDat::m_CharArray:
           ar = ((<B><FONT color="#000080">char</FONT></B>*) wrkmid.Addr()); 
           <B><FONT color="#000080">delete</FONT></B> ar;
           <B><FONT color="#000080">break</FONT></B>;
        <B><FONT color="#000080">case</FONT></B> MemInstDat::m_Short:
           <B><FONT color="#000080">delete</FONT></B> ((<B><FONT color="#000080">short</FONT></B> *) wrkmid.Addr());
           <B><FONT color="#000080">break</FONT></B>;
        <B><FONT color="#000080">case</FONT></B> MemInstDat::m_Long:
           <B><FONT color="#000080">delete</FONT></B> ((<B><FONT color="#000080">long</FONT></B> *) wrkmid.Addr());
           <B><FONT color="#000080">break</FONT></B>;
        <B><FONT color="#000080">case</FONT></B> MemInstDat::m_ShortArray:
           <B><FONT color="#000080">delete</FONT></B> [] ((<B><FONT color="#000080">short</FONT></B> *) wrkmid.Addr());
           <B><FONT color="#000080">break</FONT></B>;
        <B><FONT color="#000080">case</FONT></B> MemInstDat::m_LongArray:
           <B><FONT color="#000080">delete</FONT></B> [] ((<B><FONT color="#000080">long</FONT></B> *) wrkmid.Addr());
           <B><FONT color="#000080">break</FONT></B>;
        <B><FONT color="#000080">case</FONT></B> MemInstDat::m_string:
           <B><FONT color="#000080">delete</FONT></B> ((string *) wrkmid.Addr());
           <B><FONT color="#000080">break</FONT></B>;
        <B><FONT color="#000080">case</FONT></B> MemInstDat::m_Class:
           <B><FONT color="#000080">delete</FONT></B> [] ((<B><FONT color="#000080">char</FONT></B> *) wrkmid.Addr());
           <B><FONT color="#000080">break</FONT></B>;
        <B><FONT color="#000080">case</FONT></B> MemInstDat::m_RSData:
            <B><FONT color="#000080">delete</FONT></B> ((RSData *) wrkmid.Addr()); 
            <B><FONT color="#000080">break</FONT></B>;
        <B><FONT color="#000080">case</FONT></B> MemInstDat::m_STLVect:
            <B><FONT color="#000080">delete</FONT></B> ((STLVect *) wrkmid.Addr()); 
            <B><FONT color="#000080">break</FONT></B>;
        <B><FONT color="#000080">case</FONT></B> MemInstDat::m_STLVectIterator:
            <B><FONT color="#000080">delete</FONT></B> ((STLVectIterator *) wrkmid.Addr()); 
            <B><FONT color="#000080">break</FONT></B>;
        <B><FONT color="#000080">case</FONT></B> MemInstDat::m_STLMap:
            <B><FONT color="#000080">delete</FONT></B> ((STLMap *) wrkmid.Addr()); 
            <B><FONT color="#000080">break</FONT></B>;
        <B><FONT color="#000080">case</FONT></B> MemInstDat::m_STLMapIterator:
            <B><FONT color="#000080">delete</FONT></B> ((STLMapIterator *) wrkmid.Addr()); 
            <B><FONT color="#000080">break</FONT></B>;

        <B><FONT color="#000080">default</FONT></B>:
            <B><FONT color="#000080">return</FONT></B>(false);
           <B><FONT color="#000080">break</FONT></B>;
       }
       <B><FONT color="#000080">return</FONT></B>(true);
    }
    <B><FONT color="#000080">else</FONT></B>
    {
      <B><FONT color="#000080">return</FONT></B>(false);
    }
 }

 <B><FONT color="#000080">void</FONT></B> * AllocateType(<B><FONT color="#000080">int</FONT></B> ty, <B><FONT color="#000080">int</FONT></B> sz, <B><FONT color="#000080">long</FONT></B> hint = <FONT color="#800000">0</FONT>)
 {
    <B><FONT color="#000080">void</FONT></B> * vv;
    string * st;

     <B><FONT color="#000080">switch</FONT></B>(ty)
       {
         <B><FONT color="#000080">case</FONT></B> MemInstDat::m_CharArray:
           vv = (<B><FONT color="#000080">void</FONT></B> *) <B><FONT color="#000080">new</FONT></B> <B><FONT color="#000080">char</FONT></B>[sz];
           InsertMem(vv, ty, sz);
           <B><FONT color="#000080">break</FONT></B>;
        <B><FONT color="#000080">case</FONT></B> MemInstDat::m_Short:
           vv = (<B><FONT color="#000080">void</FONT></B> *) <B><FONT color="#000080">new</FONT></B> <B><FONT color="#000080">short</FONT></B>;
           InsertMem(vv, ty, <B><FONT color="#000080">sizeof</FONT></B>(<B><FONT color="#000080">short</FONT></B>));
           <B><FONT color="#000080">break</FONT></B>;
        <B><FONT color="#000080">case</FONT></B> MemInstDat::m_Long:
           vv = (<B><FONT color="#000080">void</FONT></B> *) <B><FONT color="#000080">new</FONT></B> <B><FONT color="#000080">long</FONT></B>;
           InsertMem(vv, ty, <B><FONT color="#000080">sizeof</FONT></B>(<B><FONT color="#000080">long</FONT></B>));
           <B><FONT color="#000080">break</FONT></B>;
        <B><FONT color="#000080">case</FONT></B> MemInstDat::m_ShortArray:
           vv = (<B><FONT color="#000080">void</FONT></B> *) <B><FONT color="#000080">new</FONT></B> <B><FONT color="#000080">short</FONT></B>[sz];
           InsertMem(vv, ty, sz*<B><FONT color="#000080">sizeof</FONT></B>(<B><FONT color="#000080">short</FONT></B>));
           <B><FONT color="#000080">break</FONT></B>;
        <B><FONT color="#000080">case</FONT></B> MemInstDat::m_LongArray:
           vv = (<B><FONT color="#000080">void</FONT></B> *) <B><FONT color="#000080">new</FONT></B> <B><FONT color="#000080">long</FONT></B>[sz];
           InsertMem(vv, ty, sz*<B><FONT color="#000080">sizeof</FONT></B>(<B><FONT color="#000080">long</FONT></B>));
           <B><FONT color="#000080">break</FONT></B>;
       <B><FONT color="#000080">case</FONT></B> MemInstDat::m_string:
           st = <B><FONT color="#000080">new</FONT></B> string;
           st-&gt;reserve(sz);
           vv = (<B><FONT color="#000080">void</FONT></B> *) st;
           InsertMem(vv, ty,<B><FONT color="#000080">sizeof</FONT></B>(string));
           <B><FONT color="#000080">break</FONT></B>;
         <B><FONT color="#000080">case</FONT></B> MemInstDat::m_Class:
           vv = (<B><FONT color="#000080">void</FONT></B> *) <B><FONT color="#000080">new</FONT></B> <B><FONT color="#000080">char</FONT></B>[sz];
           InsertMem(vv, ty, sz, hint);
           <B><FONT color="#000080">break</FONT></B>;
        <B><FONT color="#000080">case</FONT></B> MemInstDat::m_RSData:
           vv = (<B><FONT color="#000080">void</FONT></B> *) <B><FONT color="#000080">new</FONT></B> RSData;
           InsertMem(vv, ty, <B><FONT color="#000080">sizeof</FONT></B>(RSData));
           <B><FONT color="#000080">break</FONT></B>;
        <B><FONT color="#000080">case</FONT></B> MemInstDat::m_STLVect:
           vv = (<B><FONT color="#000080">void</FONT></B> *) <B><FONT color="#000080">new</FONT></B> STLVect;
           InsertMem(vv, ty, <B><FONT color="#000080">sizeof</FONT></B>(STLVect()));
           <B><FONT color="#000080">break</FONT></B>;
        <B><FONT color="#000080">case</FONT></B> MemInstDat::m_STLVectIterator:
           vv = (<B><FONT color="#000080">void</FONT></B> *) <B><FONT color="#000080">new</FONT></B> STLVectIterator;
           InsertMem(vv, ty, <B><FONT color="#000080">sizeof</FONT></B>(STLVectIterator));
           <B><FONT color="#000080">break</FONT></B>;
        <B><FONT color="#000080">case</FONT></B> MemInstDat::m_STLMap:
           vv = (<B><FONT color="#000080">void</FONT></B> *) <B><FONT color="#000080">new</FONT></B> STLMap;
           InsertMem(vv, ty, <B><FONT color="#000080">sizeof</FONT></B>(STLMap));
           <B><FONT color="#000080">break</FONT></B>;
        <B><FONT color="#000080">case</FONT></B> MemInstDat::m_STLMapIterator:
           vv = (<B><FONT color="#000080">void</FONT></B> *) <B><FONT color="#000080">new</FONT></B> STLMapIterator;
           InsertMem(vv, ty, <B><FONT color="#000080">sizeof</FONT></B>(STLMapIterator));
           <B><FONT color="#000080">break</FONT></B>;
        <B><FONT color="#000080">default</FONT></B>:
            vv = NULL;
           <B><FONT color="#000080">break</FONT></B>;
       }
    <B><FONT color="#000080">return</FONT></B>(vv);
 }

 <B><FONT color="#000080">int</FONT></B> Typeof(<B><FONT color="#000080">void</FONT></B> * p)
 {
    <B><FONT color="#000080">int</FONT></B> mm;
    <B><FONT color="#000080">if</FONT></B>((mm = FindMem(p)) != (-<FONT color="#800000">1</FONT>))
    {
      wrkmid = memdata[mm];
      <B><FONT color="#000080">return</FONT></B>((wrkmid.Type()));
    }
    <B><FONT color="#000080">else</FONT></B>
    {  
<I><FONT color="#008080">//     memory not found </FONT></I>
        <B><FONT color="#000080">return</FONT></B>(-<FONT color="#800000">1</FONT>);
    }
 }

 <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> Hintof(<B><FONT color="#000080">void</FONT></B> * p)
 {
    <B><FONT color="#000080">int</FONT></B> mm;
    <B><FONT color="#000080">if</FONT></B>((mm = FindMem(p)) != (-<FONT color="#800000">1</FONT>))
    {
      wrkmid = memdata[mm];
      <B><FONT color="#000080">return</FONT></B>((wrkmid.Hint()));
    }
    <B><FONT color="#000080">else</FONT></B>
    {  
<I><FONT color="#008080">//     memory not found </FONT></I>
        <B><FONT color="#000080">return</FONT></B>(-<FONT color="#800000">1</FONT>);
    }
 }

};


<I><FONT color="#008080">// InterpreterData is the data needed by an interpreter thread</FONT></I>
<I><FONT color="#008080">// it contains the dictonary, the memory manager, the data stack, the return stack</FONT></I>
<I><FONT color="#008080">// the Errors array, the output stream, a text parser pointer, </FONT></I>
<I><FONT color="#008080">// and the word being compiled (if any) and the Primitives object </FONT></I>
<I><FONT color="#008080">// contaning all primitive calls</FONT></I>

<B><FONT color="#000080">class</FONT></B> InterpreterData
{
  vector &lt; RSData  &gt; rets;  <I><FONT color="#008080">// return stack</FONT></I>
  vector &lt; <B><FONT color="#000080">long</FONT></B>  &gt; dats;    <I><FONT color="#008080">// data stack</FONT></I>
  vector &lt; <B><FONT color="#000080">long</FONT></B>  &gt; aux;     <I><FONT color="#008080">// auxillary data stack</FONT></I>
  vector &lt; <B><FONT color="#000080">double</FONT></B> &gt; flt;    <I><FONT color="#008080">// floating point stack</FONT></I>
  NamedSTLMap namedmaps;    <I><FONT color="#008080">// declared maps</FONT></I>
  NamedSTLVect namedvects;  <I><FONT color="#008080">// declared vects</FONT></I>
  <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> numericbase; <I><FONT color="#008080">// number base in use</FONT></I>
  <B><FONT color="#000080">char</FONT></B> nbuffer[<FONT color="#800000">120</FONT>];
  <B><FONT color="#000080">char</FONT></B> nobuffer[<FONT color="#800000">120</FONT>];
  <B><FONT color="#000080">int</FONT></B> nbufpos;
  <B><FONT color="#000080">bool</FONT></B> nbufflg;
  <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> INloc;
  <B><FONT color="#000080">char</FONT></B> wordbuf[<FONT color="#800000">1216</FONT>];
  <B><FONT color="#000080">char</FONT></B> * nwordbuf;
  
  RSData exvA;
  RSData exv0;             
  <B><FONT color="#000080">int</FONT></B> retdepth;            <I><FONT color="#008080">// the depth of the return stack</FONT></I>
  MemoryMung mmanager;     <I><FONT color="#008080">// the memory manager</FONT></I>

  Dictonary * dictonary;   <I><FONT color="#008080">// the dictonary</FONT></I>
  ClassDescriptions * cdescript; <I><FONT color="#008080">// class decriptions</FONT></I>
  Parser * pparser;        <I><FONT color="#008080">// the parser</FONT></I>
  Primitives *allprim;     <I><FONT color="#008080">// the primitives</FONT></I>
  Errors Err;              <I><FONT color="#008080">// the errors class</FONT></I>
  string Output;           <I><FONT color="#008080">// the output string</FONT></I>
  string OutFile;          <I><FONT color="#008080">// the output file name</FONT></I>
  ofstream outstream;      <I><FONT color="#008080">// the file output stream</FONT></I>
  ostrstream osstring;     <I><FONT color="#008080">// the string output stream</FONT></I>
  string tempintrp;
  string DebugStr;
  string TraceFile;        <I><FONT color="#008080">// the tracing file name</FONT></I>
  ofstream tracestream;    <I><FONT color="#008080">// the tracing stream</FONT></I>
  <B><FONT color="#000080">bool</FONT></B> tracing;            <I><FONT color="#008080">// true when traceing is on</FONT></I>
  <B><FONT color="#000080">bool</FONT></B> usestdout;          <I><FONT color="#008080">// use the condole stdout for output</FONT></I>
  <B><FONT color="#000080">bool</FONT></B> usestringout;       <I><FONT color="#008080">// use the string output strbuffer for output</FONT></I>
  <B><FONT color="#000080">bool</FONT></B> usestringerror;     <I><FONT color="#008080">// use the string error strbuffer for error output</FONT></I>
  Word * building;         <I><FONT color="#008080">// the word being compiled</FONT></I>

  <B><FONT color="#000080">int</FONT></B> compiling;           <I><FONT color="#008080">// true when compiling</FONT></I>
  <B><FONT color="#000080">int</FONT></B> immediate;
  <B><FONT color="#000080">int</FONT></B> ufcnt; 

<B><FONT color="#000080">public</FONT></B>:

  InterpreterData();
  InterpreterData(<B><FONT color="#000080">const</FONT></B> InterpreterData& idat);
  ~InterpreterData();
  InterpreterData & <B><FONT color="#000080">operator</FONT></B> = (<B><FONT color="#000080">const</FONT></B> InterpreterData& idat);

  <B><FONT color="#000080">enum</FONT></B> CompFlag
  {
    ExecuteCompile =   <FONT color="#800000">0x01</FONT>,
    Hidden =           <FONT color="#800000">0x02</FONT>,
    Private =          <FONT color="#800000">0x04</FONT>,
    Protected =        <FONT color="#800000">0x08</FONT>,
    Public =          <FONT color="#800000">0x010</FONT>,
    ArrayType =       <FONT color="#800000">0x020</FONT>,
    ClassType =       <FONT color="#800000">0x040</FONT>
  };

<I><FONT color="#008080">// return stack methods</FONT></I>

<I><FONT color="#008080">// Function name    : PushR</FONT></I>
<I><FONT color="#008080">// Description      : push the return stack</FONT></I>
<I><FONT color="#008080">// RSData type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : const RSData& aret</FONT></I>
 <B><FONT color="#000080">void</FONT></B> PushR(<B><FONT color="#000080">const</FONT></B> RSData& aret)
 {
     try
     {
       rets.push_back(aret);
       retdepth = rets.size();
     }
     <B><FONT color="#000080">catch</FONT></B>(...)
     {
        <B><FONT color="#000080">if</FONT></B>(rets.capacity() - rets.size() &lt; <FONT color="#800000">5</FONT>)
        {
           rets.reserve(rets.size() + <FONT color="#800000">10</FONT>);
           rets.push_back(aret);
           retdepth = rets.size();
        }
     }
 }


<I><FONT color="#008080">// Function name    : PopR</FONT></I>
<I><FONT color="#008080">// Description      : pop the return stack</FONT></I>
<I><FONT color="#008080">// RSData type      : RSData </FONT></I>
<I><FONT color="#008080">// Argument         : void</FONT></I>
 RSData PopR(<B><FONT color="#000080">void</FONT></B>)
 {
   <B><FONT color="#000080">if</FONT></B>(retdepth &gt; <FONT color="#800000">0</FONT>)
   {
        exvA = rets.back();
        rets.pop_back();
        retdepth = rets.size();
   }
   <B><FONT color="#000080">else</FONT></B>
   {
      ufcnt++;
      <B><FONT color="#000080">if</FONT></B>( ufcnt &lt;= <FONT color="#800000">1</FONT>)
      {
        string aa = <FONT color="#800000">"Fatal Error"</FONT>;
        Err.ShowError(Errors::RETURN_STACK_UNDERFLOW, *<B><FONT color="#000080">this</FONT></B>, aa);
      }
      <B><FONT color="#000080">else</FONT></B>
      {
        exit(<FONT color="#800000">0</FONT>);
      }
   }
   
   <B><FONT color="#000080">return</FONT></B>(exvA);
 }


<I><FONT color="#008080">// Function name    : SetRsv</FONT></I>
<I><FONT color="#008080">// Description      : re-set a return stack element</FONT></I>
<I><FONT color="#008080">// RSData type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : RSData& aret</FONT></I>
<I><FONT color="#008080">// Argument         : int ind</FONT></I>
 <B><FONT color="#000080">void</FONT></B> SetRsv(RSData& aret, <B><FONT color="#000080">int</FONT></B> ind)
 {
     <B><FONT color="#000080">int</FONT></B> ep = (rets.size() - <FONT color="#800000">1</FONT>) - ind;
     <B><FONT color="#000080">if</FONT></B> (ep &gt;= <FONT color="#800000">0</FONT> && ep &lt; rets.size())
     {
       rets[ep] = aret;
     }
     <B><FONT color="#000080">else</FONT></B>
     {
       string aa = <FONT color="#800000">"bad stack pos set"</FONT>;
       Err.ShowError(Errors::BAD_STACKPOSITION, *<B><FONT color="#000080">this</FONT></B>, aa);
     }
 }


<I><FONT color="#008080">// Function name    : GetRsv</FONT></I>
<I><FONT color="#008080">// Description      : get a return stack element</FONT></I>
<I><FONT color="#008080">// RSData type      : RSData </FONT></I>
<I><FONT color="#008080">// Argument         : int ind</FONT></I>
 RSData GetRsv(<B><FONT color="#000080">int</FONT></B> ind)
 {
    <B><FONT color="#000080">int</FONT></B> ep = (rets.size() - <FONT color="#800000">1</FONT>) - ind;
    <B><FONT color="#000080">if</FONT></B> (ep &gt;= <FONT color="#800000">0</FONT> && ep &lt; rets.size())
     {
       <B><FONT color="#000080">return</FONT></B>(rets[ep]);
     }
     <B><FONT color="#000080">else</FONT></B>
     {
       string aa;
       aa.reserve(<FONT color="#800000">120</FONT>);
       aa = <FONT color="#800000">"bad stack pos get"</FONT>;
       Err.ShowError(Errors::BAD_STACKPOSITION, *<B><FONT color="#000080">this</FONT></B>, aa);
     }
     <B><FONT color="#000080">return</FONT></B>(exvA);
 }


<I><FONT color="#008080">// Function name    : SetExv</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : RSData& ev</FONT></I>
<B><FONT color="#000080">void</FONT></B> SetExv(RSData& ev)
{
  exv0 = ev;
}

<I><FONT color="#008080">// Function name    : GetExv</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : RSData& </FONT></I>
RSData& GetExv()
{
  <B><FONT color="#000080">return</FONT></B>(exv0);
}

<I><FONT color="#008080">// Function name    : IncExv</FONT></I>
<I><FONT color="#008080">// Description      : increment the element index of the word executing </FONT></I>
<I><FONT color="#008080">// RSData type      : void </FONT></I>
 <B><FONT color="#000080">void</FONT></B> IncExv()
 {
<I><FONT color="#008080">//   rets.back().IncWind();</FONT></I>
<I><FONT color="#008080">//   exv0 = rets.back();</FONT></I>
     exv0.IncWind();
 }


<I><FONT color="#008080">// Function name    : ExvWord</FONT></I>
<I><FONT color="#008080">// Description      : get a pointer to the word of the word executing</FONT></I>
<I><FONT color="#008080">// RSData type      : Word* </FONT></I>
 Word* ExvWord()
 {
<I><FONT color="#008080">//   return((rets.back().Code()));</FONT></I>
     <B><FONT color="#000080">return</FONT></B>(exv0.Code());
 }

<I><FONT color="#008080">// Function name    : ExvIndex</FONT></I>
<I><FONT color="#008080">// Description      : get a element index of  the word of the word executing</FONT></I>
<I><FONT color="#008080">// RSData type      : int </FONT></I>
 <B><FONT color="#000080">int</FONT></B> ExvIndex()
 {
<I><FONT color="#008080">//   return((rets.back().Index()));</FONT></I>
     <B><FONT color="#000080">return</FONT></B>((exv0.Index()));
 }

<I><FONT color="#008080">// -----------------------------data stack words------------------------</FONT></I>

<I><FONT color="#008080">// Function name    : PushD</FONT></I>
<I><FONT color="#008080">// Description      : push onto the data stack</FONT></I>
<I><FONT color="#008080">// RSData type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : long dd</FONT></I>
 <B><FONT color="#000080">void</FONT></B> PushD(<B><FONT color="#000080">long</FONT></B> dd)
 {
   try
   {
      dats.push_back(dd);
   }
   <B><FONT color="#000080">catch</FONT></B>(...)
   {
     <B><FONT color="#000080">if</FONT></B>((dats.capacity() - dats.size()) &lt; <FONT color="#800000">100</FONT>)
     {
        dats.reserve((dats.size() + <FONT color="#800000">1000</FONT>));
        dats.push_back(dd);
     }
   }
 }

<I><FONT color="#008080">// Function name    : PushD</FONT></I>
<I><FONT color="#008080">// Description      : push a pointer onto the data stack</FONT></I>
<I><FONT color="#008080">// RSData type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : void * dd</FONT></I>
 <B><FONT color="#000080">void</FONT></B> PushD(<B><FONT color="#000080">void</FONT></B> * dd)
 {
   try
   {
      dats.push_back((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>) dd);
   }
   <B><FONT color="#000080">catch</FONT></B>(...)
   {
     <B><FONT color="#000080">if</FONT></B>((dats.capacity() - dats.size()) &lt; <FONT color="#800000">100</FONT>)
     {
        dats.reserve((dats.size() + <FONT color="#800000">1000</FONT>));
        dats.push_back((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>) dd);
     }
   }
 }


<I><FONT color="#008080">// Function name    : PopD</FONT></I>
<I><FONT color="#008080">// Description      : pop an item from the data stack</FONT></I>
<I><FONT color="#008080">// RSData type      : long </FONT></I>
<I><FONT color="#008080">// Argument         : void</FONT></I>
 <B><FONT color="#000080">long</FONT></B> PopD(<B><FONT color="#000080">void</FONT></B>)
 {
   <B><FONT color="#000080">if</FONT></B>(dats.empty())
   {
       Err.ShowError(Errors::STACK_UNDERFLOW, *<B><FONT color="#000080">this</FONT></B>, NameRunning());
       <B><FONT color="#000080">return</FONT></B>(<FONT color="#800000">0</FONT>);
   }

   <B><FONT color="#000080">long</FONT></B>  rv = dats.back();
   dats.pop_back();
   <B><FONT color="#000080">return</FONT></B>(rv);
 }


<I><FONT color="#008080">// Function name    : GetDatv</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : long </FONT></I>
<I><FONT color="#008080">// Argument         : int ind</FONT></I>
<B><FONT color="#000080">long</FONT></B> GetDatv(<B><FONT color="#000080">int</FONT></B> ind)
 {
    <B><FONT color="#000080">int</FONT></B> ep = (dats.size() - <FONT color="#800000">1</FONT>) - ind;
    <B><FONT color="#000080">if</FONT></B> (ep &gt;= <FONT color="#800000">0</FONT> && ep &lt; dats.size())
     {
       <B><FONT color="#000080">return</FONT></B>(dats[ep]);
     }
     <B><FONT color="#000080">else</FONT></B>
     {
       string aa = <FONT color="#800000">"bad stack pos get"</FONT>;
       Err.ShowError(Errors::BAD_STACKPOSITION, *<B><FONT color="#000080">this</FONT></B>, aa);
     }
    <B><FONT color="#000080">return</FONT></B>(<FONT color="#800000">0</FONT>);
 }


<I><FONT color="#008080">// Function name    : RollDatv</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : int ind</FONT></I>
<B><FONT color="#000080">void</FONT></B> RollDatv(<B><FONT color="#000080">int</FONT></B> ind)
{
    <B><FONT color="#000080">long</FONT></B> ep = (dats.size() - <FONT color="#800000">1</FONT>) - ind;
    <B><FONT color="#000080">if</FONT></B> (ep &gt;= <FONT color="#800000">0</FONT> && ep &lt; dats.size())
     {
       <B><FONT color="#000080">long</FONT></B> ra = dats[ep];
       dats.erase(&dats[ep]);
       dats.push_back(ra);
     }
     <B><FONT color="#000080">else</FONT></B>
     {
       string aa = <FONT color="#800000">"bad stack pos get"</FONT>;
       Err.ShowError(Errors::BAD_STACKPOSITION, *<B><FONT color="#000080">this</FONT></B>, aa);
     }
}




<I><FONT color="#008080">// Function name    : ShowDatv</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : void</FONT></I>
<B><FONT color="#000080">void</FONT></B> ShowDatv(<B><FONT color="#000080">void</FONT></B>)
{
    <B><FONT color="#000080">int</FONT></B> ds = dats.size();
    <B><FONT color="#000080">int</FONT></B> ep, smax, ii;
    
    <B><FONT color="#000080">if</FONT></B>(ds &gt; <FONT color="#800000">0</FONT>)
    {
        <B><FONT color="#000080">if</FONT></B>(usestdout)
        {
            cout &lt;&lt; <FONT color="#800000">"Stack: "</FONT>;
        }
        <B><FONT color="#000080">if</FONT></B>(usestringout)
        {
            osstring &lt;&lt; <FONT color="#800000">"Stack: "</FONT>;
        }
        <B><FONT color="#000080">else</FONT></B>
        {
            outstream &lt;&lt; <FONT color="#800000">"Stack: "</FONT>;
        }
        smax = __min(dats.size(), <FONT color="#800000">10</FONT>);
        <B><FONT color="#000080">for</FONT></B>(ii = <FONT color="#800000">0</FONT>;ii &lt; smax;ii++)
        {
            ep = (dats.size() - <FONT color="#800000">1</FONT>) - ii;
            <B><FONT color="#000080">if</FONT></B>(usestdout)
            {
                cout &lt;&lt; dats[ep] &lt;&lt; <FONT color="#800000">" "</FONT>;
            }
            <B><FONT color="#000080">if</FONT></B>(usestringout)
            {
                osstring  &lt;&lt; dats[ep] &lt;&lt; <FONT color="#800000">" "</FONT>;
            }
            <B><FONT color="#000080">else</FONT></B>
            {
                outstream  &lt;&lt; dats[ep] &lt;&lt; <FONT color="#800000">" "</FONT>;
            }
        }
        
        LineOut();
    }
    <B><FONT color="#000080">else</FONT></B>
    {
        <B><FONT color="#000080">if</FONT></B>(usestdout)
        {
            cout &lt;&lt; <FONT color="#800000">"empty stack"</FONT> &lt;&lt; endl;
        }
        <B><FONT color="#000080">if</FONT></B>(usestringout)
        {
            osstring &lt;&lt; <FONT color="#800000">"empty stack"</FONT> &lt;&lt; endl;
        }
        <B><FONT color="#000080">else</FONT></B>
        {
            outstream &lt;&lt; <FONT color="#800000">"empty stack"</FONT> &lt;&lt; endl;
        }
    }
}

<B><FONT color="#000080">void</FONT></B> TraceDatv(<B><FONT color="#000080">void</FONT></B>)
 {
    <B><FONT color="#000080">int</FONT></B> ds = dats.size();
    <B><FONT color="#000080">int</FONT></B> ep, smax, ii;

    <B><FONT color="#000080">if</FONT></B>(ds &gt; <FONT color="#800000">0</FONT>)
    {
       tracestream &lt;&lt; <FONT color="#800000">" Stack: "</FONT>;
       smax = __min(dats.size(), <FONT color="#800000">10</FONT>);
       <B><FONT color="#000080">for</FONT></B>(ii = <FONT color="#800000">0</FONT>;ii &lt; smax;ii++)
       {
         ep = (dats.size() - <FONT color="#800000">1</FONT>) - ii;
         tracestream &lt;&lt; dats[ep] &lt;&lt; <FONT color="#800000">" "</FONT>;
       }
        tracestream &lt;&lt; endl;
    }
    <B><FONT color="#000080">else</FONT></B>
    {
       tracestream &lt;&lt; <FONT color="#800000">"empty stack"</FONT> &lt;&lt; endl; 
    }
 }

<B><FONT color="#000080">void</FONT></B> TraceAuxDatv(<B><FONT color="#000080">void</FONT></B>)
 {
    <B><FONT color="#000080">int</FONT></B> ds = aux.size();
    <B><FONT color="#000080">int</FONT></B> ep, smax, ii;

    <B><FONT color="#000080">if</FONT></B>(ds &gt; <FONT color="#800000">0</FONT>)
    {
       tracestream &lt;&lt; <FONT color="#800000">" aux: "</FONT>;
       smax = __min(aux.size(), <FONT color="#800000">10</FONT>);
       <B><FONT color="#000080">for</FONT></B>(ii = <FONT color="#800000">0</FONT>;ii &lt; smax;ii++)
       {
         ep = (aux.size() - <FONT color="#800000">1</FONT>) - ii;
         tracestream &lt;&lt; aux[ep] &lt;&lt; <FONT color="#800000">" "</FONT>;
       }
<I><FONT color="#008080">//       tracestream &lt;&lt; endl;</FONT></I>
    }
    <B><FONT color="#000080">else</FONT></B>
    {
<I><FONT color="#008080">//      tracestream &lt;&lt; " aux:empty " &lt;&lt; endl; </FONT></I>
    }
 }


<I><FONT color="#008080">// --------------------end of data stack ---------------------------</FONT></I>

 string& NameRunning(<B><FONT color="#000080">void</FONT></B>);  <I><FONT color="#008080">// the name of the running word (bug)</FONT></I>

<I><FONT color="#008080">// floating point stack words</FONT></I>


<I><FONT color="#008080">// Function name    : PushFD</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : double dd</FONT></I>
 <B><FONT color="#000080">void</FONT></B> PushFD(<B><FONT color="#000080">double</FONT></B> dd)
 {
   try
   {
     flt.push_back(dd);
   }
   <B><FONT color="#000080">catch</FONT></B>(...)
   {
     <B><FONT color="#000080">if</FONT></B>((flt.capacity() - flt.size()) &lt; <FONT color="#800000">100</FONT>)
     {
        flt.reserve((flt.size() + <FONT color="#800000">1000</FONT>));
        flt.push_back(dd);
     }      
   }
 }


<I><FONT color="#008080">// Function name    : PopFD</FONT></I>
<I><FONT color="#008080">// Description      : pop an item from the double float stack</FONT></I>
<I><FONT color="#008080">// return type      : double </FONT></I>
<I><FONT color="#008080">// Argument         : void</FONT></I>
 <B><FONT color="#000080">double</FONT></B> PopFD(<B><FONT color="#000080">void</FONT></B>)
 {
   <B><FONT color="#000080">if</FONT></B>(flt.empty())
   {
       Err.ShowError(Errors::STACK_UNDERFLOW, *<B><FONT color="#000080">this</FONT></B>, NameRunning());
       <B><FONT color="#000080">return</FONT></B>(<FONT color="#800000">0</FONT>);
   }

   <B><FONT color="#000080">double</FONT></B>  rv = flt.back();
   flt.pop_back();
   <B><FONT color="#000080">return</FONT></B>(rv);
 }


<I><FONT color="#008080">// Function name    : GetFDatv</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : double </FONT></I>
<I><FONT color="#008080">// Argument         : int ind</FONT></I>
<B><FONT color="#000080">double</FONT></B> GetFDatv(<B><FONT color="#000080">int</FONT></B> ind)
 {
    <B><FONT color="#000080">int</FONT></B> ep = (flt.size() - <FONT color="#800000">1</FONT>) - ind;
    <B><FONT color="#000080">if</FONT></B> (ep &gt;= <FONT color="#800000">0</FONT> && ep &lt; flt.size())
     {
       <B><FONT color="#000080">return</FONT></B>(flt[ep]);
     }
     <B><FONT color="#000080">else</FONT></B>
     {
       string aa;
       aa.reserve(<FONT color="#800000">120</FONT>);
       aa = <FONT color="#800000">"bad stack pos get"</FONT>;
       Err.ShowError(Errors::BAD_STACKPOSITION, *<B><FONT color="#000080">this</FONT></B>, aa);
     }
    <B><FONT color="#000080">return</FONT></B>(<FONT color="#800000">0.0</FONT>);
 }

<I><FONT color="#008080">// Function name    : RollFDatv</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : int ind</FONT></I>
<B><FONT color="#000080">void</FONT></B> RollFDatv(<B><FONT color="#000080">int</FONT></B> ind)
{
    <B><FONT color="#000080">long</FONT></B> ep = (flt.size() - <FONT color="#800000">1</FONT>) - ind;
    <B><FONT color="#000080">if</FONT></B> (ep &gt;= <FONT color="#800000">0</FONT> && ep &lt; flt.size())
     {
       <B><FONT color="#000080">long</FONT></B> ra = flt[ep];
       flt.erase(&flt[ep]);
       flt.push_back(ra);
     }
     <B><FONT color="#000080">else</FONT></B>
     {
       string aa;
       aa.reserve(<FONT color="#800000">120</FONT>);
       aa = <FONT color="#800000">"bad stack pos get"</FONT>;
       Err.ShowError(Errors::BAD_STACKPOSITION, *<B><FONT color="#000080">this</FONT></B>, aa);
     }
}

<I><FONT color="#008080">// auxillary stack words</FONT></I>

<I><FONT color="#008080">// Function name    : PushAD</FONT></I>
<I><FONT color="#008080">// Description      : push onto the auxilary data stack</FONT></I>
<I><FONT color="#008080">// RSData type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : long dd</FONT></I>
<B><FONT color="#000080">void</FONT></B> PushAD(<B><FONT color="#000080">long</FONT></B> dd)
{
    try
    {
        aux.push_back(dd);
    }
    <B><FONT color="#000080">catch</FONT></B>(...)
    {
        <B><FONT color="#000080">if</FONT></B>((aux.capacity() - aux.size()) &lt; <FONT color="#800000">100</FONT>)
        {
            aux.reserve((aux.size() + <FONT color="#800000">1000</FONT>));
            aux.push_back(dd);
        }
    }
}

<I><FONT color="#008080">// Function name    : PushAD</FONT></I>
<I><FONT color="#008080">// Description      : push a pointer onto the auxilaty data stack</FONT></I>
<I><FONT color="#008080">// RSData type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : void * dd</FONT></I>
 <B><FONT color="#000080">void</FONT></B> PushAD(<B><FONT color="#000080">void</FONT></B> * dd)
 {
   try
   {
      aux.push_back((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>) dd);
   }
   <B><FONT color="#000080">catch</FONT></B>(...)
   {
     <B><FONT color="#000080">if</FONT></B>((aux.capacity() - aux.size()) &lt; <FONT color="#800000">100</FONT>)
     {
        aux.reserve((aux.size() + <FONT color="#800000">1000</FONT>));
        aux.push_back((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>) dd);
     }
   }
 }


<I><FONT color="#008080">// Function name    : GetADatv</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : long </FONT></I>
<I><FONT color="#008080">// Argument         : int ind</FONT></I>
<B><FONT color="#000080">long</FONT></B> GetADatv(<B><FONT color="#000080">int</FONT></B> ind)
 {
    <B><FONT color="#000080">int</FONT></B> ep = (aux.size() - <FONT color="#800000">1</FONT>) - ind;
    <B><FONT color="#000080">if</FONT></B> (ep &gt;= <FONT color="#800000">0</FONT> && ep &lt; aux.size())
     {
       <B><FONT color="#000080">return</FONT></B>(aux[ep]);
     }
     <B><FONT color="#000080">else</FONT></B>
     {
       string aa;
       aa.reserve(<FONT color="#800000">120</FONT>);
       aa = <FONT color="#800000">"bad stack pos get"</FONT>;
       Err.ShowError(Errors::BAD_STACKPOSITION, *<B><FONT color="#000080">this</FONT></B>, aa);
     }
    <B><FONT color="#000080">return</FONT></B>(<FONT color="#800000">0</FONT>);
 }


<I><FONT color="#008080">// Function name    : RollADatv</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : int ind</FONT></I>
<B><FONT color="#000080">void</FONT></B> RollADatv(<B><FONT color="#000080">int</FONT></B> ind)
{
    <B><FONT color="#000080">long</FONT></B> ep = (aux.size() - <FONT color="#800000">1</FONT>) - ind;
    <B><FONT color="#000080">if</FONT></B> (ep &gt;= <FONT color="#800000">0</FONT> && ep &lt; aux.size())
     {
       <B><FONT color="#000080">long</FONT></B> ra = aux[ep];
       aux.erase(&aux[ep]);
       aux.push_back(ra);
     }
     <B><FONT color="#000080">else</FONT></B>
     {
       string aa;
       aa.reserve(<FONT color="#800000">120</FONT>);
       aa = <FONT color="#800000">"bad stack pos get"</FONT>;
       Err.ShowError(Errors::BAD_STACKPOSITION, *<B><FONT color="#000080">this</FONT></B>, aa);
     }
}

<I><FONT color="#008080">// labeled aux functions are for compilation control</FONT></I>

 <B><FONT color="#000080">void</FONT></B> PushLabeledAD(<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> label, <B><FONT color="#000080">long</FONT></B> dd)
 {
   aux.push_back((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>) dd);
   aux.push_back((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>) label);
 }

<B><FONT color="#000080">void</FONT></B> PushLabeledAD(<B><FONT color="#000080">char</FONT></B>* nam, <B><FONT color="#000080">long</FONT></B> dd)
 {  
   aux.push_back((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>) dd);     <I><FONT color="#008080">// push data</FONT></I>
   Word *ww = (dictonary-&gt;Address(nam)); 
   <B><FONT color="#000080">if</FONT></B>(ww == NULL)
   {
      aux.push_back((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>) ww);                           
      Err.ShowError(Errors::NO_SUCH_WORD, *<B><FONT color="#000080">this</FONT></B>, NameRunning());
   }
   <B><FONT color="#000080">else</FONT></B>
   {
     aux.push_back((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>) ww); <I><FONT color="#008080">// push label</FONT></I>
   }
 }

<I><FONT color="#008080">// Function name    : PopAD</FONT></I>
<I><FONT color="#008080">// Description      : pop an item from the data stack</FONT></I>
<I><FONT color="#008080">// RSData type      : long </FONT></I>
<I><FONT color="#008080">// Argument         : void</FONT></I>
 <B><FONT color="#000080">long</FONT></B> PopAD(<B><FONT color="#000080">void</FONT></B>)
 {
   <B><FONT color="#000080">if</FONT></B>(aux.empty())
   {
       Err.ShowError(Errors::AUX_STACK_UNDERFLOW, *<B><FONT color="#000080">this</FONT></B>, NameRunning());
       <B><FONT color="#000080">return</FONT></B>(<FONT color="#800000">0</FONT>);
   }

   <B><FONT color="#000080">long</FONT></B>  rv = aux.back();
   aux.pop_back();
   <B><FONT color="#000080">return</FONT></B>(rv);
 }

<B><FONT color="#000080">long</FONT></B> PopLabeledAD(<B><FONT color="#000080">void</FONT></B>)
 {
   PopAD();
   <B><FONT color="#000080">return</FONT></B>(PopAD());
 }

<B><FONT color="#000080">long</FONT></B> PeekLabeledAD(<B><FONT color="#000080">void</FONT></B>)
 {
   <B><FONT color="#000080">long</FONT></B> aa = PopAD(); <I><FONT color="#008080">// get label</FONT></I>
   <B><FONT color="#000080">long</FONT></B> bb = PopAD(); <I><FONT color="#008080">// get index</FONT></I>
   PushAD(bb);
   PushAD(aa);
   <B><FONT color="#000080">return</FONT></B>(bb);
 }

<B><FONT color="#000080">long</FONT></B> FindFirstLabeledAD(<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> label)
{
  <B><FONT color="#000080">long</FONT></B> ls = aux.size();
  <B><FONT color="#000080">int</FONT></B> ii;
  <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> lt;

  <B><FONT color="#000080">for</FONT></B> (ii = (ls -<FONT color="#800000">1</FONT>);ii &gt; <FONT color="#800000">0</FONT>;ii--)
  {
    lt = aux[ii];
    <B><FONT color="#000080">if</FONT></B>(lt == label)
    {
      <B><FONT color="#000080">return</FONT></B>(aux[ii - <FONT color="#800000">1</FONT>]);
    }
  }
  <B><FONT color="#000080">return</FONT></B>(-<FONT color="#800000">1</FONT>);
}

<B><FONT color="#000080">long</FONT></B> FindNthLabeledAD(<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> label, <B><FONT color="#000080">int</FONT></B> nn)
{
  <B><FONT color="#000080">long</FONT></B> ls = aux.size();
  <B><FONT color="#000080">int</FONT></B> ii;
  <B><FONT color="#000080">int</FONT></B> cnt = <FONT color="#800000">0</FONT>;
  <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> lt;

  <B><FONT color="#000080">for</FONT></B> (ii = (ls -<FONT color="#800000">1</FONT>);ii &gt; <FONT color="#800000">0</FONT>;ii--)
  {
    lt = aux[ii];
    <B><FONT color="#000080">if</FONT></B>(lt == label)
    {
      cnt++;
      <B><FONT color="#000080">if</FONT></B>(cnt == nn)
      {
         <B><FONT color="#000080">return</FONT></B>(aux[(ii - <FONT color="#800000">1</FONT>)]);
      }
    }
  }
  <B><FONT color="#000080">return</FONT></B>(-<FONT color="#800000">1</FONT>);
}

<B><FONT color="#000080">long</FONT></B> ExtractNthLabeledAD(<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> label, <B><FONT color="#000080">int</FONT></B> nn)
{
  <B><FONT color="#000080">long</FONT></B> ls = aux.size();
  <B><FONT color="#000080">int</FONT></B> ii;
  <B><FONT color="#000080">int</FONT></B> cnt = <FONT color="#800000">0</FONT>;
  <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> lt;

  <B><FONT color="#000080">for</FONT></B> (ii = (ls -<FONT color="#800000">1</FONT>);ii &gt; <FONT color="#800000">0</FONT>;ii--)
  {
    lt = aux[ii];
    <B><FONT color="#000080">if</FONT></B>(lt == label)
    {
      cnt++;
      <B><FONT color="#000080">if</FONT></B>(cnt == nn)
      {
         <B><FONT color="#000080">long</FONT></B> rv = aux[(ii - <FONT color="#800000">1</FONT>)];
         aux.erase(&aux[ii]);
         aux.erase(&aux[ii - <FONT color="#800000">1</FONT>]);
         <B><FONT color="#000080">return</FONT></B>(rv);
      }
    }
  }
  <B><FONT color="#000080">return</FONT></B>(-<FONT color="#800000">1</FONT>);
}


<B><FONT color="#000080">long</FONT></B> FindNthLabeledAD(<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> labelA, <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> labelB, <B><FONT color="#000080">int</FONT></B> nn)
{
  <B><FONT color="#000080">long</FONT></B> ls = aux.size();
  <B><FONT color="#000080">int</FONT></B> ii;
  <B><FONT color="#000080">int</FONT></B> cnt = <FONT color="#800000">0</FONT>;
  <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> kk;

  <B><FONT color="#000080">for</FONT></B> (ii = (ls -<FONT color="#800000">1</FONT>);ii &gt; <FONT color="#800000">0</FONT>;ii--)
  {
    kk = aux[ii];
    <B><FONT color="#000080">if</FONT></B>((kk == labelA) || (kk == labelB))
    {
      cnt++;
      <B><FONT color="#000080">if</FONT></B>(cnt == nn)
      {
         <B><FONT color="#000080">return</FONT></B>(aux[(ii - <FONT color="#800000">1</FONT>)]);
      }
    }
  }
  <B><FONT color="#000080">return</FONT></B>(-<FONT color="#800000">1</FONT>);
}

<B><FONT color="#000080">long</FONT></B> ExtractNthLabeledAD(<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> labelA, <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> labelB, <B><FONT color="#000080">int</FONT></B> nn)
{
  <B><FONT color="#000080">long</FONT></B> ls = aux.size();
  <B><FONT color="#000080">int</FONT></B> ii;
  <B><FONT color="#000080">int</FONT></B> cnt = <FONT color="#800000">0</FONT>;
  <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> kk;

  <B><FONT color="#000080">for</FONT></B> (ii = (ls -<FONT color="#800000">1</FONT>);ii &gt; <FONT color="#800000">0</FONT>;ii--)
  {
    kk = aux[ii];
    <B><FONT color="#000080">if</FONT></B>((kk == labelA) || (kk == labelB))
    {
      cnt++;
      <B><FONT color="#000080">if</FONT></B>(cnt == nn)
      {
         <B><FONT color="#000080">long</FONT></B> rv = aux[(ii - <FONT color="#800000">1</FONT>)];
         aux.erase(&aux[ii]);
         aux.erase(&aux[ii - <FONT color="#800000">1</FONT>]);
         <B><FONT color="#000080">return</FONT></B>(rv);
      }
    }
  }
  <B><FONT color="#000080">return</FONT></B>(-<FONT color="#800000">1</FONT>);
}

<B><FONT color="#000080">long</FONT></B> FindFirstLabeledAD(<B><FONT color="#000080">char</FONT></B> * nam)
{
  Word* ww = dictonary-&gt;Address(nam);
  <B><FONT color="#000080">if</FONT></B>(ww == NULL)
  {
    Err.ShowError(Errors::NO_SUCH_WORD, *<B><FONT color="#000080">this</FONT></B>, NameRunning());
    <B><FONT color="#000080">return</FONT></B>(-<FONT color="#800000">1</FONT>);
  }
  <B><FONT color="#000080">return</FONT></B>(FindFirstLabeledAD((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>) ww));
}

<B><FONT color="#000080">long</FONT></B> FindNthLabeledAD(<B><FONT color="#000080">char</FONT></B> * nam, <B><FONT color="#000080">int</FONT></B> nn)
{
  Word* ww = dictonary-&gt;Address(nam);
  <B><FONT color="#000080">if</FONT></B>(ww == NULL)
  {
    Err.ShowError(Errors::NO_SUCH_WORD, *<B><FONT color="#000080">this</FONT></B>, NameRunning());
    <B><FONT color="#000080">return</FONT></B>(-<FONT color="#800000">1</FONT>);
  }
  <B><FONT color="#000080">return</FONT></B>(FindNthLabeledAD((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>) ww, nn));
}

<B><FONT color="#000080">long</FONT></B> FindNthLabeledAD(<B><FONT color="#000080">char</FONT></B> * namA, <B><FONT color="#000080">char</FONT></B> * namB, <B><FONT color="#000080">int</FONT></B> nn)
{
  Word* wwa = dictonary-&gt;Address(namA);
  Word* wwb = dictonary-&gt;Address(namB);
  <B><FONT color="#000080">if</FONT></B>(wwa == NULL || wwb == NULL)
  {
    Err.ShowError(Errors::NO_SUCH_WORD, *<B><FONT color="#000080">this</FONT></B>, NameRunning());
    <B><FONT color="#000080">return</FONT></B>(-<FONT color="#800000">1</FONT>);
  }
  <B><FONT color="#000080">return</FONT></B>(FindNthLabeledAD((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>) wwa, (<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>) wwb, nn));
}

<B><FONT color="#000080">long</FONT></B> ExtractNthLabeledAD(<B><FONT color="#000080">char</FONT></B> * nam, <B><FONT color="#000080">int</FONT></B> nn)
{
  Word* ww = dictonary-&gt;Address(nam);
  <B><FONT color="#000080">if</FONT></B>(ww == NULL)
  {
    Err.ShowError(Errors::NO_SUCH_WORD, *<B><FONT color="#000080">this</FONT></B>, NameRunning());
    <B><FONT color="#000080">return</FONT></B>(-<FONT color="#800000">1</FONT>);
  }
  <B><FONT color="#000080">return</FONT></B>(ExtractNthLabeledAD((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>) ww, nn));
}

<B><FONT color="#000080">long</FONT></B> ExtractNthLabeledAD(<B><FONT color="#000080">char</FONT></B> * namA, <B><FONT color="#000080">char</FONT></B> * namB, <B><FONT color="#000080">int</FONT></B> nn)
{
  Word* wwa = dictonary-&gt;Address(namA);
  Word* wwb = dictonary-&gt;Address(namB);
  <B><FONT color="#000080">if</FONT></B>(wwa == NULL || wwb == NULL)
  {
    Err.ShowError(Errors::NO_SUCH_WORD, *<B><FONT color="#000080">this</FONT></B>, NameRunning());
    <B><FONT color="#000080">return</FONT></B>(-<FONT color="#800000">1</FONT>);
  }
  <B><FONT color="#000080">return</FONT></B>(ExtractNthLabeledAD((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>) wwa, (<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>) wwb, nn));
}

<I><FONT color="#008080">// Function name    : SizeD</FONT></I>
<I><FONT color="#008080">// Description      : the depth of the data stack</FONT></I>
<I><FONT color="#008080">// RSData type      : long </FONT></I>
 <B><FONT color="#000080">long</FONT></B> SizeD()
 {
  <B><FONT color="#000080">return</FONT></B>(dats.size());
 }

 <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> *Base(<B><FONT color="#000080">void</FONT></B>)
 {
   <B><FONT color="#000080">return</FONT></B>(&numericbase);
 }

<I><FONT color="#008080">// functions for &lt;# hold # #s #&gt; </FONT></I>

  <B><FONT color="#000080">char</FONT></B> *Nbuffer()
  {
    <B><FONT color="#000080">return</FONT></B>(nbuffer);
  }

  <B><FONT color="#000080">char</FONT></B> *NObuffer()
  {
    <B><FONT color="#000080">return</FONT></B>(nobuffer);
  }

  <B><FONT color="#000080">int</FONT></B>* NbufferPos()
  {
    <B><FONT color="#000080">return</FONT></B>(&nbufpos);
  }

  <B><FONT color="#000080">bool</FONT></B> NbufInUse()
  {
     <B><FONT color="#000080">return</FONT></B>(nbufflg);
  }

  <B><FONT color="#000080">void</FONT></B> NbufferOn()
  {
    nbufflg = true;
  }

  <B><FONT color="#000080">void</FONT></B> NbufferOff()
  {
    nbufflg = false;
  }

  <B><FONT color="#000080">char</FONT></B> * WordBuf(<B><FONT color="#000080">void</FONT></B>)
  {
      nwordbuf += <FONT color="#800000">304</FONT>;
      <B><FONT color="#000080">if</FONT></B>(nwordbuf &lt; (wordbuf + <FONT color="#800000">1215</FONT>))
      {
        nwordbuf = wordbuf;
      }
     <B><FONT color="#000080">return</FONT></B>(nwordbuf);
  }

  <B><FONT color="#000080">void</FONT></B> StartRunImmediate()
  {
    immediate = true;
  }

  <B><FONT color="#000080">void</FONT></B> StopRunImmediate()
  {
    immediate = false;
  }

  <B><FONT color="#000080">int</FONT></B> Immediate()
  {
    <B><FONT color="#000080">return</FONT></B>(immediate);
  }

  <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> * pIN()
  {
    <B><FONT color="#000080">return</FONT></B>(&INloc);
  }

<I><FONT color="#008080">// set the compileing flag</FONT></I>
 <B><FONT color="#000080">void</FONT></B> Compile()
 {
   compiling = true;
 }

 <B><FONT color="#000080">int</FONT></B>* State(<B><FONT color="#000080">void</FONT></B>)
 {
   <B><FONT color="#000080">return</FONT></B>(&compiling);
 }

 <B><FONT color="#000080">int</FONT></B> Compiling()
 {
   <B><FONT color="#000080">return</FONT></B>(compiling);
 }

 <B><FONT color="#000080">int</FONT></B> CompilingNI()
 {
   <B><FONT color="#000080">if</FONT></B>(immediate)
   {
     <B><FONT color="#000080">return</FONT></B>(false);
   }
   <B><FONT color="#000080">return</FONT></B>(compiling);
 }

 <B><FONT color="#000080">void</FONT></B> SetCompiling(<B><FONT color="#000080">bool</FONT></B> nn)
 {
   compiling = nn;
 }

 <B><FONT color="#000080">void</FONT></B> EndCompile()
 {
   compiling = false;
 }

<I><FONT color="#008080">// return a pointer to the dictonary</FONT></I>
 Dictonary * IDict()
 {
   <B><FONT color="#000080">return</FONT></B>(dictonary);
 }

<I><FONT color="#008080">// return a pointer to the text parser</FONT></I>
 Parser * IParser()
 {
   <B><FONT color="#000080">return</FONT></B>(pparser);
 }

 ClassDescriptions * ClassDSCR()
 {
   <B><FONT color="#000080">return</FONT></B>(cdescript);
 }

<B><FONT color="#000080">int</FONT></B> Parse(<B><FONT color="#000080">char</FONT></B> * txt, <B><FONT color="#000080">bool</FONT></B> once = false);
<B><FONT color="#000080">void</FONT></B> ParseContainedClass(Parser * par, ClassDescription * nc);
<B><FONT color="#000080">bool</FONT></B> ParseClass(string &awrd, Parser * par);
<B><FONT color="#000080">bool</FONT></B> ParseDigits(<B><FONT color="#000080">char</FONT></B> *wrd, Parser * par);

<I><FONT color="#008080">// return a reference to the memory manager</FONT></I>
 MemoryMung & MManager()
 {
   <B><FONT color="#000080">return</FONT></B>(mmanager);
 }

 NamedSTLMap & NamedMaps()
 {
   <B><FONT color="#000080">return</FONT></B>(namedmaps);
 }

 NamedSTLVect & NamedVects()
 {
   <B><FONT color="#000080">return</FONT></B>(namedvects);
 }

<I><FONT color="#008080">// set the primitives pointer</FONT></I>
 <B><FONT color="#000080">void</FONT></B> SetUpPrimitives(Primitives *ap)
 {
   allprim  = ap;
 }

 <I><FONT color="#008080">// return a primitives to the primitives object</FONT></I>
 Primitives * ToPrimitives()
 {
   <B><FONT color="#000080">return</FONT></B>(allprim);
 }
 
<I><FONT color="#008080">// return the output buffer</FONT></I>
 string & Out(<B><FONT color="#000080">void</FONT></B>)
 {
   <B><FONT color="#000080">return</FONT></B>(Output);
 }

<I><FONT color="#008080">// open the output stream</FONT></I>
<B><FONT color="#000080">void</FONT></B> OpenOutput(<B><FONT color="#000080">void</FONT></B>)
 {
   <B><FONT color="#000080">if</FONT></B>(outstream.is_open())
   {
      outstream.close();
   }
   outstream.open(OutFile.c_str());
 }

 <B><FONT color="#000080">void</FONT></B> UseStdOut(<B><FONT color="#000080">void</FONT></B>);
 <B><FONT color="#000080">void</FONT></B> NoStdOut(<B><FONT color="#000080">void</FONT></B>);
 
 <B><FONT color="#000080">bool</FONT></B> IsStdOut(<B><FONT color="#000080">void</FONT></B>)
 {
    <B><FONT color="#000080">return</FONT></B>(usestdout);
 }

 <B><FONT color="#000080">void</FONT></B> UseStringOut(<B><FONT color="#000080">void</FONT></B>);
 <B><FONT color="#000080">void</FONT></B> NoStringOut(<B><FONT color="#000080">void</FONT></B>);
 
 <B><FONT color="#000080">bool</FONT></B> IsStringOut(<B><FONT color="#000080">void</FONT></B>)
 {
    <B><FONT color="#000080">return</FONT></B>(usestringout);
 }

<I><FONT color="#008080">// a new output stream file is opened</FONT></I>
<B><FONT color="#000080">void</FONT></B> NewOutputFile(<B><FONT color="#000080">const</FONT></B> <B><FONT color="#000080">char</FONT></B> * opath)
{
  OutFile = opath;
  OpenOutput();
}

<B><FONT color="#000080">void</FONT></B> NewOutputString(<B><FONT color="#000080">void</FONT></B>)
{
  osstring.seekp(<FONT color="#800000">0</FONT>, ios_base::beg);
}

ostrstream & GetOutputString()
{
   <B><FONT color="#000080">return</FONT></B>(osstring);
}

<I><FONT color="#008080">// write the last output string to the stream</FONT></I>
<B><FONT color="#000080">void</FONT></B> WriteOut(<B><FONT color="#000080">void</FONT></B>)
{
    <B><FONT color="#000080">if</FONT></B>(usestdout)
    {
        cout &lt;&lt; ((<B><FONT color="#000080">char</FONT></B> *) Output.c_str());
    }
    <B><FONT color="#000080">if</FONT></B>(usestringout)
    {
        osstring &lt;&lt; Output.c_str();
    }
    <B><FONT color="#000080">else</FONT></B>
    {
        outstream &lt;&lt; Output.c_str();
    }
    Output.erase(Output.begin(), Output.end());
    Output.reserve(<FONT color="#800000">1000</FONT>);
}

<B><FONT color="#000080">#ifdef</FONT></B> USING_WINDOWS
<B><FONT color="#000080">void</FONT></B> WindowsError()
{
    WriteOut();
    LineOut();
    LPVOID lpMsgBuf;
    FormatMessage( 
        FORMAT_MESSAGE_ALLOCATE_BUFFER | 
        FORMAT_MESSAGE_FROM_SYSTEM | 
        FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        GetLastError(),
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), <I><FONT color="#008080">// Default language</FONT></I>
        (LPTSTR) &lpMsgBuf,
        <FONT color="#800000">0</FONT>,
        NULL 
        );
    
    <B><FONT color="#000080">if</FONT></B>(Output.capacity() &lt; (strlen((<B><FONT color="#000080">char</FONT></B> *)lpMsgBuf) + <FONT color="#800000">100</FONT>))
    {
       Output.reserve((Output.size() + strlen((<B><FONT color="#000080">char</FONT></B> *)lpMsgBuf) + <FONT color="#800000">100</FONT>)); 
    }

    Output = (<B><FONT color="#000080">char</FONT></B> *)lpMsgBuf;

    <I><FONT color="#008080">// Free the buffer.</FONT></I>
    <B><FONT color="#000080">LocalFree</FONT></B>( lpMsgBuf );
    WriteOut();
    LineOut();
}
<B><FONT color="#000080">#endif</FONT></B>

<I><FONT color="#008080">// add cr</FONT></I>
<B><FONT color="#000080">void</FONT></B> LineOut()
{
    <B><FONT color="#000080">if</FONT></B>(usestdout)
    {
        cout &lt;&lt; endl;
    }
    <B><FONT color="#000080">if</FONT></B>(usestringout)
    {
        osstring &lt;&lt; endl;
    }
    <B><FONT color="#000080">else</FONT></B>
    {
        outstream &lt;&lt; endl;
    }
}


<I><FONT color="#008080">// open a trace stream</FONT></I>
<B><FONT color="#000080">void</FONT></B> OpenTrace(<B><FONT color="#000080">void</FONT></B>)
{
    <B><FONT color="#000080">if</FONT></B>(tracestream.is_open())
    {
        tracestream.close();
    }
    tracestream.open(TraceFile.c_str());
}

<I><FONT color="#008080">// close the tracing stream</FONT></I>
<B><FONT color="#000080">void</FONT></B> CloseTrace(<B><FONT color="#000080">void</FONT></B>)
{
    tracestream.close();
}

<I><FONT color="#008080">// a new traceing file</FONT></I>
<B><FONT color="#000080">void</FONT></B> NewTraceFile(<B><FONT color="#000080">char</FONT></B> * ts)
{
    TraceFile = ts;
    OpenTrace();
}

<I><FONT color="#008080">// output a trace string</FONT></I>
<B><FONT color="#000080">void</FONT></B> TraceOut(string& Traceput)
{
    tracestream &lt;&lt; Traceput.c_str();
    <B><FONT color="#000080">if</FONT></B>(retdepth &gt; <FONT color="#800000">0</FONT>)
    {
        tracestream &lt;&lt; <FONT color="#800000">" rdepth = "</FONT> &lt;&lt; retdepth &lt;&lt; <FONT color="#800000">", sdepth = "</FONT> &lt;&lt; SizeD();
    }
    <B><FONT color="#000080">if</FONT></B>(dats.size() &gt; <FONT color="#800000">0</FONT>)
    {
        <B><FONT color="#000080">if</FONT></B>(aux.size() &gt; <FONT color="#800000">0</FONT>)
        {
          TraceAuxDatv();
        }
        TraceDatv();
       <I><FONT color="#008080">//      tracestream &lt;&lt; " TOS =" &lt;&lt; dats.back() &lt;&lt; endl;</FONT></I>
    }
    <B><FONT color="#000080">else</FONT></B>
    {
        tracestream &lt;&lt; endl;
    }
}

<I><FONT color="#008080">// output trace char text</FONT></I>
<B><FONT color="#000080">void</FONT></B> TraceOut(<B><FONT color="#000080">char</FONT></B> * ts)
{
    tracestream &lt;&lt; ts;
    <B><FONT color="#000080">if</FONT></B>(retdepth &gt; <FONT color="#800000">0</FONT>)
    {
        tracestream &lt;&lt; <FONT color="#800000">" rdepth = "</FONT> &lt;&lt; retdepth &lt;&lt; <FONT color="#800000">", sdepth = "</FONT> &lt;&lt; SizeD();
    }
    <B><FONT color="#000080">if</FONT></B>(dats.size() &gt; <FONT color="#800000">0</FONT>)
    {
        TraceDatv();
        <I><FONT color="#008080">//      tracestream &lt;&lt; " TOS =" &lt;&lt; dats.back() &lt;&lt; endl;</FONT></I>
    }
    <B><FONT color="#000080">else</FONT></B>
    {
        tracestream &lt;&lt; endl;
    }    
}

<B><FONT color="#000080">void</FONT></B> DebugTrace(<B><FONT color="#000080">char</FONT></B> * cc)
{
  <B><FONT color="#000080">if</FONT></B>(Tracing())
  {
    tracestream &lt;&lt; <FONT color="#800000">" &lt;&lt; debug: "</FONT>;
    TraceOut(cc);
  }
}

<B><FONT color="#000080">void</FONT></B> TraceOn()
{
  tracing = true;
}

<B><FONT color="#000080">void</FONT></B> TraceOff()
{
  tracing = false;
}

<B><FONT color="#000080">bool</FONT></B> Tracing()
{
 <B><FONT color="#000080">return</FONT></B>(tracing);
}

<B><FONT color="#000080">void</FONT></B> DecompileCurrent(<B><FONT color="#000080">void</FONT></B>);
<B><FONT color="#000080">void</FONT></B> DecompileOne(<B><FONT color="#000080">void</FONT></B>);
<B><FONT color="#000080">void</FONT></B> DecompileN(<B><FONT color="#000080">int</FONT></B> n);

<I><FONT color="#008080">// show error ii with extra debug info</FONT></I>
 <B><FONT color="#000080">void</FONT></B> ShowError(<B><FONT color="#000080">int</FONT></B> ii, string& extra)
 {
   Err.ShowError(ii, *<B><FONT color="#000080">this</FONT></B>, extra); 
 }

<I><FONT color="#008080">// show error ii with extra debug info</FONT></I>
<B><FONT color="#000080">void</FONT></B> ShowError(<B><FONT color="#000080">int</FONT></B> ii)
 {
<I><FONT color="#008080">//   string tmp = NameRunning();</FONT></I>
   string tmp = <FONT color="#800000">" &lt;&lt;&lt; "</FONT>;
   Err.ShowError(ii, *<B><FONT color="#000080">this</FONT></B>, tmp); 
 }

 <B><FONT color="#000080">void</FONT></B> ShowError(<B><FONT color="#000080">int</FONT></B> ii, string& extra, <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> nn)
 {
   <B><FONT color="#000080">char</FONT></B> errtxt[<FONT color="#800000">300</FONT>];
   sprintf(errtxt,<FONT color="#800000">" %s = %li"</FONT> , extra.c_str(), nn);
   extra = errtxt;
   Err.ShowError(ii, *<B><FONT color="#000080">this</FONT></B>, extra); 
 }

 <B><FONT color="#000080">void</FONT></B> ShowError(<B><FONT color="#000080">int</FONT></B> ii, string& extra, <B><FONT color="#000080">void</FONT></B> * vv)
 {
   <B><FONT color="#000080">char</FONT></B> errtxt[<FONT color="#800000">300</FONT>];
   sprintf(errtxt,<FONT color="#800000">" %s = %lx"</FONT> , extra.c_str(), vv);
   extra = errtxt;
   Err.ShowError(ii, *<B><FONT color="#000080">this</FONT></B>, extra); 
 }

<I><FONT color="#008080">// Function name    : TempString</FONT></I>
<I><FONT color="#008080">// Description      : Non-compiled strings need to go somewhere</FONT></I>
<I><FONT color="#008080">// RSData type      : string& </FONT></I>
 string& TempString()
 {    
    <B><FONT color="#000080">return</FONT></B>(tempintrp);
    
 }

<I><FONT color="#008080">// Function name    : TempString</FONT></I>
<I><FONT color="#008080">// Description      : empty the temporary string</FONT></I>
<I><FONT color="#008080">// RSData type      : string& </FONT></I>
 <B><FONT color="#000080">void</FONT></B> EmptyTempString()
 {    
   tempintrp.erase(tempintrp.begin(),tempintrp.end());
   tempintrp.reserve(<FONT color="#800000">300</FONT>);
 }

 <B><FONT color="#000080">void</FONT></B> DebugString(<B><FONT color="#000080">const</FONT></B> <B><FONT color="#000080">char</FONT></B> * ds)
 {
   DebugStr.erase(DebugStr.begin(),DebugStr.end());
   DebugStr.reserve(<FONT color="#800000">300</FONT>);  
   DebugStr = ds;
 }

<I><FONT color="#008080">// a fatal error</FONT></I>
  <B><FONT color="#000080">bool</FONT></B> Fatal()
  {
    <B><FONT color="#000080">return</FONT></B>(Err.Fatal());
  }

  <B><FONT color="#000080">void</FONT></B> FatalError(<B><FONT color="#000080">void</FONT></B>)
  {
    Err.FatalError();
  }

  <B><FONT color="#000080">void</FONT></B> ResetFatal(<B><FONT color="#000080">void</FONT></B>)
  {
    Err.ResetFatal();
  }

<I><FONT color="#008080">// return the address of the word being compiled</FONT></I>
 Word * Building()
 {
   <B><FONT color="#000080">return</FONT></B>(building);
 }

<I><FONT color="#008080">// set the word being compiled</FONT></I>
 <B><FONT color="#000080">void</FONT></B> SetBuilding(Word * bb)
 {
   building = bb;
 }

<I><FONT color="#008080">// compile helpers </FONT></I>
 <B><FONT color="#000080">void</FONT></B> BuildWithName(string & name);
 <B><FONT color="#000080">void</FONT></B> BuildAddElement(Element& el);
 <B><FONT color="#000080">void</FONT></B> BuildAddElement(Word* pww);
 <B><FONT color="#000080">void</FONT></B> BuildAddElement(string* pss);
 <B><FONT color="#000080">void</FONT></B> BuildAddElement(<B><FONT color="#000080">long</FONT></B>* pqq);
 <B><FONT color="#000080">void</FONT></B> BuildAddElement(<B><FONT color="#000080">long</FONT></B> qq);
 <B><FONT color="#000080">void</FONT></B> BuildAddElement(ClassMethod* pm);
 <B><FONT color="#000080">void</FONT></B> BuildAddElement(ClassData* pd);

 <B><FONT color="#000080">void</FONT></B> BuildFinishWord(<B><FONT color="#000080">void</FONT></B>);
 
 <B><FONT color="#000080">int</FONT></B> BuildLastUsedElement(<B><FONT color="#000080">void</FONT></B>);
 <B><FONT color="#000080">int</FONT></B> BuildLastElementCalling(Word *pwrd);
 
};

<B><FONT color="#000080">class</FONT></B> Primitives
{
  <B><FONT color="#000080">friend</FONT></B> Language;
  <B><FONT color="#000080">friend</FONT></B> Element;
  <B><FONT color="#000080">friend</FONT></B> Word;
  InterpreterData * indat;
  
<B><FONT color="#000080">public</FONT></B>:

 Primitives(InterpreterData * idat)
 {
   indat = idat;
 }

 Primitives()
 {
   
 } 

 __int64 Pop64(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> Push64(<B><FONT color="#000080">unsigned</FONT></B> __int64 vv, InterpreterData & idat);

 <B><FONT color="#000080">void</FONT></B> L_plus(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_minus(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_colon(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_semicolon(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_quote(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_dotquote(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_Comment(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_CppComment(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_ForthComment(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_dot(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_udot(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_emit(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_CR(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_printstring(InterpreterData & idat);

 <B><FONT color="#000080">void</FONT></B> L_equal(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_greaterthan(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_dup(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_questiondup(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_swap(InterpreterData & idat);

 <I><FONT color="#008080">// control words</FONT></I>
 <B><FONT color="#000080">void</FONT></B> L_do(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_rundo(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_runloop(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_loop(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_runiinloop(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_iinloop(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_runjinloop(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_jinloop(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_runplusloop(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_plusloop(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_runquestiondo(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_questiondo(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_runbegin(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_begin(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_rununtil(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_until(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_runleave(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_leave(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_rununloop(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_unloop(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_runif(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_if(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_runelse(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_else(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_runthen(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_then(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_runwhile(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_while(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_runrepeat(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_repeat(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_runagain(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_again(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_runcase(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_case(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_runof(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_of(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_runendof(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_endof(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_runendcase(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_endcase(InterpreterData & idat);

<I><FONT color="#008080">// end control words</FONT></I>
 <B><FONT color="#000080">void</FONT></B> L_depth(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_drop(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_over(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_slashmod(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_mod(InterpreterData & idat);

<I><FONT color="#008080">// void L_roll(InterpreterData & idat);</FONT></I>
 <B><FONT color="#000080">void</FONT></B> L_rot(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_multiply(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_starslash(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_starslashmod(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_divide(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_constant(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_variable(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_store(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_fetch(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_oneplus(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_oneminus(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_twotimes(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_twoplus(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_twominus(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_twoslash(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_abs(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_plusstore(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_and(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_not(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_or(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_xor(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_rshift(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_lshift(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_max(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_min(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_zeroless(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_zeronot(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_zeroequal(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_zerogreater(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_lessthan(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_ulessthan(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_notequal(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_greaterthanequal(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_lessthanequal(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_negate(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_stringcopy(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_stringplus(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_stringequal(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_substring(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_stringvariable(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_stringtocstr(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_cstrtostring(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_chararray(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_chararraylen(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_deletechararray(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_cstore(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_cfetch(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_wstore(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_wfetch(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_count(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_type(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_traceon(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_traceoff(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_addtrace(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_stackdepth(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_strcpy(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_strncpy(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_memcpy(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_memset(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_hex(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_octal(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_decimal(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_base(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_sTod(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_mtimes(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_smslashrem(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_fmslashmod(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_umtimes(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_umslashmod(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_dplus(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_greaternumber(InterpreterData & idat);

 <B><FONT color="#000080">void</FONT></B> L_dnegate(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_dzeroless(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_dminus(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_dzeroequal(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_dtwostar(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_dtwoslash(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_dmax(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_dmin(InterpreterData & idat);

 <B><FONT color="#000080">void</FONT></B> L_structure(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_createinstance(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_Nchar(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_Nshort(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_Nlong(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_Narraylong(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_Narrayshort(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_Narrayobjects(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_endstructure(InterpreterData & idat);

 <B><FONT color="#000080">void</FONT></B> L_ReadEntireFile(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_include(InterpreterData & idat);

 <B><FONT color="#000080">void</FONT></B> L_greaterin(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_decompile(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_execute(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_tic(InterpreterData & idat);

 <B><FONT color="#000080">void</FONT></B> L_dot_s(InterpreterData & idat);

 <B><FONT color="#000080">void</FONT></B> L_immediate(InterpreterData & idat);
<I><FONT color="#008080">// L_tocontext hidden</FONT></I>
 <B><FONT color="#000080">void</FONT></B> L_tocontext(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_forth(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_vocabulary(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_definitions(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_literal(InterpreterData & idat);
<I><FONT color="#008080">// may remove this one</FONT></I>
 <B><FONT color="#000080">void</FONT></B> L_vocquery(InterpreterData & idat);

 <B><FONT color="#000080">void</FONT></B> L_bl(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_word(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_create(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_endcreate(InterpreterData & idat);

 <B><FONT color="#000080">void</FONT></B> L_allot(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_rundoes(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_does(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_execute_at(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_runexit(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_exit(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_recurse(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_leftbracket(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_rightbracket(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_quit(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_release(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_rpush(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_rpop(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_rfetch(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_nip(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_pick(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_reverserot(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_twoswap(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_twoover(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_twodup(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_twodrop(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_twostore(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_twofetch(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_cell(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_cellplus(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_charplus(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_cells(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_chars(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_true(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_false(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_memsize(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_auxpush(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_auxpop(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_auxswap(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_auxdrop(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_auxover(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_auxrot(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_auxreverserot(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_auxtuck(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_auxnip(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_auxroll(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_auxpick(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_auxtwodup(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_auxtwodrop(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_auxfetch(InterpreterData & idat);


 <B><FONT color="#000080">void</FONT></B> L_timeanddate(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_tuck(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_roll(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_within(InterpreterData & idat);
 

 <B><FONT color="#000080">void</FONT></B> L_ftimes(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_fplus(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_fminus(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_fdivide(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_dtof(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_ftod(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_fzeroless(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_fzeroequal(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_fless(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_flessequal(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_fgreater(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_fgreaterequal(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_fdrop(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_fdup(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_fnip(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_froll(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_fpick(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_fover(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_frot(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_freverserot(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_ftuck(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_fpower(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_fabs(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_facos(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_fcos(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_fcosh(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_fasin(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_fsin(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_fsincos(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_fsinh(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_fatan(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_ftan(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_ftanh(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_fatan2(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_fexp(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_fln(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_flog(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_sqrt(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_fdot(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_fmin(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_fmax(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_fnegate(InterpreterData & idat);
<I><FONT color="#008080">// end floating point</FONT></I>

 <B><FONT color="#000080">void</FONT></B> L_evaluate(InterpreterData & idat);

<I><FONT color="#008080">// STL methods</FONT></I>
 <B><FONT color="#000080">void</FONT></B> L_STLVect(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_STLVectIterator(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_STLMap(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_STLMapIterator(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_STLInsert(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_STLFind(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_STLBegin(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_STLEnd(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_STLItFrom(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_STLItInc(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_STLItEquals(InterpreterData & idat);
<I><FONT color="#008080">// STL done</FONT></I>

 <I><FONT color="#008080">// class defining words</FONT></I>
 <B><FONT color="#000080">void</FONT></B> L_MethodSemicolon(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_MethodColon(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_This(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_DashRightGreater(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_DashDot(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_MakeClass(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_class(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_EnclosedByte(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_EnclosedBytes(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_EnclosedWord(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_EnclosedWords(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_EnclosedDWord(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_EnclosedDWords(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_EnclosedPointer(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_EnclosedPointers(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_EnclosedArrays(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_EnclosedClass(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_EnclosedClasses(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_endclass(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_privatecolon(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_publiccolon(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_protectedcolon(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_DecompileClass(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_MakeClassCompileTest(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_ColonEqual(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_ExecuteConstructor(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_NewClass(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_DeleteClass(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_squote(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_cquote(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_invert(InterpreterData & idat);   <I><FONT color="#008080">// put near xor</FONT></I>
 <B><FONT color="#000080">void</FONT></B> L_source(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_postpone(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_bracketcharbracket(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_bracketticbracket(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_char(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_find(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_state(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_poundgreater(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_lesspound(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_pounds(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_pound(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_hold(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_sign(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_space(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_spaces(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_fill(InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> L_move(InterpreterData & idat);

 <I><FONT color="#008080">// will work with other 'types'</FONT></I>
 <B><FONT color="#000080">void</FONT></B> L_delete(InterpreterData & idat);

<I><FONT color="#008080">// class defining done</FONT></I>

 <B><FONT color="#000080">void</FONT></B> L_bye(InterpreterData & idat);

 <B><FONT color="#000080">void</FONT></B> L_nop(InterpreterData & idat);
};

<I><FONT color="#008080">// pointer to Primitives::function passed InterpterData and returning void </FONT></I>

<B><FONT color="#000080">typedef</FONT></B> <B><FONT color="#000080">void</FONT></B> (Primitives::*PVFN)( InterpreterData &);

<I><FONT color="#008080">// typedef void (*PVFN)( InterpreterData & intrp );</FONT></I>

<I><FONT color="#008080">// Primitive parts of words in the language are elements</FONT></I>

<B><FONT color="#000080">class</FONT></B> Element
{
  <B><FONT color="#000080">int</FONT></B> type;
  <B><FONT color="#000080">union</FONT></B>
  {
    Word * call;
    PVFN fun;
    <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> literal;
    string *litstring;
    ClassMethod * method;
    ClassData * data;
  };

<B><FONT color="#000080">public</FONT></B>:

<B><FONT color="#000080">enum</FONT></B> elementtypes
{
  Primitive,
  Definition,
  Literal,
  LitString,
  AddressV,
  MethodDefinition,
  DataDefinition
};

  Element(<B><FONT color="#000080">const</FONT></B> Element & el)
  {
    type = el.type;
    string *ast = NULL;

    <B><FONT color="#000080">switch</FONT></B>(type)
    {
      <B><FONT color="#000080">case</FONT></B> Primitive:
           fun = el.fun;
          <B><FONT color="#000080">break</FONT></B>;
      <B><FONT color="#000080">case</FONT></B> Literal:
           literal = el.literal;
          <B><FONT color="#000080">break</FONT></B>;
      <B><FONT color="#000080">case</FONT></B> Definition:
           call = el.call;
          <B><FONT color="#000080">break</FONT></B>;
      <B><FONT color="#000080">case</FONT></B> LitString:
           ast = <B><FONT color="#000080">new</FONT></B> string();   <I><FONT color="#008080">// the string not just the pointer is copied</FONT></I>
           ast-&gt;reserve(el.litstring-&gt;size());
           *ast = *el.litstring;
           litstring = ast; 
          <B><FONT color="#000080">break</FONT></B>;
      <B><FONT color="#000080">case</FONT></B> AddressV:
           literal = el.literal;
           <B><FONT color="#000080">break</FONT></B>;
      <B><FONT color="#000080">case</FONT></B> MethodDefinition:
           method = el.method;
           <B><FONT color="#000080">break</FONT></B>;
      <B><FONT color="#000080">case</FONT></B> DataDefinition:
           data = el.data;
           <B><FONT color="#000080">break</FONT></B>;
      <B><FONT color="#000080">default</FONT></B>:
          <B><FONT color="#000080">break</FONT></B>;
    }
  }

  Element(string * val)
  {
    type = LitString;
    litstring = val;
  }

  Element(<B><FONT color="#000080">long</FONT></B> val)
  {
    type = Literal; 
    literal = val;
  }

 Element(<B><FONT color="#000080">long</FONT></B> * pval)
  {
    type = AddressV; 
    literal = *pval;
  }

  Element(Word * def)
  {
    type = Definition;
    call = def;
  }

  Element(ClassMethod * mp)
  {
    type = MethodDefinition;
    method = mp;
  }

  Element(ClassData * dp)
  {
    type = DataDefinition;
    data = dp;
  }

  Element(PVFN ff)
  {
    type = Primitive;
    fun = ff;
  }

  ~Element()
  {
    <B><FONT color="#000080">if</FONT></B>(type == LitString)
    {
       <B><FONT color="#000080">if</FONT></B>(litstring != NULL)
       {
         <B><FONT color="#000080">delete</FONT></B> litstring;
<I><FONT color="#008080">//         litstring = NULL;</FONT></I>
       }
    }
  }

  
  <B><FONT color="#000080">void</FONT></B> FetchLiteralAdr(<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> *nv)
  {
    <B><FONT color="#000080">if</FONT></B>(type == Literal || type == AddressV)
    {
      nv = &literal;
    }
    <B><FONT color="#000080">else</FONT></B>
    {
      nv = NULL;
    }
  }

  <B><FONT color="#000080">void</FONT></B> FetchLiteralVal(<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> *nv)
  {
    <B><FONT color="#000080">if</FONT></B>(type == Literal || type == AddressV)
    {
      *nv = literal;
    }
  }

 <B><FONT color="#000080">void</FONT></B> SetLiteralVal(<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> *nv)
  {
    <B><FONT color="#000080">if</FONT></B>(type == Literal || type == AddressV)
    {
      literal = *nv;
    }
  }

  <B><FONT color="#000080">void</FONT></B> FetchLitStringAdr(string* cs)
  {
    <B><FONT color="#000080">if</FONT></B>(type == LitString)
    {
      cs = litstring;
    }
    <B><FONT color="#000080">else</FONT></B>
    {
       cs = NULL;
    }
  }

  <B><FONT color="#000080">void</FONT></B> FetchLitString(string& cs)
  {
    <B><FONT color="#000080">if</FONT></B>(type == LitString)
    {
      cs = *litstring;
    }
  }

 <B><FONT color="#000080">void</FONT></B> FetchDefinitionAdr(Word *ws)
  {
    <B><FONT color="#000080">if</FONT></B>(type == Definition)
    {
      ws = call;
    }
    <B><FONT color="#000080">else</FONT></B>
    {
      ws = NULL;
    }
  }

  <B><FONT color="#000080">void</FONT></B> FetchMethodDefinitionAdr(ClassMethod *mp)
  {
    <B><FONT color="#000080">if</FONT></B>(type == MethodDefinition)
    {
      mp = method;
    }
    <B><FONT color="#000080">else</FONT></B>
    {
      mp = NULL;
    }
  }

  <B><FONT color="#000080">void</FONT></B> FetchDataDefinitionAdr(ClassData *dp)
  {
    <B><FONT color="#000080">if</FONT></B>(type == DataDefinition)
    {
      dp = data;
    }
    <B><FONT color="#000080">else</FONT></B>
    {
      dp = NULL;
    }
  }


 <B><FONT color="#000080">bool</FONT></B> FetchDefinitionName(string & s);

<I><FONT color="#008080">// bool FetchMethodDefinitionName(string & s);</FONT></I>
<I><FONT color="#008080">// bool FetchMethodDefinitionClass();</FONT></I>
<I><FONT color="#008080">// bool FetchDataDefinitionName(string & s);</FONT></I>
<I><FONT color="#008080">// bool FetchDataDefinitionClass()</FONT></I>

 <B><FONT color="#000080">int</FONT></B> Type()
 {
   <B><FONT color="#000080">return</FONT></B>(type);
 }

  <B><FONT color="#000080">const</FONT></B> Element & <B><FONT color="#000080">operator</FONT></B> = (<B><FONT color="#000080">const</FONT></B> Element & el)
  {
    type = el.type;
    string * ast;

    <B><FONT color="#000080">switch</FONT></B>(type)
    {
      <B><FONT color="#000080">case</FONT></B> Primitive:
           fun = el.fun;
          <B><FONT color="#000080">break</FONT></B>;
      <B><FONT color="#000080">case</FONT></B> Literal:
           literal = el.literal;
          <B><FONT color="#000080">break</FONT></B>;
      <B><FONT color="#000080">case</FONT></B> Definition:
           call = el.call;
          <B><FONT color="#000080">break</FONT></B>;
      <B><FONT color="#000080">case</FONT></B> LitString:
           ast = <B><FONT color="#000080">new</FONT></B> string();
           ast-&gt;reserve(el.litstring-&gt;size());
           *ast = *el.litstring;
           litstring = ast; 
          <B><FONT color="#000080">break</FONT></B>;
      <B><FONT color="#000080">case</FONT></B> AddressV:
           literal = el.literal;
           <B><FONT color="#000080">break</FONT></B>;
      <B><FONT color="#000080">case</FONT></B> MethodDefinition:
           method = el.method;
           <B><FONT color="#000080">break</FONT></B>;
      <B><FONT color="#000080">case</FONT></B> DataDefinition:
           data = el.data;
           <B><FONT color="#000080">break</FONT></B>;
      <B><FONT color="#000080">default</FONT></B>:
          <B><FONT color="#000080">break</FONT></B>;
    }
    <B><FONT color="#000080">return</FONT></B>(*<B><FONT color="#000080">this</FONT></B>);
  }

<I><FONT color="#008080">// Function name    : IsWord</FONT></I>
<I><FONT color="#008080">// Description      : does this element call the given word?</FONT></I>
<I><FONT color="#008080">// RSData type      : bool </FONT></I>
<I><FONT color="#008080">// Argument         : Word * ww</FONT></I>
 <B><FONT color="#000080">bool</FONT></B> IsWord(Word * ww)
 {
   <B><FONT color="#000080">if</FONT></B>(type == Definition)
   {
      <B><FONT color="#000080">if</FONT></B>(call == ww)
      {
        <B><FONT color="#000080">return</FONT></B>(true);
      }
   }
   <B><FONT color="#000080">return</FONT></B>(false);
 }

 <B><FONT color="#000080">bool</FONT></B> IsMethod(ClassMethod * pm)
 {
  <B><FONT color="#000080">if</FONT></B>(type == MethodDefinition)
   {
      <B><FONT color="#000080">if</FONT></B>(method == pm)
      {
        <B><FONT color="#000080">return</FONT></B>(true);
      }
   }
   <B><FONT color="#000080">return</FONT></B>(false);    
 }

 <B><FONT color="#000080">bool</FONT></B> IsData(ClassData * pd)
 {
  <B><FONT color="#000080">if</FONT></B>(type == DataDefinition)
   {
      <B><FONT color="#000080">if</FONT></B>(data == pd)
      {
        <B><FONT color="#000080">return</FONT></B>(true);
      }
   }
   <B><FONT color="#000080">return</FONT></B>(false);    
 }

 <B><FONT color="#000080">bool</FONT></B> SameWord(<B><FONT color="#000080">char</FONT></B> *nam, InterpreterData & idat);
 <B><FONT color="#000080">void</FONT></B> Execute(InterpreterData & intrp, <B><FONT color="#000080">int</FONT></B> imed = <FONT color="#800000">0</FONT>);
 <B><FONT color="#000080">friend</FONT></B> Word;
 <B><FONT color="#000080">friend</FONT></B> ClassMethod;
 <B><FONT color="#000080">friend</FONT></B> ClassData;
};


<I><FONT color="#008080">// the class of words in the language</FONT></I>

<B><FONT color="#000080">class</FONT></B> Word
{
  string name;
  <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> flags;
  vector&lt;Element &gt; word;

 <B><FONT color="#000080">public</FONT></B>: 

  <B><FONT color="#000080">enum</FONT></B> exerrors
  {
    Ok,
    None,
    ErrorExec,
  };

 Word()
 {
   flags = 0L;
   word.reserve(<FONT color="#800000">60</FONT>);
 }

 ~Word()
 {

 }

 Word(<B><FONT color="#000080">const</FONT></B> Word & Wrd)
 {
   name = Wrd.name;
   word = Wrd.word;
   flags = Wrd.flags;
 }

 Word & <B><FONT color="#000080">operator</FONT></B> = (<B><FONT color="#000080">const</FONT></B> Word & Wrd)
 {
   name = Wrd.name;
   word = Wrd.word;
   flags = Wrd.flags;
   <B><FONT color="#000080">return</FONT></B>(*<B><FONT color="#000080">this</FONT></B>);
 }

 <B><FONT color="#000080">void</FONT></B> NewName(string & cs)
 {
   name = cs;
 }

 <B><FONT color="#000080">void</FONT></B> AddElement(Element & el)
 {
   <B><FONT color="#000080">if</FONT></B>((word.capacity() - word.size()) &lt; <FONT color="#800000">10</FONT>)
   {
     word.reserve(word.capacity() + <FONT color="#800000">20</FONT>);
   }
   word.push_back(el);
 }

 <B><FONT color="#000080">void</FONT></B> SetFlags(<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> ff)
 {
   flags |= ff;
 }

 <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> FlagsMatch(<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> ff)
 {
   <B><FONT color="#000080">return</FONT></B>((flags & ff));
 }

 string& Name()
 {
   <B><FONT color="#000080">return</FONT></B>(name);
 }

 string *NamePtr()
 {
   <B><FONT color="#000080">return</FONT></B>(&name);
 }

 <B><FONT color="#000080">int</FONT></B> NextUse(Word * Wrd, <B><FONT color="#000080">int</FONT></B> index)
 {
    <B><FONT color="#000080">for</FONT></B>(<B><FONT color="#000080">int</FONT></B> ii = (index + <FONT color="#800000">1</FONT>);ii &lt; word.size();ii++)
    {
       <B><FONT color="#000080">if</FONT></B>(word[ii].IsWord(Wrd))
       {
         <B><FONT color="#000080">return</FONT></B>(ii);
       }
    }
    <B><FONT color="#000080">return</FONT></B>(-<FONT color="#800000">1</FONT>);
 }

 <B><FONT color="#000080">int</FONT></B> LastUse(Word * Wrd, <B><FONT color="#000080">int</FONT></B> index)
 {
    <B><FONT color="#000080">for</FONT></B>(<B><FONT color="#000080">int</FONT></B> ii = index;ii &gt;= <FONT color="#800000">0</FONT>;ii--)
    {
       <B><FONT color="#000080">if</FONT></B>(word[ii].IsWord(Wrd))
       {
         <B><FONT color="#000080">return</FONT></B>(ii);
       }
    }
    <B><FONT color="#000080">return</FONT></B>(-<FONT color="#800000">1</FONT>);
 }

 <B><FONT color="#000080">int</FONT></B> NextUse(ClassMethod * cm, <B><FONT color="#000080">int</FONT></B> index)
 {
    <B><FONT color="#000080">for</FONT></B>(<B><FONT color="#000080">int</FONT></B> ii = (index + <FONT color="#800000">1</FONT>);ii &lt; word.size();ii++)
    {
       <B><FONT color="#000080">if</FONT></B>(word[ii].IsMethod(cm))
       {
         <B><FONT color="#000080">return</FONT></B>(ii);
       }
    }
    <B><FONT color="#000080">return</FONT></B>(-<FONT color="#800000">1</FONT>);
 }

 <B><FONT color="#000080">int</FONT></B> LastUse(ClassMethod * cm, <B><FONT color="#000080">int</FONT></B> index)
 {
    <B><FONT color="#000080">for</FONT></B>(<B><FONT color="#000080">int</FONT></B> ii = index;ii &gt;= <FONT color="#800000">0</FONT>;ii--)
    {
       <B><FONT color="#000080">if</FONT></B>(word[ii].IsMethod(cm))
       {
         <B><FONT color="#000080">return</FONT></B>(ii);
       }
    }
    <B><FONT color="#000080">return</FONT></B>(-<FONT color="#800000">1</FONT>);
 }

<B><FONT color="#000080">int</FONT></B> NextUse(ClassData * dm, <B><FONT color="#000080">int</FONT></B> index)
 {
    <B><FONT color="#000080">for</FONT></B>(<B><FONT color="#000080">int</FONT></B> ii = (index + <FONT color="#800000">1</FONT>);ii &lt; word.size();ii++)
    {
       <B><FONT color="#000080">if</FONT></B>(word[ii].IsData(dm))
       {
         <B><FONT color="#000080">return</FONT></B>(ii);
       }
    }
    <B><FONT color="#000080">return</FONT></B>(-<FONT color="#800000">1</FONT>);
 }

 <B><FONT color="#000080">int</FONT></B> LastUse(ClassData * dm, <B><FONT color="#000080">int</FONT></B> index)
 {
    <B><FONT color="#000080">for</FONT></B>(<B><FONT color="#000080">int</FONT></B> ii = index;ii &gt;= <FONT color="#800000">0</FONT>;ii--)
    {
       <B><FONT color="#000080">if</FONT></B>(word[ii].IsData(dm))
       {
         <B><FONT color="#000080">return</FONT></B>(ii);
       }
    }
    <B><FONT color="#000080">return</FONT></B>(-<FONT color="#800000">1</FONT>);
 }


 <B><FONT color="#000080">int</FONT></B> NextIndex()
 {
   <B><FONT color="#000080">return</FONT></B>(word.size());
 }

 <B><FONT color="#000080">void</FONT></B> LiteralAddress(<B><FONT color="#000080">int</FONT></B> index, <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>* ll)
 {
   <B><FONT color="#000080">if</FONT></B> (index &gt;= <FONT color="#800000">0</FONT> && index &lt; word.size())
   {
     word[index].FetchLiteralAdr(ll);
   }
   <B><FONT color="#000080">else</FONT></B>
   {
     ll = NULL;
   }
 }

 <B><FONT color="#000080">void</FONT></B> LiteralValue(<B><FONT color="#000080">int</FONT></B> index, <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>* ll)
 {
   <B><FONT color="#000080">if</FONT></B> (index &gt;= <FONT color="#800000">0</FONT> && index &lt; word.size())
   {
     word[index].FetchLiteralVal(ll);
   }
 }

 <B><FONT color="#000080">void</FONT></B> SetLiteralValue(<B><FONT color="#000080">int</FONT></B> index, <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>* ll)
 {
   <B><FONT color="#000080">if</FONT></B> (index &gt;= <FONT color="#800000">0</FONT> && index &lt; word.size())
   {
     word[index].SetLiteralVal(ll);
   }
 }

 <B><FONT color="#000080">void</FONT></B> StringAddress(<B><FONT color="#000080">int</FONT></B> index, string * cs)
 {
   <B><FONT color="#000080">if</FONT></B> (index &gt;= <FONT color="#800000">0</FONT> && index &lt; word.size())
   {
     word[index].FetchLitStringAdr(cs);
   }
   <B><FONT color="#000080">else</FONT></B>
   {
     cs = NULL; 
   }
 }

 <B><FONT color="#000080">void</FONT></B> StringAsCopy(<B><FONT color="#000080">int</FONT></B> index, string& cs)
 {
   <B><FONT color="#000080">if</FONT></B> (index &gt;= <FONT color="#800000">0</FONT> && index &lt; word.size())
   {
     word[index].FetchLitString(cs);
   }
 }

  <B><FONT color="#000080">void</FONT></B> DefinitionAddress(<B><FONT color="#000080">int</FONT></B> index, Word * ww)
  {
    <B><FONT color="#000080">if</FONT></B> (index &gt;= <FONT color="#800000">0</FONT> && index &lt; word.size())
    {
       word[index].FetchDefinitionAdr(ww);
    }
    <B><FONT color="#000080">else</FONT></B>
    {
       ww = NULL; 
    }
  }

  <B><FONT color="#000080">void</FONT></B> DefinitionAddress(<B><FONT color="#000080">int</FONT></B> index, ClassMethod * cm)
  {
    <B><FONT color="#000080">if</FONT></B> (index &gt;= <FONT color="#800000">0</FONT> && index &lt; word.size())
    {
       word[index].FetchMethodDefinitionAdr(cm);
    }
    <B><FONT color="#000080">else</FONT></B>
    {
       cm = NULL; 
    }
  }

 <B><FONT color="#000080">void</FONT></B> DefinitionAddress(<B><FONT color="#000080">int</FONT></B> index, ClassData * dm)
  {
    <B><FONT color="#000080">if</FONT></B> (index &gt;= <FONT color="#800000">0</FONT> && index &lt; word.size())
    {
       word[index].FetchDataDefinitionAdr(dm);
    }
    <B><FONT color="#000080">else</FONT></B>
    {
       dm = NULL; 
    }
  }


 <B><FONT color="#000080">int</FONT></B> Execute(<B><FONT color="#000080">int</FONT></B> index, InterpreterData & intrp, <B><FONT color="#000080">int</FONT></B> imed = <FONT color="#800000">0</FONT>);

 <B><FONT color="#000080">bool</FONT></B> SameWord(<B><FONT color="#000080">int</FONT></B> index, <B><FONT color="#000080">char</FONT></B> *nam, InterpreterData & idat)
 {
    <B><FONT color="#000080">return</FONT></B>(word[index].SameWord(nam, idat));
 }

<B><FONT color="#000080">void</FONT></B> Decompile(string& dtext, InterpreterData & intrp);

<B><FONT color="#000080">friend</FONT></B> ClassMethod; 

};

<I><FONT color="#008080">// data element description for forth classes;</FONT></I>
<B><FONT color="#000080">class</FONT></B> ClassData 
{
   <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> size;
   <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> flags;
   <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> element_size;
   <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> number_of;
   string name;
   <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> offset;
   ClassDescription * pclassdecription;
   ClassDescription * dclass_desc;

<B><FONT color="#000080">public</FONT></B>:

    <B><FONT color="#000080">enum</FONT></B> data_types
    {
       ExecuteCompile =  <FONT color="#800000">0x01</FONT>,
       Hidden =          <FONT color="#800000">0x02</FONT>,
       Private =         <FONT color="#800000">0x04</FONT>,
       Protected =       <FONT color="#800000">0x08</FONT>,
       Public =         <FONT color="#800000">0x010</FONT>,
       ArrayType =      <FONT color="#800000">0x020</FONT>,
       ClassType =      <FONT color="#800000">0x040</FONT>
    };

   ClassData()
   {
      name.reserve(<FONT color="#800000">120</FONT>);
      offset = 0l;
      size = 0l;
      flags = 0l;
      number_of = <FONT color="#800000">1</FONT>;
      element_size = <FONT color="#800000">0</FONT>;
      pclassdecription = NULL;
      dclass_desc = NULL;
   }

   ClassData(string & nam, <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> siz, ClassDescription *pc,  <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> num = <FONT color="#800000">1</FONT>, ClassDescription *dc = NULL);
 
   ClassData(<B><FONT color="#000080">const</FONT></B> ClassData& cd)
   {
      name.reserve(<FONT color="#800000">120</FONT>);
      name = cd.name;
      offset = cd.offset;
      size = cd.size;
      flags = cd.flags;
      number_of = cd.number_of;
      element_size = cd.element_size;
      pclassdecription = cd.pclassdecription;
      dclass_desc = cd.dclass_desc; 
   }

   ClassData& <B><FONT color="#000080">operator</FONT></B> = (<B><FONT color="#000080">const</FONT></B> ClassData& cd)
   {
      name.reserve(<FONT color="#800000">120</FONT>);
      name = cd.name;
      offset = cd.offset;
      size = cd.size;
      flags = cd.flags;
      number_of = cd.number_of;
      element_size = cd.element_size;
      pclassdecription = cd.pclassdecription;
      dclass_desc = cd.dclass_desc;
      <B><FONT color="#000080">return</FONT></B>(*<B><FONT color="#000080">this</FONT></B>);
   }

   <B><FONT color="#000080">void</FONT></B> SetFlags(<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> ff)
   {
       flags |= ff;
   }
   
   <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> FlagsMatch(<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> ff)
   {
       <B><FONT color="#000080">return</FONT></B>((flags & ff));
   }

   <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> EraseFlags(<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> gg)
   {
       <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> rr = ~(flags & gg);
       flags &= rr;
       <B><FONT color="#000080">return</FONT></B>(flags);
   }
   
   <B><FONT color="#000080">void</FONT></B> ResetPermision(<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> nn)
   {
       EraseFlags(Private);
       EraseFlags(Protected);
       EraseFlags(Public);
       flags |= nn;
   }

   <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> Size()
   {
     <B><FONT color="#000080">return</FONT></B>(size);
   }

   <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> Offset()
   {
      <B><FONT color="#000080">return</FONT></B>(offset);
   }

   <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> Offset(<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> o)
   {
     <B><FONT color="#000080">if</FONT></B>(FlagsMatch(ArrayType))
     {
       <B><FONT color="#000080">long</FONT></B> nb = (o * element_size) + offset;
       <B><FONT color="#000080">return</FONT></B>(nb);       
     }
     <B><FONT color="#000080">return</FONT></B>(offset);
   }

   <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">int</FONT></B> Array()
   {
     <B><FONT color="#000080">return</FONT></B>(FlagsMatch(ArrayType));
   }

   <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> ElementSize()
   {
      <B><FONT color="#000080">return</FONT></B>(element_size);
   }

   <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> ElementNumber()
   {
     <B><FONT color="#000080">return</FONT></B>(number_of);
   }

   string & Name()
   {
     <B><FONT color="#000080">return</FONT></B>(name);
   }

   <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">int</FONT></B> IsPrivate()
   {
     <B><FONT color="#000080">return</FONT></B>(FlagsMatch(Private));
   }

   <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">int</FONT></B> IsClass()
   {
     <B><FONT color="#000080">return</FONT></B>(FlagsMatch(ClassType));
   }

  <B><FONT color="#000080">void</FONT></B> SetClassDecription(ClassDescription * pcd)
  {
     pclassdecription = pcd;
  }

  ClassDescription * GetClassDescription(<B><FONT color="#000080">void</FONT></B>)
  {
     <B><FONT color="#000080">return</FONT></B>(pclassdecription);
  }

  <B><FONT color="#000080">int</FONT></B> Resolve(InterpreterData & idat);

   <B><FONT color="#000080">void</FONT></B> SetName(string & sn)
   {
     name = sn;
   }

   <B><FONT color="#000080">void</FONT></B> SetPrivate()
   {
     SetFlags(Private);
   }

   <B><FONT color="#000080">void</FONT></B> SetSize(<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> num, <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> siz)
   {
     <B><FONT color="#000080">if</FONT></B>(num &gt; <FONT color="#800000">1</FONT>)
      {
        size = num *siz;
        number_of = num;
        element_size = siz;
        SetFlags(ArrayType);
      }
      <B><FONT color="#000080">else</FONT></B>
      {
        size = siz;
        number_of = <FONT color="#800000">1</FONT>;
        element_size = size; 
      }
   }

   <B><FONT color="#000080">void</FONT></B> SetOffset(<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> gs)
   {
       offset = gs;
   }

   <B><FONT color="#000080">void</FONT></B> SetDClassDesc(ClassDescription * dc)
   {
     dclass_desc = dc;
     SetFlags(ClassType);
   }

   ClassDescription * DClassDesc(<B><FONT color="#000080">void</FONT></B>)
   {
      <B><FONT color="#000080">return</FONT></B>(dclass_desc);
   }

   <B><FONT color="#000080">void</FONT></B> Decompile(string& dtext, InterpreterData & idat); 
};

<I><FONT color="#008080">// method object for forth classes</FONT></I>
<B><FONT color="#000080">class</FONT></B> ClassMethod
{
  string name;
  <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> flags;
  vector&lt;Element &gt; method;
  <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> mindex;  <I><FONT color="#008080">// method index</FONT></I>
  ClassDescription * pclassdecription;

 <B><FONT color="#000080">public</FONT></B>:

  <B><FONT color="#000080">enum</FONT></B> CompFlag
  {
    ExecuteCompile =   <FONT color="#800000">0x01</FONT>,
    Hidden =           <FONT color="#800000">0x02</FONT>,
    Private =          <FONT color="#800000">0x04</FONT>,
    Protected =        <FONT color="#800000">0x08</FONT>,
    Public =          <FONT color="#800000">0x010</FONT>,
    ArrayType =       <FONT color="#800000">0x020</FONT>,
    ClassType =       <FONT color="#800000">0x040</FONT>
  };

  <B><FONT color="#000080">enum</FONT></B> exerrors
  {
    Ok,
    None,
    ErrorExec,
  };

  <I><FONT color="#008080">// duplicate of </FONT></I>

 ClassMethod()
 {
   flags = 0L;
   name.reserve(<FONT color="#800000">120</FONT>);
   method.reserve(<FONT color="#800000">20</FONT>);
   pclassdecription = NULL;
 }

 ClassMethod(string& nm, ClassDescription *cd)
 {
   flags = 0L;
   name.reserve(<FONT color="#800000">120</FONT>);
   method.reserve(<FONT color="#800000">20</FONT>);
   name = nm;
   pclassdecription = cd;
 }

 ~ClassMethod()
 {
   ;
 }

 ClassMethod(<B><FONT color="#000080">const</FONT></B> ClassMethod & mm)
 {
   name = mm.name;
   method.reserve(mm.method.size() + <FONT color="#800000">1</FONT>);
   method = mm.method;
   flags = mm.flags;
   pclassdecription = mm.pclassdecription;
 }

 explicit ClassMethod(<B><FONT color="#000080">const</FONT></B> Word & ww, ClassDescription * cd)
 {
   name = ww.name;
   method.reserve(ww.word.size() + <FONT color="#800000">1</FONT>);
   method = ww.word;
   flags = ww.flags;
   pclassdecription = cd;
 }

 ClassMethod & <B><FONT color="#000080">operator</FONT></B> = (<B><FONT color="#000080">const</FONT></B> ClassMethod & mm)
 {
   name = mm.name;
   method = mm.method;
   flags = mm.flags;
   pclassdecription = mm.pclassdecription;
   <B><FONT color="#000080">return</FONT></B>(*<B><FONT color="#000080">this</FONT></B>);
 }

 <B><FONT color="#000080">void</FONT></B> NewName(string & cs)
 {
   name = cs;
 }

 <B><FONT color="#000080">void</FONT></B> AddClassDecription(ClassDescription * pcd)
 {
   pclassdecription = pcd;
 }

 ClassDescription * GetClassDescription(<B><FONT color="#000080">void</FONT></B>)
 {
   <B><FONT color="#000080">return</FONT></B>(pclassdecription);
 }

 <B><FONT color="#000080">void</FONT></B> AddElement(Element & el)
 {
   <B><FONT color="#000080">if</FONT></B>((method.capacity() - method.size()) &lt; <FONT color="#800000">10</FONT>)
   {
     method.reserve(method.capacity() + <FONT color="#800000">20</FONT>);
   }
   method.push_back(el);
 }

 <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> MethodIndex(<B><FONT color="#000080">void</FONT></B>)
 {
   <B><FONT color="#000080">return</FONT></B>(mindex);
 }

 <B><FONT color="#000080">void</FONT></B> SetMethodIndex(<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> ii)
 {
   mindex = ii;
 }

 <B><FONT color="#000080">void</FONT></B> SetFlags(<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> ff)
 {
   flags |= ff;
 }

 <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> FlagsMatch(<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> ff)
 {
   <B><FONT color="#000080">return</FONT></B>((flags & ff));
 }

 <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> EraseFlags(<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> gg)
 {
   <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> rr = ~(flags & gg);
   flags &= rr;
   <B><FONT color="#000080">return</FONT></B>(flags);
 }

 <B><FONT color="#000080">void</FONT></B> ResetPermision(<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> nn)
 {
    EraseFlags(Private);
    EraseFlags(Protected);
    EraseFlags(Public);
    flags |= nn;
 }

 string& Name()
 {
   <B><FONT color="#000080">return</FONT></B>(name);
 }

 string *NamePtr()
 {
   <B><FONT color="#000080">return</FONT></B>(&name);
 }

 <B><FONT color="#000080">void</FONT></B> SetName(string & ss)
 {
   name = ss;
 }

 <B><FONT color="#000080">int</FONT></B> NextUse(ClassMethod * mm, <B><FONT color="#000080">int</FONT></B> index)
 {
    <B><FONT color="#000080">for</FONT></B>(<B><FONT color="#000080">int</FONT></B> ii = (index + <FONT color="#800000">1</FONT>);ii &lt; method.size();ii++)
    {
       <B><FONT color="#000080">if</FONT></B>(method[ii].IsMethod(mm))
       {
         <B><FONT color="#000080">return</FONT></B>(ii);
       }
    }
    <B><FONT color="#000080">return</FONT></B>(-<FONT color="#800000">1</FONT>);
 }

 <B><FONT color="#000080">int</FONT></B> NextUse(ClassData * dm, <B><FONT color="#000080">int</FONT></B> index)
 {
    <B><FONT color="#000080">for</FONT></B>(<B><FONT color="#000080">int</FONT></B> ii = (index + <FONT color="#800000">1</FONT>);ii &lt; method.size();ii++)
    {
       <B><FONT color="#000080">if</FONT></B>(method[ii].IsData(dm))
       {
         <B><FONT color="#000080">return</FONT></B>(ii);
       }
    }
    <B><FONT color="#000080">return</FONT></B>(-<FONT color="#800000">1</FONT>);
 }

 <B><FONT color="#000080">int</FONT></B> NextUse(Word * ww, <B><FONT color="#000080">int</FONT></B> index)
 {
    <B><FONT color="#000080">for</FONT></B>(<B><FONT color="#000080">int</FONT></B> ii = (index + <FONT color="#800000">1</FONT>);ii &lt; method.size();ii++)
    {
       <B><FONT color="#000080">if</FONT></B>(method[ii].IsWord(ww))
       {
         <B><FONT color="#000080">return</FONT></B>(ii);
       }
    }
    <B><FONT color="#000080">return</FONT></B>(-<FONT color="#800000">1</FONT>);
 }

 <B><FONT color="#000080">int</FONT></B> LastUse(ClassMethod * mm, <B><FONT color="#000080">int</FONT></B> index)
 {
    <B><FONT color="#000080">for</FONT></B>(<B><FONT color="#000080">int</FONT></B> ii = index;ii &gt;= <FONT color="#800000">0</FONT>;ii--)
    {
       <B><FONT color="#000080">if</FONT></B>(method[ii].IsMethod(mm))
       {
         <B><FONT color="#000080">return</FONT></B>(ii);
       }
    }
    <B><FONT color="#000080">return</FONT></B>(-<FONT color="#800000">1</FONT>);
 }

 <B><FONT color="#000080">int</FONT></B> LastUse(ClassData * mm, <B><FONT color="#000080">int</FONT></B> index)
 {
    <B><FONT color="#000080">for</FONT></B>(<B><FONT color="#000080">int</FONT></B> ii = index;ii &gt;= <FONT color="#800000">0</FONT>;ii--)
    {
       <B><FONT color="#000080">if</FONT></B>(method[ii].IsData(mm))
       {
         <B><FONT color="#000080">return</FONT></B>(ii);
       }
    }
    <B><FONT color="#000080">return</FONT></B>(-<FONT color="#800000">1</FONT>);
 }

 <B><FONT color="#000080">int</FONT></B> LastUse(Word * ww, <B><FONT color="#000080">int</FONT></B> index)
 {
    <B><FONT color="#000080">for</FONT></B>(<B><FONT color="#000080">int</FONT></B> ii = index;ii &gt;= <FONT color="#800000">0</FONT>;ii--)
    {
       <B><FONT color="#000080">if</FONT></B>(method[ii].IsWord(ww))
       {
         <B><FONT color="#000080">return</FONT></B>(ii);
       }
    }
    <B><FONT color="#000080">return</FONT></B>(-<FONT color="#800000">1</FONT>);
 }

 <B><FONT color="#000080">int</FONT></B> NextIndex()
 {
   <B><FONT color="#000080">return</FONT></B>(method.size());
 }

 <B><FONT color="#000080">void</FONT></B> LiteralAddress(<B><FONT color="#000080">int</FONT></B> index, <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>* ll)
 {
   <B><FONT color="#000080">if</FONT></B> (index &gt;= <FONT color="#800000">0</FONT> && index &lt; method.size())
   {
     method[index].FetchLiteralAdr(ll);
   }
   <B><FONT color="#000080">else</FONT></B>
   {
     ll = NULL;
   }
 }

 <B><FONT color="#000080">void</FONT></B> LiteralValue(<B><FONT color="#000080">int</FONT></B> index, <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>* ll)
 {
   <B><FONT color="#000080">if</FONT></B> (index &gt;= <FONT color="#800000">0</FONT> && index &lt; method.size())
   {
     method[index].FetchLiteralVal(ll);
   }
 }

 <B><FONT color="#000080">void</FONT></B> SetLiteralValue(<B><FONT color="#000080">int</FONT></B> index, <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>* ll)
 {
   <B><FONT color="#000080">if</FONT></B> (index &gt;= <FONT color="#800000">0</FONT> && index &lt; method.size())
   {
     method[index].SetLiteralVal(ll);
   }
 }

 <B><FONT color="#000080">void</FONT></B> StringAddress(<B><FONT color="#000080">int</FONT></B> index, string * cs)
 {
   <B><FONT color="#000080">if</FONT></B> (index &gt;= <FONT color="#800000">0</FONT> && index &lt; method.size())
   {
     method[index].FetchLitStringAdr(cs);
   }
   <B><FONT color="#000080">else</FONT></B>
   {
     cs = NULL; 
   }
 }

 <B><FONT color="#000080">void</FONT></B> StringAsCopy(<B><FONT color="#000080">int</FONT></B> index, string& cs)
 {
   <B><FONT color="#000080">if</FONT></B> (index &gt;= <FONT color="#800000">0</FONT> && index &lt; method.size())
   {
     method[index].FetchLitString(cs);
   }
 }

  <B><FONT color="#000080">void</FONT></B> DefinitionAddress(<B><FONT color="#000080">int</FONT></B> index, Word * ww)
  {
    <B><FONT color="#000080">if</FONT></B> (index &gt;= <FONT color="#800000">0</FONT> && index &lt; method.size())
    {
       method[index].FetchDefinitionAdr(ww);
    }
    <B><FONT color="#000080">else</FONT></B>
    {
       ww = NULL; 
    }
  }

  <B><FONT color="#000080">void</FONT></B> DefinitionAddress(<B><FONT color="#000080">int</FONT></B> index, ClassMethod * cm)
  {
    <B><FONT color="#000080">if</FONT></B> (index &gt;= <FONT color="#800000">0</FONT> && index &lt; method.size())
    {
       method[index].FetchMethodDefinitionAdr(cm);
    }
    <B><FONT color="#000080">else</FONT></B>
    {
       cm = NULL; 
    }
  }

 <B><FONT color="#000080">void</FONT></B> DefinitionAddress(<B><FONT color="#000080">int</FONT></B> index, ClassData * dm)
  {
    <B><FONT color="#000080">if</FONT></B> (index &gt;= <FONT color="#800000">0</FONT> && index &lt; method.size())
    {
       method[index].FetchDataDefinitionAdr(dm);
    }
    <B><FONT color="#000080">else</FONT></B>
    {
       dm = NULL; 
    }
  }

 <B><FONT color="#000080">int</FONT></B> Execute(<B><FONT color="#000080">int</FONT></B> index, InterpreterData & intrp, <B><FONT color="#000080">int</FONT></B> imed = <FONT color="#800000">0</FONT>);

 <B><FONT color="#000080">bool</FONT></B> SameWord(<B><FONT color="#000080">int</FONT></B> index, <B><FONT color="#000080">char</FONT></B> *nam, InterpreterData & idat)
 {
    <B><FONT color="#000080">return</FONT></B>(method[index].SameWord(nam, idat));
 }

 <B><FONT color="#000080">void</FONT></B> Decompile(string& dtext, InterpreterData & idat); 

};

<B><FONT color="#000080">class</FONT></B> ClassDescription
{
   <B><FONT color="#000080">long</FONT></B> objsize;
<I><FONT color="#008080">//   bool compiling;</FONT></I>
<I><FONT color="#008080">//   bool compiling_method;</FONT></I>
   map&lt;string, ClassData, less&lt;string&gt; &gt;objectdata;
   map&lt;string, ClassMethod, less&lt;string&gt; &gt;methods;
   vector&lt;string&gt; obj_order;
   vector&lt;string&gt; inherited_order;
   string name;
   deque&lt;<B><FONT color="#000080">char</FONT></B> *&gt; thisstack;
<I><FONT color="#008080">//   bool compile_is_privite;</FONT></I>
   <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> current_offset;
   InterpreterData * pidat;
   <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> flags;
   
 <B><FONT color="#000080">public</FONT></B>:

   <B><FONT color="#000080">enum</FONT></B> DescriptionFlags
   {
     VirtualClass =      <FONT color="#800000">0x01</FONT>,
     CanInherit =        <FONT color="#800000">0x02</FONT>,
     CompilePrivate =    <FONT color="#800000">0x04</FONT>,
     CompileProtected =  <FONT color="#800000">0x08</FONT>,
     CompilePublic =    <FONT color="#800000">0x010</FONT>,
     CompilingNow =     <FONT color="#800000">0x020</FONT>,
     CompilingMethod =  <FONT color="#800000">0x040</FONT>
   };

  ClassDescription()
  {
    objsize = <FONT color="#800000">0</FONT>;
    name.reserve(<FONT color="#800000">120</FONT>);
    flags = 0l;
    SetFlags((CompilingNow | CompilePrivate));
 <I><FONT color="#008080">//   compiling = true;</FONT></I>
 <I><FONT color="#008080">//   compiling_method = false;</FONT></I>
 <I><FONT color="#008080">//   compile_is_privite = true;</FONT></I>
    pidat = NULL;
    obj_order.reserve(<FONT color="#800000">10</FONT>);
    inherited_order.reserve(<FONT color="#800000">10</FONT>);
  }

  ClassDescription(string& nn, InterpreterData * pi)
  {
    name.reserve(<FONT color="#800000">120</FONT>);
    name = nn;
    flags = 0l;
    SetFlags((CompilingNow | CompilePrivate));
    objsize = <FONT color="#800000">0</FONT>;
<I><FONT color="#008080">//    compiling = true;</FONT></I>
<I><FONT color="#008080">//    compiling_method = false;</FONT></I>
<I><FONT color="#008080">//    compile_is_privite = true;</FONT></I>
    pidat = pi;
    obj_order.reserve(<FONT color="#800000">10</FONT>);
    inherited_order.reserve(<FONT color="#800000">10</FONT>);
  }

  ClassDescription(<B><FONT color="#000080">const</FONT></B> ClassDescription & fc)
  {
    name = fc.name;
    objsize = fc.objsize;
<I><FONT color="#008080">//    compiling = fc.compiling;</FONT></I>
    objectdata = fc.objectdata;
    methods = fc.methods;
<I><FONT color="#008080">//    compiling_method = fc.compiling_method;</FONT></I>
<I><FONT color="#008080">//    compile_is_privite = fc.compile_is_privite;</FONT></I>
    pidat = fc.pidat;
    obj_order.reserve(fc.obj_order.capacity());
    obj_order = fc.obj_order;
    inherited_order = fc.inherited_order;
    flags = fc.flags;
  }

  ClassDescription& <B><FONT color="#000080">operator</FONT></B> = (<B><FONT color="#000080">const</FONT></B> ClassDescription & fc)
  {
    name = fc.name;
    objsize = fc.objsize;
<I><FONT color="#008080">//    compiling = fc.compiling;</FONT></I>
    objectdata = fc.objectdata;
    methods = fc.methods;
<I><FONT color="#008080">//    compiling_method = fc.compiling_method;</FONT></I>
<I><FONT color="#008080">//    compile_is_privite = fc.compile_is_privite;</FONT></I>
    pidat = fc.pidat;
    obj_order.reserve(fc.obj_order.capacity());
    obj_order = fc.obj_order;
    inherited_order.reserve(fc.inherited_order.capacity());
    inherited_order = fc.inherited_order;
    flags = fc.flags;
    <B><FONT color="#000080">return</FONT></B>(*<B><FONT color="#000080">this</FONT></B>);
  }

   <B><FONT color="#000080">bool</FONT></B> <B><FONT color="#000080">operator</FONT></B> &lt; (<B><FONT color="#000080">const</FONT></B> ClassDescription& cd) 
   {
      <B><FONT color="#000080">if</FONT></B>(name &lt; cd.name)
      {
          <B><FONT color="#000080">return</FONT></B>(true);
      }
      <B><FONT color="#000080">return</FONT></B>(false);
   }

  <B><FONT color="#000080">bool</FONT></B> <B><FONT color="#000080">operator</FONT></B> == (<B><FONT color="#000080">const</FONT></B> ClassDescription& cd) 
   {
      <B><FONT color="#000080">if</FONT></B>(name == cd.name)
      {
          <B><FONT color="#000080">return</FONT></B>(true);
      }
      <B><FONT color="#000080">return</FONT></B>(false);
   }

 <B><FONT color="#000080">void</FONT></B> SetFlags(<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> ff)
 {
   flags |= ff;
 }

 <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> FlagsMatch(<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> ff)
 {
   <B><FONT color="#000080">return</FONT></B>((flags & ff));
 }

 <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> EraseFlags(<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> gg)
 {
   <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> rr = ~(flags & gg);
   flags &= rr;
   <B><FONT color="#000080">return</FONT></B>(flags);
 }

  <B><FONT color="#000080">void</FONT></B> PushInheritedThis(<B><FONT color="#000080">char</FONT></B> * nths);
  <B><FONT color="#000080">void</FONT></B> PopInheritedThis(<B><FONT color="#000080">void</FONT></B>);

  <B><FONT color="#000080">void</FONT></B> PushThis(<B><FONT color="#000080">char</FONT></B> * nth)
  {
    thisstack.push_front(nth);
    PushInheritedThis(nth);
  }

  <B><FONT color="#000080">char</FONT></B> *ThisFront(<B><FONT color="#000080">void</FONT></B>)
  {
    <B><FONT color="#000080">return</FONT></B>(thisstack.front());
  }

  <B><FONT color="#000080">void</FONT></B> PopThis(<B><FONT color="#000080">void</FONT></B>)
  {
    thisstack.pop_front();
    PopInheritedThis();
  }

  <B><FONT color="#000080">bool</FONT></B> IsMethodCompiling()
  {
    <B><FONT color="#000080">if</FONT></B>(FlagsMatch(CompilingMethod))
    {
      <B><FONT color="#000080">return</FONT></B>(true);
    }
    <B><FONT color="#000080">return</FONT></B>(false);
  }

  <B><FONT color="#000080">void</FONT></B> SetMethodCompile(<B><FONT color="#000080">bool</FONT></B> bv)
  {
    <B><FONT color="#000080">if</FONT></B>(bv == true)
    {
       SetFlags(CompilingMethod);
    }
    <B><FONT color="#000080">else</FONT></B>
    {
       EraseFlags(CompilingMethod);
    }
  }

      <B><FONT color="#000080">bool</FONT></B> Compiling(<B><FONT color="#000080">void</FONT></B>)
      {
           <B><FONT color="#000080">if</FONT></B>(FlagsMatch(CompilingNow))
            {
              <B><FONT color="#000080">return</FONT></B>(true);
            }
            <B><FONT color="#000080">return</FONT></B>(false);
      }
      
      <B><FONT color="#000080">bool</FONT></B> IsPrivateMode()
      {
           <B><FONT color="#000080">if</FONT></B>(FlagsMatch(CompilePrivate))
            {
              <B><FONT color="#000080">return</FONT></B>(true);
            }
            <B><FONT color="#000080">return</FONT></B>(false);
      }
      
      <B><FONT color="#000080">bool</FONT></B> IsProtectedMode()
      {
          <B><FONT color="#000080">if</FONT></B>(FlagsMatch(CompileProtected))
          {
              <B><FONT color="#000080">return</FONT></B>(true);
          }
          <B><FONT color="#000080">return</FONT></B>(false);
      }
      
      <B><FONT color="#000080">void</FONT></B> SetPrivateMode(<B><FONT color="#000080">bool</FONT></B> pm)
      {
          <B><FONT color="#000080">if</FONT></B>(pm == true)
          {
              pidat-&gt;DebugTrace(<FONT color="#800000">"set class compile to private:"</FONT>); 
              EraseFlags(CompilePublic); 
              EraseFlags(CompileProtected); 
              SetFlags(CompilePrivate);
          }
          <B><FONT color="#000080">else</FONT></B>
          {
              pidat-&gt;DebugTrace(<FONT color="#800000">"set class compile to public:"</FONT>); 
              EraseFlags(CompilePrivate); 
              EraseFlags(CompileProtected); 
              SetFlags(CompilePublic);
          }
      }
      
      <B><FONT color="#000080">void</FONT></B> SetProtectedMode()
      {
          pidat-&gt;DebugTrace(<FONT color="#800000">"set class compile to protected:"</FONT>); 
          EraseFlags(CompilePublic); 
          EraseFlags(CompilePrivate); 
          SetFlags(CompileProtected);
          
      }
      
      <B><FONT color="#000080">void</FONT></B> SetPublicdMode()
      {
          pidat-&gt;DebugTrace(<FONT color="#800000">"set class compile to protected:"</FONT>); 
          EraseFlags(CompileProtected); 
          EraseFlags(CompilePrivate); 
          SetFlags(CompilePublic);
      }

  <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> CurrentOffset()
  {
    <B><FONT color="#000080">return</FONT></B>(current_offset);
  }

  <B><FONT color="#000080">void</FONT></B> Inherit(string &nam, <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> mode);

  <B><FONT color="#000080">void</FONT></B> AddInheretedName(string & sc)
  {
       <B><FONT color="#000080">if</FONT></B>((inherited_order.capacity() - inherited_order.size()) &lt; <FONT color="#800000">3</FONT>)
        {
           inherited_order.reserve(inherited_order.size() + <FONT color="#800000">10</FONT>);
        }
       inherited_order.push_back(sc);
  }

 ClassDescription * InheritedClassDescription(string & cn);

 ClassData * InheritedClassData(string & nam);
 ClassMethod * InheritedClassMethod(string & nam);
 <B><FONT color="#000080">void</FONT></B> ResetNamesForInherit(string &prepend); 
 <B><FONT color="#000080">void</FONT></B> CallDestructor(<B><FONT color="#000080">void</FONT></B>);
 <B><FONT color="#000080">void</FONT></B> CallConstructor(<B><FONT color="#000080">char</FONT></B> * tt);

  <B><FONT color="#000080">bool</FONT></B> MethodExists(string & nm)
  {
      map&lt;string, ClassMethod, less&lt;string&gt; &gt;::iterator ii;
      ii = methods.find(nm);
       
     <B><FONT color="#000080">if</FONT></B>(ii != methods.end())
      {
        <B><FONT color="#000080">return</FONT></B>(true);
      }
     <B><FONT color="#000080">else</FONT></B>
     {
       <B><FONT color="#000080">if</FONT></B>(InheritedClassMethod(nm) != NULL)
       {
         <B><FONT color="#000080">return</FONT></B>(true);
       }
     }
    <B><FONT color="#000080">return</FONT></B>(false);
  }

  <B><FONT color="#000080">bool</FONT></B> DataExists(string & nm)
  {
      map&lt;string, ClassData, less&lt;string&gt; &gt;::iterator ii;
      ii = objectdata.find(nm);
       
     <B><FONT color="#000080">if</FONT></B>(ii != objectdata.end())
      {
        <B><FONT color="#000080">return</FONT></B>(true);
      }
     <B><FONT color="#000080">else</FONT></B>
     {
       <B><FONT color="#000080">if</FONT></B>(InheritedClassData(nm) != NULL)
       {
         <B><FONT color="#000080">return</FONT></B>(true);
       }
     }

    <B><FONT color="#000080">return</FONT></B>(false);
  }

  <B><FONT color="#000080">bool</FONT></B> AddMethod(ClassMethod & cm, <B><FONT color="#000080">bool</FONT></B> override)
  {
     <B><FONT color="#000080">if</FONT></B>(IsPrivateMode())
     {
         cm.ResetPermision(ClassMethod::Private);
     }
     <B><FONT color="#000080">else</FONT></B>
     {
         <B><FONT color="#000080">if</FONT></B>(IsProtectedMode())
         {
             cm.ResetPermision(ClassMethod::Protected);
         }
         <B><FONT color="#000080">else</FONT></B>
         {
             cm.ResetPermision(ClassMethod::Public);
         }
     }

     map&lt;string, ClassMethod, less&lt;string&gt; &gt;::iterator ii;
     ii = methods.find(cm.Name());
       
     <B><FONT color="#000080">if</FONT></B>(ii == methods.end())
      {
         methods[cm.Name()] = cm;
         <B><FONT color="#000080">char</FONT></B> test1[<FONT color="#800000">200</FONT>];
         sprintf(test1, <FONT color="#800000">"Added method %s in ClassDescription::AddMethod()"</FONT>, cm.Name().c_str());
         pidat-&gt;DebugTrace(test1); 
         <B><FONT color="#000080">return</FONT></B>(true);
     }
     <B><FONT color="#000080">else</FONT></B>
     {
       <B><FONT color="#000080">if</FONT></B>(override)
       {
<I><FONT color="#008080">//           map&lt;string, ClassMethod, less&lt;string&gt; &gt;::iterator ii;</FONT></I>
<I><FONT color="#008080">//           ii = methods.find(cm.Name());</FONT></I>
<I><FONT color="#008080">//           methods.erase(ii);</FONT></I>
<I><FONT color="#008080">//           methods[cm.Name()] =  cm;</FONT></I>
<I><FONT color="#008080">//           return(true);</FONT></I>
       }
     }
     <B><FONT color="#000080">return</FONT></B>(false);
  }

  <B><FONT color="#000080">bool</FONT></B> AddData(ClassData & dm)
  {
     <B><FONT color="#000080">if</FONT></B>(IsPrivateMode())
     {
         dm.ResetPermision(ClassData::Private);
     }
     <B><FONT color="#000080">else</FONT></B>
     {
       <B><FONT color="#000080">if</FONT></B>(IsProtectedMode())
       {
           dm.ResetPermision(ClassData::Protected);
       }
       <B><FONT color="#000080">else</FONT></B>
       {
           dm.ResetPermision(ClassData::Public);
       }
     }

     <B><FONT color="#000080">if</FONT></B>(dm.IsClass())
     {
       pidat-&gt;DebugTrace(<FONT color="#800000">"adding class in AddData"</FONT>);
     }

     <B><FONT color="#000080">if</FONT></B>(DataExists(dm.Name()) == false)
     {
        objectdata[dm.Name()] =  dm;
        <B><FONT color="#000080">if</FONT></B>((obj_order.capacity() - obj_order.size()) &lt; <FONT color="#800000">3</FONT>)
        {
           obj_order.reserve(obj_order.size() + <FONT color="#800000">10</FONT>);
        }
        obj_order.push_back(dm.Name());
        current_offset += dm.Size();
        <B><FONT color="#000080">return</FONT></B>(true);
     }
     <B><FONT color="#000080">return</FONT></B>(false);
  }
  
  ClassMethod * MethodDesc(string & nm)
  {
      map&lt;string, ClassMethod, less&lt;string&gt; &gt;::iterator ii;
      ClassMethod * pcm = NULL;
      <B><FONT color="#000080">char</FONT></B> test1[<FONT color="#800000">100</FONT>];

      sprintf(test1, <FONT color="#800000">"%s method search for %s"</FONT>, name.c_str(), nm.c_str());
      pidat-&gt;DebugTrace(test1);

      ii = methods.find(nm);
      
      <B><FONT color="#000080">if</FONT></B>(ii != methods.end())
      {
          pcm = &(*ii).second;
         
          sprintf(test1, <FONT color="#800000">"%s found method %s in ClassDescription::MethodDesc() as %lx"</FONT>, name.c_str(), nm.c_str(), (<B><FONT color="#000080">void</FONT></B> *)pcm);
          pidat-&gt;DebugTrace(test1); 
          <B><FONT color="#000080">return</FONT></B>(pcm);
      }
      pcm = InheritedClassMethod(nm);
      <B><FONT color="#000080">return</FONT></B>(pcm);
  }
  
  ClassData * DataDesc(string & nm)
  {
      map&lt;string, ClassData, less&lt;string&gt; &gt;::iterator ii;
      ClassData * pcd = NULL;
      <B><FONT color="#000080">char</FONT></B> test1[<FONT color="#800000">100</FONT>];

      sprintf(test1, <FONT color="#800000">"%s data search for %s"</FONT>, name.c_str(), nm.c_str());
      pidat-&gt;DebugTrace(test1);
      ii = objectdata.find(nm);
      
      <B><FONT color="#000080">if</FONT></B>(ii != objectdata.end())
      {
          pcd = &(*ii).second;
          
          sprintf(test1, <FONT color="#800000">"%s found object %s in ClassDescription::DataDesc() as %lx"</FONT>, name.c_str(), nm.c_str(), (<B><FONT color="#000080">void</FONT></B> *)pcd);
          pidat-&gt;DebugTrace(test1); 
          <B><FONT color="#000080">return</FONT></B>(pcd);
      }
      pcd = InheritedClassData(nm); 
      <B><FONT color="#000080">return</FONT></B>(pcd);
  }

   <B><FONT color="#000080">bool</FONT></B> MethodDescObject(string & nm, ClassMethod & mm)
  {
      map&lt;string, ClassMethod, less&lt;string&gt; &gt;::iterator ii;
      ii = methods.find(nm);
       
     <B><FONT color="#000080">if</FONT></B>(ii != methods.end())
      {
         mm = (*ii).second;
         <B><FONT color="#000080">return</FONT></B>(true);
       }
    <B><FONT color="#000080">return</FONT></B>(false);
  }

   <B><FONT color="#000080">bool</FONT></B> DataDescObject(string & nm, ClassData & dm)
  {
      map&lt;string, ClassData, less&lt;string&gt; &gt;::iterator ii;
      ii = objectdata.find(nm);
       
     <B><FONT color="#000080">if</FONT></B>(ii != objectdata.end())
      {
         dm = (*ii).second;
         <B><FONT color="#000080">return</FONT></B>(true);
      }
    <B><FONT color="#000080">return</FONT></B>(false);
  }


  string & Name(<B><FONT color="#000080">void</FONT></B>)
  {
    <B><FONT color="#000080">return</FONT></B>(name);
  }

  <B><FONT color="#000080">void</FONT></B> SetName(string & ss)
  {
    name = ss;
  }

  <B><FONT color="#000080">bool</FONT></B> RenameMethod(string &onam, string &nnam)
  {
      map&lt;string, ClassMethod, less&lt;string&gt; &gt;::iterator ii;
      ii = methods.find(onam);
      ClassMethod mm;
       
     <B><FONT color="#000080">if</FONT></B>(ii != methods.end())
      {
         mm = (*ii).second;
         mm.SetName(nnam);
         methods.erase(ii);
         methods[nnam] =  mm;
         <B><FONT color="#000080">return</FONT></B>(true);
       }
    <B><FONT color="#000080">return</FONT></B>(false);    
  }

  <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> Size(<B><FONT color="#000080">void</FONT></B>)
  {
    <B><FONT color="#000080">return</FONT></B>(objsize);
  }

  <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> CalkObjSize(<B><FONT color="#000080">void</FONT></B>)
  {
    map&lt;string, ClassData, less&lt;string&gt; &gt;::iterator ii;
    vector&lt;string&gt;:: iterator jj;
    <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> rets = 0l;

    <B><FONT color="#000080">for</FONT></B>(jj = obj_order.begin(); jj != obj_order.end(); jj++)
    {
      ii = objectdata.find((*jj));
      <B><FONT color="#000080">if</FONT></B>(ii != objectdata.end())
      {
        (*ii).second.SetOffset(rets);
        rets += (*ii).second.Size();        
      }
    }
    <B><FONT color="#000080">return</FONT></B>(rets);
  }

<I><FONT color="#008080">// for permision inheritance</FONT></I>

  <B><FONT color="#000080">void</FONT></B> ResetAllPrivate(<B><FONT color="#000080">void</FONT></B>)
  {
      map&lt;string, ClassData, less&lt;string&gt; &gt;::iterator ii;
      map&lt;string, ClassMethod, less&lt;string&gt; &gt;::iterator kk;
      vector&lt;string&gt;:: iterator jj;
      
      <B><FONT color="#000080">for</FONT></B>(jj = obj_order.begin(); jj != obj_order.end(); jj++)
      {
          ii = objectdata.find((*jj));
          <B><FONT color="#000080">if</FONT></B>(ii != objectdata.end())
          {
              (*ii).second.ResetPermision(ClassData::Private);
          }
      }
  }
  
  <B><FONT color="#000080">void</FONT></B> ResetAllProtected(<B><FONT color="#000080">void</FONT></B>)
  {
      map&lt;string, ClassData, less&lt;string&gt; &gt;::iterator ii;
      map&lt;string, ClassMethod, less&lt;string&gt; &gt;::iterator kk;
      vector&lt;string&gt;:: iterator jj;
      
      <B><FONT color="#000080">for</FONT></B>(jj = obj_order.begin(); jj != obj_order.end(); jj++)
      {
          ii = objectdata.find((*jj));
          <B><FONT color="#000080">if</FONT></B>(ii != objectdata.end())
          {
              <B><FONT color="#000080">if</FONT></B>(ii-&gt;second.FlagsMatch(ClassData::Public))
              {
                  (*ii).second.ResetPermision(ClassData::Protected);
              }
          }
      }
  }
  
  <B><FONT color="#000080">void</FONT></B> Done(<B><FONT color="#000080">void</FONT></B>)
  {
      EraseFlags(CompilingNow);
      objsize = CalkObjSize();
  }

  <B><FONT color="#000080">void</FONT></B> Decompile(string & tt, InterpreterData & idat)
  {
      map&lt;string, ClassData, less&lt;string&gt; &gt;::iterator ii;
      map&lt;string, ClassMethod, less&lt;string&gt; &gt;::iterator kk;
      vector&lt;string&gt;:: iterator jj;
      <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> rets = 0l;
      
      tt += <FONT color="#800000">"\nClass Name: \""</FONT>;
      tt += name;
      tt += <FONT color="#800000">"\""</FONT>;
      
      <B><FONT color="#000080">for</FONT></B>(jj = obj_order.begin(); jj != obj_order.end(); jj++)
      {
          ii = objectdata.find((*jj));
          <B><FONT color="#000080">if</FONT></B>(ii != objectdata.end())
          {
              idat.DebugTrace(<FONT color="#800000">"decompiling object"</FONT>);
              (*ii).second.Decompile(tt, idat);
          }
      }
      <B><FONT color="#000080">for</FONT></B>(kk = methods.begin(); kk != methods.end(); kk++)
      {
          <B><FONT color="#000080">if</FONT></B>(kk != methods.end())
          {
              idat.DebugTrace(<FONT color="#800000">"decompiling method"</FONT>);
              (*kk).second.Decompile(tt, idat);
          }
      }
      tt += <FONT color="#800000">"\n --End-of-class-decompile---"</FONT>;
  }

};

<I><FONT color="#008080">// idat.ClassDSCR()</FONT></I>

<B><FONT color="#000080">class</FONT></B> ClassDescriptions
{
   map&lt;string, ClassDescription, less&lt;string&gt; &gt; cld;
   deque&lt;string&gt; compiling;
   InterpreterData * pidat;

<B><FONT color="#000080">public</FONT></B>:

   ClassDescriptions()
   {
     InterpreterData * pidat = NULL;
   }

   ClassDescriptions(<B><FONT color="#000080">const</FONT></B> ClassDescriptions & cds)
   {
     cld = cds.cld;
     compiling = cds.compiling;
   }

   <B><FONT color="#000080">void</FONT></B> SetInterpreterData(InterpreterData * pi)
   {
     pidat = pi;
   }
   
   <B><FONT color="#000080">bool</FONT></B> Find(string & sn, ClassDescription * pcd)
   {
       map&lt;string, ClassDescription, less&lt;string&gt; &gt;::iterator ii;
       <B><FONT color="#000080">char</FONT></B> test1[<FONT color="#800000">200</FONT>];

       ii = cld.find(sn);
       <B><FONT color="#000080">if</FONT></B>(ii != cld.end())
       {
         pcd = &((*ii).second);

         sprintf(test1, <FONT color="#800000">"Address in ClassDescription * cd = %lx in ClassDescriptions::Find(%s) (found)"</FONT>, (<B><FONT color="#000080">void</FONT></B> *)pcd, sn.c_str());
         pidat-&gt;DebugTrace(test1); 
         <B><FONT color="#000080">return</FONT></B>(true);
       }
       pcd = NULL;
       sprintf(test1, <FONT color="#800000">"NULL Address in ClassDescription * cd = %lx in ClassDescriptions::Find(%s) (not found)"</FONT>, (<B><FONT color="#000080">void</FONT></B> *)pcd, sn.c_str());
       pidat-&gt;DebugTrace(test1); 
       <B><FONT color="#000080">return</FONT></B>(false);
   }

   ClassDescription * Find(string & sn)
   {
       map&lt;string, ClassDescription, less&lt;string&gt; &gt;::iterator ii;
       <B><FONT color="#000080">char</FONT></B> test1[<FONT color="#800000">200</FONT>];
       ClassDescription *pcd;

       ii = cld.find(sn);
       <B><FONT color="#000080">if</FONT></B>(ii != cld.end())
       {
         pcd = &((*ii).second);

         sprintf(test1, <FONT color="#800000">"Address in ClassDescription * cd = %lx in ClassDescriptions::Find(%s) (found)"</FONT>, (<B><FONT color="#000080">void</FONT></B> *)pcd, sn.c_str());
         pidat-&gt;DebugTrace(test1); 
         <B><FONT color="#000080">return</FONT></B>(pcd);
       }
       pcd = NULL;
       sprintf(test1, <FONT color="#800000">"NULL Address in ClassDescription * cd = %lx in ClassDescriptions::Find(%s) (not found)"</FONT>, (<B><FONT color="#000080">void</FONT></B> *)pcd, sn.c_str());
       pidat-&gt;DebugTrace(test1); 
       <B><FONT color="#000080">return</FONT></B>(pcd);
   }

  <B><FONT color="#000080">bool</FONT></B> Find(<B><FONT color="#000080">char</FONT></B> * wrd, ClassDescription * acd)
   {
       <B><FONT color="#000080">if</FONT></B>(wrd == NULL)
       {
         <B><FONT color="#000080">return</FONT></B>(false);
       }
       string snn;
       snn.reserve(<FONT color="#800000">120</FONT>);
       snn = wrd;
       <B><FONT color="#000080">bool</FONT></B> rv = Find(snn, acd);

       <B><FONT color="#000080">return</FONT></B>(rv);
   }

  <B><FONT color="#000080">bool</FONT></B> AddDescription(ClassDescription & dd)
  {
      ClassDescription * nd = NULL;
 <I><FONT color="#008080">//     char test1[200];</FONT></I>
      
      pidat-&gt;DebugTrace(<FONT color="#800000">"In AddDescription first find should fail"</FONT>); 
      map&lt;string, ClassDescription, less&lt;string&gt; &gt;::iterator ii;
      
      ii = cld.find(dd.Name());
      <B><FONT color="#000080">if</FONT></B>(ii != cld.end())
      {
          <B><FONT color="#000080">return</FONT></B>(false);
      }
           
      cld[dd.Name()] = dd;
<I><FONT color="#008080">//      nd = NULL;</FONT></I>
<I><FONT color="#008080">//      pidat-&gt;DebugTrace("In AddDescription second find should succeed"); </FONT></I>
<I><FONT color="#008080">//     Sleep(10);</FONT></I>
<I><FONT color="#008080">//     ii = cld.find(dd.Name());</FONT></I>
<I><FONT color="#008080">//      if(ii != cld.end())</FONT></I>
<I><FONT color="#008080">//      {</FONT></I>
<I><FONT color="#008080">//          nd = &((*ii).second);</FONT></I>
<I><FONT color="#008080">//          sprintf(test1, "Address in ClassDescription * nd = %lx in ClassDescriptions::AddDescription after 2nd find", (void *) nd);</FONT></I>
<I><FONT color="#008080">//          pidat-&gt;DebugTrace(test1); </FONT></I>
          compiling.push_front(dd.Name());
          <B><FONT color="#000080">return</FONT></B>(true);
<I><FONT color="#008080">//      }</FONT></I>
<I><FONT color="#008080">//      return(false);</FONT></I>
  }

  <B><FONT color="#000080">bool</FONT></B> AddInheritedDescription(ClassDescription & dd)
  {
      ClassDescription * nd = NULL;
 <I><FONT color="#008080">//     char test1[200];</FONT></I>
      
      
      map&lt;string, ClassDescription, less&lt;string&gt; &gt;::iterator ii;
      
      ii = cld.find(dd.Name());
      <B><FONT color="#000080">if</FONT></B>(ii != cld.end())
      {
          pidat-&gt;DebugTrace(<FONT color="#800000">"AddInheritedDescription FAILED"</FONT>); 
          <B><FONT color="#000080">return</FONT></B>(false);
      }
           
      cld[dd.Name()] = dd;
      pidat-&gt;DebugTrace(<FONT color="#800000">"AddInheritedDescription OK"</FONT>); 
      <B><FONT color="#000080">return</FONT></B>(true);
  }

   ClassDescription *CompilingWhat(<B><FONT color="#000080">void</FONT></B>)
   {
     string name_is;
     name_is.reserve(<FONT color="#800000">120</FONT>);
     ClassDescription * pcd = NULL; 
     <B><FONT color="#000080">if</FONT></B>(compiling.empty() == false)
     {
        name_is = compiling.front();
        map&lt;string, ClassDescription, less&lt;string&gt; &gt;::iterator ii;
        ii = cld.find(name_is);
        <B><FONT color="#000080">if</FONT></B>(ii != cld.end())
        {
           pcd = &((*ii).second);
           <B><FONT color="#000080">char</FONT></B> test1[<FONT color="#800000">200</FONT>];
           sprintf(test1, <FONT color="#800000">"Address in pcd = %lx in ClassDescriptions::CompilingWhat(void)"</FONT>, (<B><FONT color="#000080">void</FONT></B> *)pcd);
           pidat-&gt;DebugTrace(test1); 
           <B><FONT color="#000080">return</FONT></B>(pcd);
        }
        <B><FONT color="#000080">else</FONT></B>
        {
          <B><FONT color="#000080">return</FONT></B>(NULL);
        }
     }
     <B><FONT color="#000080">return</FONT></B>(NULL);
   }

   <B><FONT color="#000080">bool</FONT></B> Compiled()
   {
      ClassDescription *cp = CompilingWhat();
      <B><FONT color="#000080">if</FONT></B>(cp != NULL)
      {
        cp-&gt;Done();
        compiling.pop_front(); 
        pidat-&gt;DebugTrace(<FONT color="#800000">"in ClassDescriptions::Compiled() pop done"</FONT>); 
        <B><FONT color="#000080">return</FONT></B>(true);
      }
      <B><FONT color="#000080">else</FONT></B>
      {
        <B><FONT color="#000080">return</FONT></B>(false);
      }
   }
  
};

<B><FONT color="#000080">class</FONT></B> ParserData
{
  <B><FONT color="#000080">char</FONT></B> * buffer;
  <B><FONT color="#000080">char</FONT></B> * linestart;
  <B><FONT color="#000080">char</FONT></B> * lineend;
  <B><FONT color="#000080">char</FONT></B> * ppos;
  <B><FONT color="#000080">char</FONT></B> * lppos;
  <B><FONT color="#000080">char</FONT></B> line[<FONT color="#800000">1024</FONT>];
  <B><FONT color="#000080">char</FONT></B> cline[<FONT color="#800000">1024</FONT>];
  InterpreterData * pidat;

<B><FONT color="#000080">public</FONT></B>:

    ParserData(<B><FONT color="#000080">char</FONT></B> *buf = NULL, InterpreterData * pi = NULL)
    {
      buffer = buf;
      linestart = lineend = buffer;
      ppos = lppos = line;
      pidat = pi;
      NextLine();
    }

   ParserData(ParserData & pp)
    {
      buffer = pp.buffer;
      linestart = pp.linestart;
      lineend = pp.lineend;
      ppos = pp.ppos;
      lppos = pp.lppos;
      pidat = pp.pidat;
    }

  ParserData & <B><FONT color="#000080">operator</FONT></B> == (ParserData & pp)
    {
      buffer = pp.buffer;
      linestart = pp.linestart;
      lineend = pp.lineend;
      ppos = pp.ppos;
      lppos = pp.lppos;
      pidat = pp.pidat;
      <B><FONT color="#000080">return</FONT></B>(*<B><FONT color="#000080">this</FONT></B>);
    }

  <B><FONT color="#000080">void</FONT></B> ParserTrace(<B><FONT color="#000080">const</FONT></B> <B><FONT color="#000080">char</FONT></B> * cc, <B><FONT color="#000080">const</FONT></B> <B><FONT color="#000080">char</FONT></B> * ee = NULL, <B><FONT color="#000080">int</FONT></B> np = <FONT color="#800000">0</FONT>)
  {
    <B><FONT color="#000080">char</FONT></B> dbl[<FONT color="#800000">220</FONT>];
    <B><FONT color="#000080">if</FONT></B>(ee)
    {
       <B><FONT color="#000080">if</FONT></B>(np == <FONT color="#800000">0</FONT>)
       {
         sprintf(dbl, <FONT color="#800000">"ParserData: %s &gt;&gt;%s&lt;&lt; [%i]"</FONT>, ee, cc, strlen(cc));
       }
       <B><FONT color="#000080">else</FONT></B>
       {
         sprintf(dbl, <FONT color="#800000">"ParserData: %s &gt;&gt;%s&lt;&lt; [%i] (%li)"</FONT>, ee, cc, strlen(cc), np);
       }
    }
    <B><FONT color="#000080">else</FONT></B>
    {
       <B><FONT color="#000080">if</FONT></B>(np == <FONT color="#800000">0</FONT>)
       {
         sprintf(dbl, <FONT color="#800000">"ParserData: &gt;&gt;%s&lt;&lt;"</FONT>, cc);     
       }
       <B><FONT color="#000080">else</FONT></B>
       {
          sprintf(dbl, <FONT color="#800000">"ParserData: &gt;&gt;%s&lt;&lt; (%li)"</FONT>, cc, np);         
       }
    }

    pidat-&gt;DebugTrace(dbl); 
  }

  <B><FONT color="#000080">void</FONT></B> ResetLinePos(<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> nn)
  {
    <B><FONT color="#000080">if</FONT></B>(nn &gt;= <FONT color="#800000">0</FONT> && nn &lt; strlen(line))
    {
       ppos = nn + line;
       lppos = ppos;
    }
  }
  
  <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> LinePos(<B><FONT color="#000080">void</FONT></B>)
  {
<I><FONT color="#008080">//      ParserTrace("LinePos", line, (ppos - line));</FONT></I>
      <B><FONT color="#000080">return</FONT></B>(ppos - line);  
  }

    <B><FONT color="#000080">bool</FONT></B> NextLine(<B><FONT color="#000080">void</FONT></B>)
    {
 <I><FONT color="#008080">//       ParserTrace(" Entered Nextline");</FONT></I>
        <B><FONT color="#000080">char</FONT></B> * oldend = lineend;
        lineend++;
        <B><FONT color="#000080">while</FONT></B>(((*lineend) != <FONT color="#800000">'\n'</FONT>) && (*lineend) != <FONT color="#800000">0</FONT>)
        {
            lineend++;
        }
        
        linestart = oldend;
        <B><FONT color="#000080">if</FONT></B>(linestart != buffer)
        {
           linestart++;
        }
        memcpy(line, linestart, (lineend - linestart));
        line[(lineend - linestart)] = <FONT color="#800000">0</FONT>;
        ppos = line;
        lppos = line;
<I><FONT color="#008080">//        ParserTrace("BufferLine:", line);</FONT></I>
<I><FONT color="#008080">//        ParserTrace("NextLine:", line);</FONT></I>
        <B><FONT color="#000080">if</FONT></B>(*lineend)
        {
<I><FONT color="#008080">//          ParserTrace(" Exiting Nextline true");</FONT></I>
          <B><FONT color="#000080">return</FONT></B>(true);
        }
 <I><FONT color="#008080">//       ParserTrace(" Exiting Nextline false");</FONT></I>
        <B><FONT color="#000080">return</FONT></B>(false);
    }

    <B><FONT color="#000080">bool</FONT></B> AdvancepWhite(<B><FONT color="#000080">void</FONT></B>)
    {
<I><FONT color="#008080">//       ParserTrace("entered AdvancepWhite:");</FONT></I>
       <B><FONT color="#000080">while</FONT></B>((*ppos) != <FONT color="#800000">0</FONT> && (isspace(*ppos)))
       {
         ppos++;
       }
       <B><FONT color="#000080">if</FONT></B>((*ppos) == <FONT color="#800000">0</FONT>)
       {
         <B><FONT color="#000080">return</FONT></B>(false);
       }
<I><FONT color="#008080">//       ParserTrace(ppos, "AdvancepWhite:");</FONT></I>
       <B><FONT color="#000080">return</FONT></B>(true);
    }

    <B><FONT color="#000080">bool</FONT></B> AdvancelpWhite(<B><FONT color="#000080">void</FONT></B>)
    {
       <B><FONT color="#000080">while</FONT></B>(isspace(*lppos))
       {
         lppos++;
       }
<I><FONT color="#008080">//       ParserTrace(lppos, "AdvancelpWhite:");</FONT></I>
       <B><FONT color="#000080">return</FONT></B>(true);
    }

    <B><FONT color="#000080">bool</FONT></B> AdvancepBlack()
    {
      <B><FONT color="#000080">while</FONT></B>((*ppos) != <FONT color="#800000">0</FONT> && !(isspace(*ppos)))
       {
         ppos++;
       }
       
       <B><FONT color="#000080">if</FONT></B>((*ppos) == <FONT color="#800000">0</FONT>)
       {
<I><FONT color="#008080">//         ParserTrace(ppos, "AdvancepBlack: ret == false");</FONT></I>
         <B><FONT color="#000080">return</FONT></B>(false);
       }
<I><FONT color="#008080">//       ParserTrace(ppos, "AdvancepBlack: ret == true");</FONT></I>
       <B><FONT color="#000080">return</FONT></B>(true);
    }

    <B><FONT color="#000080">bool</FONT></B> GetWord(<B><FONT color="#000080">char</FONT></B> * ww)
    {
       <B><FONT color="#000080">int</FONT></B> dd = ppos - lppos;
       <B><FONT color="#000080">if</FONT></B>(dd)
       {
          memcpy(ww, lppos, dd);
          ww[(ppos - lppos)] = <FONT color="#800000">0</FONT>;
<I><FONT color="#008080">//          ParserTrace(ww, "word:");</FONT></I>
          lppos = ppos;
       }
       <B><FONT color="#000080">else</FONT></B>
       {
<I><FONT color="#008080">//          ParserTrace("Word length 0", "word:");</FONT></I>
<I><FONT color="#008080">//          ParserTrace(ppos, "word:ppos");</FONT></I>
<I><FONT color="#008080">//          ParserTrace(lppos, "word:lppos");</FONT></I>
       }
       <B><FONT color="#000080">return</FONT></B>(true);
    }
    
    <B><FONT color="#000080">bool</FONT></B> ToAny(<B><FONT color="#000080">char</FONT></B> nn)
    {
        <B><FONT color="#000080">while</FONT></B>((*ppos) != <FONT color="#800000">0</FONT> && (*ppos) != nn)
        {
            ppos++;
        }
        <B><FONT color="#000080">if</FONT></B>((*ppos) == <FONT color="#800000">0</FONT>)
        {
            <B><FONT color="#000080">return</FONT></B>(false);
        }
<I><FONT color="#008080">//        ParserTrace(ppos, "toAny:");</FONT></I>
<I><FONT color="#008080">//        ParserTrace(lppos, "toAny:");</FONT></I>
        <B><FONT color="#000080">return</FONT></B>(true);   
    }
    
    <B><FONT color="#000080">bool</FONT></B> GetAny(string &cc)
    {
        <B><FONT color="#000080">if</FONT></B>(ppos == lppos)
        {
            <B><FONT color="#000080">return</FONT></B>(false);
        }
<I><FONT color="#008080">//        ParserTrace(ppos, "GetAny:");</FONT></I>
        <B><FONT color="#000080">int</FONT></B> dd = ppos - lppos;
        memcpy(cline, lppos, dd);
        cline[dd] = <FONT color="#800000">0</FONT>;
<I><FONT color="#008080">//        ParserTrace(cline, "GetAny:cline");</FONT></I>
        cc = cline;

<I><FONT color="#008080">//        ppos++;</FONT></I>
<I><FONT color="#008080">//        ParserTrace(ppos, "GetAny p:"); </FONT></I>
<I><FONT color="#008080">//        ParserTrace(ppos, "GetAny lp:"); </FONT></I>
        lppos = ppos;
        <B><FONT color="#000080">return</FONT></B>(true);
    }

 <B><FONT color="#000080">char</FONT></B> GetChar(<B><FONT color="#000080">void</FONT></B>)
 {
   <B><FONT color="#000080">if</FONT></B>((*ppos) == <FONT color="#800000">0</FONT>)
   {
     <B><FONT color="#000080">return</FONT></B>(<FONT color="#800000">0</FONT>);
   }
   <B><FONT color="#000080">return</FONT></B>(*(ppos + <FONT color="#800000">1</FONT>));
 }

 <B><FONT color="#000080">void</FONT></B> Advance(<B><FONT color="#000080">void</FONT></B>)
 {
   <B><FONT color="#000080">if</FONT></B>((*ppos) != <FONT color="#800000">0</FONT>)
   {
      ppos++;
      lppos = ppos;
      <B><FONT color="#000080">if</FONT></B>((*ppos) == <FONT color="#800000">0</FONT>)
      {
        NextLine();
      }
   }
 }

 <B><FONT color="#000080">char</FONT></B> * Takeline(<B><FONT color="#000080">void</FONT></B>)
 {   
   <B><FONT color="#000080">return</FONT></B>(line);
 }
};


<I><FONT color="#008080">// The parser class with a stack of current parsings</FONT></I>

<B><FONT color="#000080">class</FONT></B> Parser
{
  stack&lt;ParserData *&gt; buffstack;
  ParserData* bufnow;
  <B><FONT color="#000080">char</FONT></B> theword[<FONT color="#800000">1000</FONT>];
  <B><FONT color="#000080">bool</FONT></B> usestdout;
  string aline;
  <B><FONT color="#000080">int</FONT></B> outx;
<B><FONT color="#000080">#ifdef</FONT></B> USING_WINDOWS
  HANDLE cinput;
  CONSOLE_SCREEN_BUFFER_INFO sbi;
<B><FONT color="#000080">#endif</FONT></B>
  InterpreterData * pidat;

<B><FONT color="#000080">public</FONT></B>:

<I><FONT color="#008080">//  Parser(char * buf)</FONT></I>
<I><FONT color="#008080">//  {</FONT></I>
<I><FONT color="#008080">//     bufnow = new ParserData(buf);</FONT></I>
<I><FONT color="#008080">//     usestdout = false;</FONT></I>
<I><FONT color="#008080">//     aline.reserve(1000);</FONT></I>
<I><FONT color="#008080">//  }</FONT></I>

  Parser(InterpreterData * idp = NULL)
  {
     bufnow = NULL;
     usestdout = false;
     aline.reserve(<FONT color="#800000">1000</FONT>);
     pidat = idp;
  }

  Parser(<B><FONT color="#000080">const</FONT></B> Parser & pp)
  {
    buffstack = pp.buffstack;
    bufnow = pp.bufnow;
    usestdout = pp.usestdout;
    aline = pp.aline;
    pidat = pp.pidat;
  }

  ~Parser()
  {
    <B><FONT color="#000080">while</FONT></B>(bufnow != NULL)
    {
      <B><FONT color="#000080">delete</FONT></B> bufnow;
      bufnow = NULL;
      <B><FONT color="#000080">if</FONT></B>( buffstack.empty() != true)
      {
        PopBuf();
      }
    }
  }

 Parser& <B><FONT color="#000080">operator</FONT></B> = (<B><FONT color="#000080">const</FONT></B> Parser & pp)
  {
    buffstack = pp.buffstack;
    bufnow = pp.bufnow;
    usestdout = pp.usestdout;
    aline = pp.aline;
    pidat = pp.pidat;
    <B><FONT color="#000080">return</FONT></B>(*<B><FONT color="#000080">this</FONT></B>);
  }

 <B><FONT color="#000080">void</FONT></B> UseStdOut(<B><FONT color="#000080">void</FONT></B>)
 {
     usestdout = true;
 }

 <B><FONT color="#000080">void</FONT></B> NoStdOut(<B><FONT color="#000080">void</FONT></B>)
 {
     usestdout = false;
 }

 <B><FONT color="#000080">bool</FONT></B> IsStdOut(<B><FONT color="#000080">void</FONT></B>)
 {
    <B><FONT color="#000080">return</FONT></B>(usestdout);
 }

 <B><FONT color="#000080">void</FONT></B> Prompt()
 {
    <B><FONT color="#000080">if</FONT></B>(usestdout)
    {
      cout &lt;&lt; endl;
      cout &lt;&lt; <FONT color="#800000">"Forth: "</FONT>;
<B><FONT color="#000080">#ifdef</FONT></B> USING_WINDOWS
      GetConsoleScreenBufferInfo(cinput, &sbi);
      outx = sbi.dwCursorPosition.X;
<B><FONT color="#000080">#endif</FONT></B>
    }
 }

 <B><FONT color="#000080">void</FONT></B> NoPrompt()
 {
    <B><FONT color="#000080">if</FONT></B>(usestdout)
    {
      cout &lt;&lt; endl;
<B><FONT color="#000080">#ifdef</FONT></B> USING_WINDOWS
      GetConsoleScreenBufferInfo(cinput, &sbi);
      outx = sbi.dwCursorPosition.X;
<B><FONT color="#000080">#endif</FONT></B>
    }
 }

 <B><FONT color="#000080">char</FONT></B> * NextWord(<B><FONT color="#000080">bool</FONT></B> once = false)
 {
   <B><FONT color="#000080">if</FONT></B>(bufnow == NULL)
   {
     *pidat-&gt;pIN() = <FONT color="#800000">0</FONT>;
     <B><FONT color="#000080">return</FONT></B>(NULL);
   }
<I><FONT color="#008080">//  pidat-&gt;DebugTrace("Entered nextword"); </FONT></I>

   bufnow-&gt;ResetLinePos((*pidat-&gt;pIN()));
 
   <B><FONT color="#000080">while</FONT></B>(bufnow-&gt;AdvancepWhite() == false)
   {
      pidat-&gt;DebugTrace(<FONT color="#800000">"false from advance p white"</FONT>); 

      <B><FONT color="#000080">if</FONT></B>(bufnow-&gt;NextLine() == false)
      {
<I><FONT color="#008080">//        pidat-&gt;DebugTrace("false from Nextline");</FONT></I>
        <B><FONT color="#000080">if</FONT></B>(once == false)
        {
           PopBuf();
           <B><FONT color="#000080">if</FONT></B>(bufnow == NULL)
           {
               <B><FONT color="#000080">if</FONT></B>(usestdout)
               {
            <B><FONT color="#000080">#ifdef</FONT></B> USING_WINDOWS
                     cinput = GetStdHandle(STD_INPUT_HANDLE);
                     GetConsoleScreenBufferInfo(cinput, &sbi);
                     <B><FONT color="#000080">if</FONT></B>(sbi.dwCursorPosition.X != outx)
                     {
                       Prompt();
                     }
            <B><FONT color="#000080">#endif</FONT></B>
                }
             <B><FONT color="#000080">return</FONT></B>(NULL);
           }
        }
        <B><FONT color="#000080">else</FONT></B>
        { 
           PopBuf();
           <B><FONT color="#000080">if</FONT></B>(bufnow == NULL)
           {
             <B><FONT color="#000080">return</FONT></B>(NULL);
           }
           *pidat-&gt;pIN() = bufnow-&gt;LinePos();
           <B><FONT color="#000080">return</FONT></B>(NULL);
        }
      }
     *pidat-&gt;pIN() = bufnow-&gt;LinePos();
   }

   bufnow -&gt;AdvancelpWhite();

   <B><FONT color="#000080">if</FONT></B>(bufnow-&gt;AdvancepBlack() == false)
   {
      bufnow-&gt;GetWord(theword);
      *pidat-&gt;pIN() = bufnow-&gt;LinePos();
      <B><FONT color="#000080">return</FONT></B>(theword); 
   }
   bufnow-&gt;GetWord(theword);
   *pidat-&gt;pIN() = bufnow-&gt;LinePos();
    <B><FONT color="#000080">return</FONT></B>(theword);
 }

 <B><FONT color="#000080">bool</FONT></B> AllDigits(<B><FONT color="#000080">char</FONT></B> *txt)
 {

    <B><FONT color="#000080">if</FONT></B>(isdigit(txt[<FONT color="#800000">0</FONT>]) == false && txt[<FONT color="#800000">0</FONT>] != <FONT color="#800000">'-'</FONT>)
     {
       <B><FONT color="#000080">return</FONT></B>(false);
     }
    <B><FONT color="#000080">else</FONT></B>
    {
       <B><FONT color="#000080">if</FONT></B>(txt[<FONT color="#800000">0</FONT>] == <FONT color="#800000">'-'</FONT> && strlen(txt) == <FONT color="#800000">1</FONT>)
       {
          <B><FONT color="#000080">return</FONT></B>(false);
       }
    }

   <B><FONT color="#000080">for</FONT></B>(<B><FONT color="#000080">int</FONT></B> ii = <FONT color="#800000">1</FONT>;ii &lt; strlen(txt);ii++)
   {
     <B><FONT color="#000080">if</FONT></B>(isdigit(txt[ii]) == false)
     {
       <B><FONT color="#000080">return</FONT></B>(false);
     }
   }
   <B><FONT color="#000080">return</FONT></B>(true);
 }
 
 <B><FONT color="#000080">bool</FONT></B> GetAny(string& cs, <B><FONT color="#000080">int</FONT></B> once = false, <B><FONT color="#000080">char</FONT></B> nn = <FONT color="#800000">'"'</FONT>)
 {
     <B><FONT color="#000080">if</FONT></B>(bufnow == NULL)
     {
       <B><FONT color="#000080">return</FONT></B>(false);
     }

     bufnow-&gt;ResetLinePos((*pidat-&gt;pIN()));
<I><FONT color="#008080">//     pidat-&gt;DebugTrace("Entered Parser::Getany"); </FONT></I>

     cs = <FONT color="#800000">" .."</FONT>;

     <B><FONT color="#000080">if</FONT></B>(bufnow-&gt;ToAny(nn) == false)
     {
<I><FONT color="#008080">//         pidat-&gt;DebugTrace(" Parser::Getany toAny ret == false"); </FONT></I>
         <B><FONT color="#000080">if</FONT></B>(bufnow-&gt;GetAny(cs) == false)
         {
             *pidat-&gt;pIN() = bufnow-&gt;LinePos(); 
             <B><FONT color="#000080">return</FONT></B>(false);
         }
         <B><FONT color="#000080">else</FONT></B>
         {
             *pidat-&gt;pIN() = bufnow-&gt;LinePos(); 
             <B><FONT color="#000080">return</FONT></B>(true);
         }
     }
     <B><FONT color="#000080">else</FONT></B>
     {
<I><FONT color="#008080">//        pidat-&gt;DebugTrace(" Parser::Getany toAny ret == true"); </FONT></I>
        bufnow-&gt;GetAny(cs);
        *pidat-&gt;pIN() = bufnow-&gt;LinePos();
     }
   <B><FONT color="#000080">return</FONT></B>(true);
 }

 <B><FONT color="#000080">char</FONT></B> GetChar(<B><FONT color="#000080">void</FONT></B>)
 {
   <B><FONT color="#000080">return</FONT></B>(bufnow-&gt;GetChar());
 }

 <B><FONT color="#000080">void</FONT></B> Advance(<B><FONT color="#000080">void</FONT></B>)
 {
    bufnow-&gt;Advance();
    *pidat-&gt;pIN() = bufnow-&gt;LinePos();
 }
 
 <B><FONT color="#000080">bool</FONT></B> NewLine(<B><FONT color="#000080">bool</FONT></B> once)
 {
     <B><FONT color="#000080">if</FONT></B>(bufnow == NULL)
     {
         <B><FONT color="#000080">return</FONT></B>(false);
     }
     
     <B><FONT color="#000080">if</FONT></B>(bufnow-&gt;NextLine() == false)
     {
<I><FONT color="#008080">//         pidat-&gt;DebugTrace("false from Nextline");</FONT></I>
         <B><FONT color="#000080">if</FONT></B>(once == false)
         {
             PopBuf();
             <B><FONT color="#000080">if</FONT></B>(bufnow == NULL)
             {
                 <B><FONT color="#000080">if</FONT></B>(usestdout)
                 {
<B><FONT color="#000080">#ifdef</FONT></B> USING_WINDOWS
                     cinput = GetStdHandle(STD_INPUT_HANDLE);
                     GetConsoleScreenBufferInfo(cinput, &sbi);
                     <B><FONT color="#000080">if</FONT></B>(sbi.dwCursorPosition.X != outx)
                     {
                         Prompt();
                     }
<B><FONT color="#000080">#endif</FONT></B>
                 }
                 <B><FONT color="#000080">return</FONT></B>(false);
             }
         }
         <B><FONT color="#000080">else</FONT></B>
         { 
             PopBuf();
             *pidat-&gt;pIN() = bufnow-&gt;LinePos();
             <B><FONT color="#000080">return</FONT></B>(false);
         }      
     }
     *pidat-&gt;pIN() = bufnow-&gt;LinePos();
     <B><FONT color="#000080">return</FONT></B>(true);
 }

 <B><FONT color="#000080">void</FONT></B> PushBuf(<B><FONT color="#000080">char</FONT></B> * buf)
 {
   <B><FONT color="#000080">if</FONT></B>(bufnow != NULL)
   {
      buffstack.push(bufnow);
   }
   bufnow = <B><FONT color="#000080">new</FONT></B> ParserData(buf, pidat);
   *pidat-&gt;pIN() = bufnow-&gt;LinePos();
 }

 <B><FONT color="#000080">void</FONT></B> PopBuf(<B><FONT color="#000080">void</FONT></B>)
 {
   <B><FONT color="#000080">if</FONT></B>(bufnow != NULL)
   {    
      <B><FONT color="#000080">delete</FONT></B> bufnow;
      bufnow = NULL;
   }   
   <B><FONT color="#000080">if</FONT></B>(buffstack.empty() == false)
   {
      bufnow = buffstack.top();
      buffstack.pop();
      *pidat-&gt;pIN() = bufnow-&gt;LinePos();
   }
 }

 <B><FONT color="#000080">char</FONT></B> * Lastline()
 {
   <B><FONT color="#000080">if</FONT></B>(bufnow)
   {
     <B><FONT color="#000080">return</FONT></B>(bufnow-&gt;Takeline());
   }
   <B><FONT color="#000080">return</FONT></B>(NULL);
 }
};



<I><FONT color="#008080">// top level class</FONT></I>

<B><FONT color="#000080">class</FONT></B> Language
{
  InterpreterData idat;
  Primitives aprim;

<B><FONT color="#000080">public</FONT></B>:
  Language()
  {
      idat.SetUpPrimitives(&aprim);
      idat.NewOutputFile(<FONT color="#800000">".\\InterpOut.txt"</FONT>);
<I><FONT color="#008080">// Start forth words -----------------------------</FONT></I>

<I><FONT color="#008080">// defining words</FONT></I>
      SimpleWord(aprim.L_colon, <FONT color="#800000">":"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_semicolon, <FONT color="#800000">";"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_constant, <FONT color="#800000">"constant"</FONT>, idat, 0l);
      SimpleWord(aprim.L_variable, <FONT color="#800000">"variable"</FONT>, idat, 0l);
      SimpleWord(aprim.L_create, <FONT color="#800000">"create"</FONT>, idat, 0l);
      SimpleWord(aprim.L_endcreate, <FONT color="#800000">";create"</FONT>, idat, 0l);
      SimpleWord(aprim.L_allot, <FONT color="#800000">"allot"</FONT>, idat, 0l);
      SimpleWord(aprim.L_rundoes, <FONT color="#800000">"rundoes&gt;"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_does, <FONT color="#800000">"does&gt;"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_postpone, <FONT color="#800000">"postpone"</FONT>, idat, idat.ExecuteCompile);

<I><FONT color="#008080">// comment words</FONT></I>
      SimpleWord(aprim.L_Comment, <FONT color="#800000">"("</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_CppComment, <FONT color="#800000">"//"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_ForthComment, <FONT color="#800000">"\\", idat, idat.ExecuteCompile);</FONT>
<I><FONT color="#008080">// output words</FONT></I>
      SimpleWord(aprim.L_quote, <FONT color="#800000">"\""</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_dotquote, <FONT color="#800000">".\""</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_dot, <FONT color="#800000">"."</FONT>, idat, 0l);
      SimpleWord(aprim.L_udot, <FONT color="#800000">"u."</FONT>, idat, 0l);
      SimpleWord(aprim.L_emit, <FONT color="#800000">"emit"</FONT>, idat, 0l);
      SimpleWord(aprim.L_nop, <FONT color="#800000">"nop"</FONT>, idat, 0l);
      SimpleWord(aprim.L_CR, <FONT color="#800000">"cr"</FONT>, idat, 0l);
      SimpleWord(aprim.L_printstring, <FONT color="#800000">"printstring"</FONT>, idat, 0l);
      SimpleWord(aprim.L_type, <FONT color="#800000">"type"</FONT>, idat, 0l);
      SimpleWord(aprim.L_count, <FONT color="#800000">"count"</FONT>, idat, 0l);
      SimpleWord(aprim.L_word, <FONT color="#800000">"word"</FONT>, idat, 0l);

<I><FONT color="#008080">// control words</FONT></I>
      SimpleWord(aprim.L_runif, <FONT color="#800000">"runif"</FONT>, idat, 0l);
      SimpleWord(aprim.L_if, <FONT color="#800000">"if"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_runelse, <FONT color="#800000">"runelse"</FONT>, idat, 0l);
      SimpleWord(aprim.L_else, <FONT color="#800000">"else"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_runthen, <FONT color="#800000">"runthen"</FONT>, idat, 0l);
      SimpleWord(aprim.L_then, <FONT color="#800000">"then"</FONT>, idat, idat.ExecuteCompile);

      SimpleWord(aprim.L_runbegin, <FONT color="#800000">"runbegin"</FONT>, idat, 0l);
      SimpleWord(aprim.L_begin, <FONT color="#800000">"begin"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_rununtil, <FONT color="#800000">"rununtil"</FONT>, idat, 0l);
      SimpleWord(aprim.L_until, <FONT color="#800000">"until"</FONT>, idat, idat.ExecuteCompile);

      SimpleWord(aprim.L_rundo, <FONT color="#800000">"rundo"</FONT>, idat, 0l);
      SimpleWord(aprim.L_do, <FONT color="#800000">"do"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_runloop, <FONT color="#800000">"runloop"</FONT>, idat, 0l);
      SimpleWord(aprim.L_loop, <FONT color="#800000">"loop"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_runiinloop, <FONT color="#800000">"runi"</FONT>, idat, 0l);
      SimpleWord(aprim.L_iinloop, <FONT color="#800000">"i"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_runjinloop, <FONT color="#800000">"runj"</FONT>, idat, 0l);
      SimpleWord(aprim.L_jinloop, <FONT color="#800000">"j"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_runleave, <FONT color="#800000">"runleave"</FONT>, idat, 0l);
      SimpleWord(aprim.L_leave, <FONT color="#800000">"leave"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_runplusloop, <FONT color="#800000">"+runloop"</FONT>, idat, 0l);
      SimpleWord(aprim.L_plusloop, <FONT color="#800000">"+loop"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_runquestiondo, <FONT color="#800000">"?rundo"</FONT>, idat, 0l);
      SimpleWord(aprim.L_questiondo, <FONT color="#800000">"?do"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_rununloop, <FONT color="#800000">"rununloop"</FONT>, idat, 0l);
      SimpleWord(aprim.L_unloop, <FONT color="#800000">"unloop"</FONT>, idat, idat.ExecuteCompile);

      SimpleWord(aprim.L_runwhile, <FONT color="#800000">"runwhile"</FONT>, idat,  0l);
      SimpleWord(aprim.L_while, <FONT color="#800000">"while"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_runrepeat, <FONT color="#800000">"runrepeat"</FONT>, idat, 0l);
      SimpleWord(aprim.L_repeat, <FONT color="#800000">"repeat"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_runagain, <FONT color="#800000">"runagain"</FONT>, idat, 0l);
      SimpleWord(aprim.L_again, <FONT color="#800000">"again"</FONT>, idat, idat.ExecuteCompile);

      SimpleWord(aprim.L_runcase, <FONT color="#800000">"runcase"</FONT>, idat, 0l);
      SimpleWord(aprim.L_case, <FONT color="#800000">"case"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_runof, <FONT color="#800000">"runof"</FONT>, idat, 0l);
      SimpleWord(aprim.L_of, <FONT color="#800000">"of"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_runendof, <FONT color="#800000">"runendof"</FONT>, idat,  0l);
      SimpleWord(aprim.L_endof, <FONT color="#800000">"endof"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_runendcase, <FONT color="#800000">"runendcase"</FONT>, idat, 0l);
      SimpleWord(aprim.L_endcase, <FONT color="#800000">"endcase"</FONT>, idat, idat.ExecuteCompile);
      
      SimpleWord(aprim.L_runexit, <FONT color="#800000">"runexit"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_exit, <FONT color="#800000">"exit"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_recurse, <FONT color="#800000">"recurse"</FONT>, idat, 0l);

      SimpleWord(aprim.L_quit, <FONT color="#800000">"quit"</FONT>, idat, 0l);

<I><FONT color="#008080">// stack words</FONT></I>
      SimpleWord(aprim.L_stackdepth, <FONT color="#800000">"depth"</FONT>, idat, 0l);
      SimpleWord(aprim.L_drop, <FONT color="#800000">"drop"</FONT>, idat, 0l);
      SimpleWord(aprim.L_over, <FONT color="#800000">"over"</FONT>, idat, 0l);
      SimpleWord(aprim.L_swap, <FONT color="#800000">"swap"</FONT>, idat, 0l);
      SimpleWord(aprim.L_dup, <FONT color="#800000">"dup"</FONT>, idat, 0l);
      SimpleWord(aprim.L_questiondup, <FONT color="#800000">"?dup"</FONT>, idat, 0l);
      SimpleWord(aprim.L_rot, <FONT color="#800000">"rot"</FONT>, idat, 0l);
      SimpleWord(aprim.L_rpush, <FONT color="#800000">"&gt;r"</FONT>, idat, 0l);
      SimpleWord(aprim.L_rpop, <FONT color="#800000">"r&gt;"</FONT>, idat, 0l);
      SimpleWord(aprim.L_rfetch, <FONT color="#800000">"r@"</FONT>, idat, 0l);
      SimpleWord(aprim.L_nip, <FONT color="#800000">"nip"</FONT>, idat, 0l);
      SimpleWord(aprim.L_pick, <FONT color="#800000">"pick"</FONT>, idat, 0l);
      SimpleWord(aprim.L_tuck, <FONT color="#800000">"tuck"</FONT>, idat, 0l);
      SimpleWord(aprim.L_roll, <FONT color="#800000">"roll"</FONT>, idat, 0l);
      SimpleWord(aprim.L_reverserot, <FONT color="#800000">"-rot"</FONT>, idat, 0l);


      SimpleWord(aprim.L_twodup, <FONT color="#800000">"2dup"</FONT>, idat, 0l);
      SimpleWord(aprim.L_twodrop, <FONT color="#800000">"2drop"</FONT>, idat, 0l);
      SimpleWord(aprim.L_twoswap, <FONT color="#800000">"2swap"</FONT>, idat, 0l);
      SimpleWord(aprim.L_twoover, <FONT color="#800000">"2over"</FONT>, idat, 0l);

      SimpleWord(aprim.L_auxpop, <FONT color="#800000">"aux&gt;"</FONT>, idat, 0l);
      SimpleWord(aprim.L_auxpush, <FONT color="#800000">"&gt;aux"</FONT>, idat, 0l);
      SimpleWord(aprim.L_auxswap, <FONT color="#800000">"auxswap"</FONT>, idat, 0l);
      SimpleWord(aprim.L_auxover, <FONT color="#800000">"auxover"</FONT>, idat, 0l);
      SimpleWord(aprim.L_auxdrop, <FONT color="#800000">"auxdrop"</FONT>, idat, 0l);
      SimpleWord(aprim.L_auxrot, <FONT color="#800000">"auxrot"</FONT>, idat, 0l);
      SimpleWord(aprim.L_auxreverserot, <FONT color="#800000">"-auxrot"</FONT>, idat, 0l);
      SimpleWord(aprim.L_auxfetch, <FONT color="#800000">"aux@"</FONT>, idat, 0l);
      SimpleWord(aprim.L_auxnip, <FONT color="#800000">"auxnip"</FONT>, idat, 0l);
      SimpleWord(aprim.L_auxpick, <FONT color="#800000">"auxpick"</FONT>, idat, 0l);
      SimpleWord(aprim.L_auxtuck, <FONT color="#800000">"auxtuck"</FONT>, idat, 0l);
      SimpleWord(aprim.L_auxroll, <FONT color="#800000">"auxroll"</FONT>, idat, 0l);
      SimpleWord(aprim.L_auxtwodup, <FONT color="#800000">"aux2dup"</FONT>, idat, 0l);
      SimpleWord(aprim.L_auxtwodrop, <FONT color="#800000">"aux2drop"</FONT>, idat, 0l);

<I><FONT color="#008080">// address words</FONT></I>
      SimpleWord(aprim.L_fetch, <FONT color="#800000">"@"</FONT>, idat, 0l);
      SimpleWord(aprim.L_store, <FONT color="#800000">"!"</FONT>, idat, 0l);
      SimpleWord(aprim.L_cstore, <FONT color="#800000">"c!"</FONT>, idat, 0l);
      SimpleWord(aprim.L_cfetch, <FONT color="#800000">"c@"</FONT>, idat, 0l);
      SimpleWord(aprim.L_wstore, <FONT color="#800000">"w!"</FONT>, idat, 0l);
      SimpleWord(aprim.L_wfetch, <FONT color="#800000">"w@"</FONT>, idat, 0l);
      SimpleWord(aprim.L_plusstore, <FONT color="#800000">"+!"</FONT>, idat, 0l);
      SimpleWord(aprim.L_twostore, <FONT color="#800000">"2!"</FONT>, idat, 0l);
      SimpleWord(aprim.L_twofetch, <FONT color="#800000">"2@"</FONT>, idat, 0l);

<I><FONT color="#008080">// arithmatic words</FONT></I>
      SimpleWord(aprim.L_plus, <FONT color="#800000">"+"</FONT>, idat, 0l);
      SimpleWord(aprim.L_minus, <FONT color="#800000">"-"</FONT>, idat, 0l);
      SimpleWord(aprim.L_multiply, <FONT color="#800000">"*"</FONT>, idat, 0l);
      SimpleWord(aprim.L_starslash, <FONT color="#800000">"*/"</FONT>, idat, 0l);
      SimpleWord(aprim.L_starslashmod, <FONT color="#800000">"*/mod"</FONT>, idat, 0l);
      SimpleWord(aprim.L_divide, <FONT color="#800000">"/"</FONT>, idat, 0l);
      SimpleWord(aprim.L_oneplus, <FONT color="#800000">"1+"</FONT>, idat, 0l);
      SimpleWord(aprim.L_oneminus, <FONT color="#800000">"1-"</FONT>, idat, 0l);
      SimpleWord(aprim.L_twotimes, <FONT color="#800000">"2*"</FONT>, idat, 0l);
      SimpleWord(aprim.L_twoplus, <FONT color="#800000">"2+"</FONT>, idat, 0l);
      SimpleWord(aprim.L_twominus, <FONT color="#800000">"2-"</FONT>, idat, 0l);
      SimpleWord(aprim.L_twoslash, <FONT color="#800000">"2/"</FONT>, idat, 0l);
      SimpleWord(aprim.L_abs, <FONT color="#800000">"abs"</FONT>, idat, 0l);
      SimpleWord(aprim.L_and, <FONT color="#800000">"and"</FONT>, idat, 0l);
      SimpleWord(aprim.L_not, <FONT color="#800000">"not"</FONT>, idat, 0l);
      SimpleWord(aprim.L_or, <FONT color="#800000">"or"</FONT>, idat, 0l);
      SimpleWord(aprim.L_xor, <FONT color="#800000">"xor"</FONT>, idat, 0l);
      SimpleWord(aprim.L_rshift, <FONT color="#800000">"rshift"</FONT>, idat, 0l);
      SimpleWord(aprim.L_lshift, <FONT color="#800000">"lshift"</FONT>, idat, 0l);
      SimpleWord(aprim.L_invert, <FONT color="#800000">"invert"</FONT>, idat, 0l);
      SimpleWord(aprim.L_base, <FONT color="#800000">"base"</FONT>, idat, 0l);
      SimpleWord(aprim.L_hex, <FONT color="#800000">"hex"</FONT>, idat, 0l);
      SimpleWord(aprim.L_decimal, <FONT color="#800000">"decimal"</FONT>, idat, 0l);
      SimpleWord(aprim.L_octal, <FONT color="#800000">"octal"</FONT>, idat, 0l);

      SimpleWord(aprim.L_fmslashmod, <FONT color="#800000">"fm/mod"</FONT>, idat, 0l);
      SimpleWord(aprim.L_smslashrem, <FONT color="#800000">"sm/rem"</FONT>, idat, 0l);
      SimpleWord(aprim.L_sTod, <FONT color="#800000">"s&gt;d"</FONT>, idat, 0l);
      SimpleWord(aprim.L_mtimes, <FONT color="#800000">"m*"</FONT>, idat, 0l);
      SimpleWord(aprim.L_umtimes, <FONT color="#800000">"um*"</FONT>, idat, 0l);
      SimpleWord(aprim.L_umslashmod, <FONT color="#800000">"um/mod"</FONT>, idat, 0l);
      SimpleWord(aprim.L_slashmod, <FONT color="#800000">"/mod"</FONT>, idat, 0l);
      SimpleWord(aprim.L_mod, <FONT color="#800000">"mod"</FONT>, idat, 0l);
      SimpleWord(aprim.L_greaternumber, <FONT color="#800000">"&gt;number"</FONT>, idat, 0l);

      SimpleWord(aprim.L_dplus, <FONT color="#800000">"d+"</FONT>, idat, 0l);
      SimpleWord(aprim.L_dnegate, <FONT color="#800000">"dnegate"</FONT>, idat, 0l);
      SimpleWord(aprim.L_dzeroless, <FONT color="#800000">"d0&lt;"</FONT>, idat, 0l);
      SimpleWord(aprim.L_dminus, <FONT color="#800000">"d-"</FONT>, idat, 0l);
      SimpleWord(aprim.L_dzeroequal, <FONT color="#800000">"d0="</FONT>, idat, 0l);
      SimpleWord(aprim.L_dtwostar, <FONT color="#800000">"d2*"</FONT>, idat, 0l);
      SimpleWord(aprim.L_dtwoslash, <FONT color="#800000">"d2/"</FONT>, idat, 0l);
      SimpleWord(aprim.L_dmax, <FONT color="#800000">"dmax"</FONT>, idat, 0l);
      SimpleWord(aprim.L_dmin, <FONT color="#800000">"dmin"</FONT>, idat, 0l);

      SimpleWord(aprim.L_max, <FONT color="#800000">"max"</FONT>, idat, 0l);
      SimpleWord(aprim.L_min, <FONT color="#800000">"min"</FONT>, idat, 0l);
      SimpleWord(aprim.L_negate, <FONT color="#800000">"negate"</FONT>, idat, 0l);

      SimpleWord(aprim.L_hold, <FONT color="#800000">"hold"</FONT>, idat, 0l);
      SimpleWord(aprim.L_sign, <FONT color="#800000">"sign"</FONT>, idat, 0l);
      SimpleWord(aprim.L_pounds, <FONT color="#800000">"#s"</FONT>, idat, 0l);
      SimpleWord(aprim.L_pound, <FONT color="#800000">"#"</FONT>, idat, 0l);
      SimpleWord(aprim.L_lesspound, <FONT color="#800000">"&lt;#"</FONT>, idat, 0l);
      SimpleWord(aprim.L_poundgreater, <FONT color="#800000">"#&gt;"</FONT>, idat, 0l);

<I><FONT color="#008080">// test words</FONT></I>
      SimpleWord(aprim.L_lessthan, <FONT color="#800000">"&lt;"</FONT>, idat, 0l);
      SimpleWord(aprim.L_ulessthan, <FONT color="#800000">"u&lt;"</FONT>, idat, 0l);
      SimpleWord(aprim.L_notequal, <FONT color="#800000">"&lt;&gt;"</FONT>, idat, 0l);
      SimpleWord(aprim.L_equal, <FONT color="#800000">"=="</FONT>, idat, 0l);
      SimpleWord(aprim.L_equal, <FONT color="#800000">"="</FONT>, idat, 0l);           <I><FONT color="#008080">// note definition of ==</FONT></I>
      SimpleWord(aprim.L_greaterthan, <FONT color="#800000">"&gt;"</FONT>, idat, 0l);
      SimpleWord(aprim.L_zeroless, <FONT color="#800000">"0&lt;"</FONT>, idat, 0l);
      SimpleWord(aprim.L_zeroequal, <FONT color="#800000">"0="</FONT>, idat, 0l);
      SimpleWord(aprim.L_zerogreater, <FONT color="#800000">"0&gt;"</FONT>, idat, 0l);
      SimpleWord(aprim.L_zeronot, <FONT color="#800000">"0&lt;&gt;"</FONT>, idat, 0l);
      SimpleWord(aprim.L_greaterthanequal, <FONT color="#800000">"&gt;="</FONT>, idat, 0l);
      SimpleWord(aprim.L_lessthanequal, <FONT color="#800000">"&lt;="</FONT>, idat, 0l);
      SimpleWord(aprim.L_within, <FONT color="#800000">"within"</FONT>, idat, 0l);

<I><FONT color="#008080">// varius string memory and array words</FONT></I>
      SimpleWord(aprim.L_stringcopy, <FONT color="#800000">"str="</FONT>, idat, 0l);
      SimpleWord(aprim.L_stringplus, <FONT color="#800000">"str+"</FONT>, idat, 0l);
      SimpleWord(aprim.L_stringequal, <FONT color="#800000">"str=="</FONT>, idat, 0l);
      SimpleWord(aprim.L_substring, <FONT color="#800000">"substr"</FONT>, idat, 0l);
      SimpleWord(aprim.L_stringvariable, <FONT color="#800000">"string"</FONT>, idat, 0l);
      SimpleWord(aprim.L_stringtocstr, <FONT color="#800000">"str&gt;cstr"</FONT>, idat, 0l);
      SimpleWord(aprim.L_cstrtostring, <FONT color="#800000">"cstr&gt;str"</FONT>, idat, 0l);
      SimpleWord(aprim.L_chararray, <FONT color="#800000">"char[]:"</FONT>, idat, 0l);
      SimpleWord(aprim.L_chararraylen, <FONT color="#800000">"char[]_len"</FONT>, idat, 0l);
      SimpleWord(aprim.L_deletechararray, <FONT color="#800000">"delchar[]"</FONT>, idat, 0l);
      SimpleWord(aprim.L_strcpy, <FONT color="#800000">"strcpy"</FONT>, idat, 0l);
      SimpleWord(aprim.L_strncpy, <FONT color="#800000">"strncpy"</FONT>, idat, 0l);
      SimpleWord(aprim.L_memcpy, <FONT color="#800000">"memcpy"</FONT>, idat, 0l);
      SimpleWord(aprim.L_memset, <FONT color="#800000">"memset"</FONT>, idat, 0l);
      SimpleWord(aprim.L_memsize, <FONT color="#800000">"msize"</FONT>, idat, 0l);
      SimpleWord(aprim.L_bl, <FONT color="#800000">"bl"</FONT>, idat, 0l);
      SimpleWord(aprim.L_squote, <FONT color="#800000">"s\""</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_cquote, <FONT color="#800000">"c\""</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_source, <FONT color="#800000">"source"</FONT>, idat, 0l);
      SimpleWord(aprim.L_space, <FONT color="#800000">"space"</FONT>, idat, 0l);
      SimpleWord(aprim.L_spaces, <FONT color="#800000">"spaces"</FONT>, idat, 0l);
      SimpleWord(aprim.L_greaterin, <FONT color="#800000">"&gt;in"</FONT>, idat, 0l);
      SimpleWord(aprim.L_fill, <FONT color="#800000">"fill"</FONT>, idat, 0l);
      SimpleWord(aprim.L_move, <FONT color="#800000">"move"</FONT>, idat, 0l);

<I><FONT color="#008080">// debug words</FONT></I>
      SimpleWord(aprim.L_traceon, <FONT color="#800000">"traceon"</FONT>, idat, 0l);
      SimpleWord(aprim.L_traceoff, <FONT color="#800000">"traceoff"</FONT>, idat, 0l);
      SimpleWord(aprim.L_addtrace, <FONT color="#800000">"addtrace"</FONT>, idat, 0l);
      SimpleWord(aprim.L_dot_s, <FONT color="#800000">".s"</FONT>, idat, 0l);

<I><FONT color="#008080">// structure words</FONT></I>
      SimpleWord(aprim.L_structure, <FONT color="#800000">"structure:"</FONT>, idat, 0l);
      SimpleWord(aprim.L_createinstance, <FONT color="#800000">"new-structure"</FONT>, idat, 0l);
      SimpleWord(aprim.L_Nchar, <FONT color="#800000">"+char"</FONT>, idat, 0l);
      SimpleWord(aprim.L_Nshort, <FONT color="#800000">"+short"</FONT>, idat, 0l);
      SimpleWord(aprim.L_Nlong, <FONT color="#800000">"+long"</FONT>, idat, 0l);
      SimpleWord(aprim.L_Narraylong, <FONT color="#800000">"+long[]"</FONT>, idat, 0l);
      SimpleWord(aprim.L_Narrayshort, <FONT color="#800000">"+short[]"</FONT>, idat, 0l);
      SimpleWord(aprim.L_Narrayobjects, <FONT color="#800000">"+object[]"</FONT>, idat, 0l);
      SimpleWord(aprim.L_endstructure, <FONT color="#800000">"structure;"</FONT>, idat, 0l);
<I><FONT color="#008080">// end structure words</FONT></I>

<I><FONT color="#008080">// system words</FONT></I>
      SimpleWord(aprim.L_ReadEntireFile, <FONT color="#800000">"ReadEntireFile"</FONT>, idat, 0l);
      SimpleWord(aprim.L_include, <FONT color="#800000">"include"</FONT>, idat, 0l);
      SimpleWord(aprim.L_timeanddate, <FONT color="#800000">"time&date"</FONT>, idat, 0l);
      SimpleWord(aprim.L_find, <FONT color="#800000">"find"</FONT>, idat, 0l);

<I><FONT color="#008080">// vocabulary and compile control words</FONT></I>
      SimpleWord(aprim.L_tic, <FONT color="#800000">"'"</FONT>, idat, 0l);
      SimpleWord(aprim.L_execute, <FONT color="#800000">"execute"</FONT>, idat, 0l);
      SimpleWord(aprim.L_decompile, <FONT color="#800000">"decompile"</FONT>, idat, 0l);

      SimpleWord(aprim.L_immediate, <FONT color="#800000">"immediate"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_forth, <FONT color="#800000">"forth"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_vocabulary, <FONT color="#800000">"vocabulary"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_definitions, <FONT color="#800000">"definitions"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_literal, <FONT color="#800000">"literal"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_vocquery, <FONT color="#800000">"is-in-voc"</FONT>, idat, 0l);

      SimpleWord(aprim.L_leftbracket, <FONT color="#800000">"["</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_rightbracket, <FONT color="#800000">"]"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_bracketticbracket, <FONT color="#800000">"[']"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_release, <FONT color="#800000">"release"</FONT>, idat, 0l);

      SimpleWord(aprim.L_cell, <FONT color="#800000">"cell"</FONT>, idat, 0l);
      SimpleWord(aprim.L_cellplus, <FONT color="#800000">"cell+"</FONT>, idat, 0l);
      SimpleWord(aprim.L_cells, <FONT color="#800000">"cells"</FONT>, idat, 0l);
      SimpleWord(aprim.L_chars, <FONT color="#800000">"chars"</FONT>, idat, 0l);
      SimpleWord(aprim.L_charplus, <FONT color="#800000">"char+"</FONT>, idat, 0l);

      SimpleWord(aprim.L_true, <FONT color="#800000">"true"</FONT>, idat, 0l);
      SimpleWord(aprim.L_false, <FONT color="#800000">"false"</FONT>, idat, 0l);

<I><FONT color="#008080">// floating point support</FONT></I>

      SimpleWord(aprim.L_ftimes, <FONT color="#800000">"f*"</FONT>, idat, 0l);
      SimpleWord(aprim.L_fplus, <FONT color="#800000">"f+"</FONT>, idat, 0l);
      SimpleWord(aprim.L_fminus, <FONT color="#800000">"f-"</FONT>, idat, 0l);
      SimpleWord(aprim.L_fdivide, <FONT color="#800000">"f/"</FONT>, idat, 0l);
      SimpleWord(aprim.L_dtof, <FONT color="#800000">"d&gt;f"</FONT>, idat, 0l);
      SimpleWord(aprim.L_ftod, <FONT color="#800000">"f&gt;d"</FONT>, idat, 0l);
      SimpleWord(aprim.L_fzeroless, <FONT color="#800000">"f0&lt;"</FONT>, idat, 0l);
      SimpleWord(aprim.L_fzeroequal, <FONT color="#800000">"f0="</FONT>, idat, 0l);
      SimpleWord(aprim.L_fless, <FONT color="#800000">"f&lt;"</FONT>, idat, 0l);
      SimpleWord(aprim.L_flessequal, <FONT color="#800000">"f&lt;="</FONT>, idat, 0l);
      SimpleWord(aprim.L_fgreater, <FONT color="#800000">"f&gt;"</FONT>, idat, 0l);
      SimpleWord(aprim.L_fgreaterequal, <FONT color="#800000">"f&gt;="</FONT>, idat, 0l);
      SimpleWord(aprim.L_fdrop, <FONT color="#800000">"fdrop"</FONT>, idat, 0l);
      SimpleWord(aprim.L_fdup, <FONT color="#800000">"fdup"</FONT>, idat, 0l);
      SimpleWord(aprim.L_fnip, <FONT color="#800000">"fnip"</FONT>, idat, 0l);
      SimpleWord(aprim.L_froll, <FONT color="#800000">"froll"</FONT>, idat, 0l);
      SimpleWord(aprim.L_fpick, <FONT color="#800000">"fpick"</FONT>, idat, 0l);
      SimpleWord(aprim.L_fover, <FONT color="#800000">"fover"</FONT>, idat, 0l);
      SimpleWord(aprim.L_frot, <FONT color="#800000">"frot"</FONT>, idat, 0l);
      SimpleWord(aprim.L_freverserot, <FONT color="#800000">"-frot"</FONT>, idat, 0l);
      SimpleWord(aprim.L_ftuck, <FONT color="#800000">"ftuck"</FONT>, idat, 0l);
      SimpleWord(aprim.L_fpower, <FONT color="#800000">"f**"</FONT>, idat, 0l);
      SimpleWord(aprim.L_fabs, <FONT color="#800000">"fabs"</FONT>, idat, 0l);
      SimpleWord(aprim.L_facos, <FONT color="#800000">"facos"</FONT>, idat, 0l);
      SimpleWord(aprim.L_fcosh, <FONT color="#800000">"fcosh"</FONT>, idat, 0l);
      SimpleWord(aprim.L_fcos, <FONT color="#800000">"fcos"</FONT>, idat, 0l);
      SimpleWord(aprim.L_fasin, <FONT color="#800000">"fasin"</FONT>, idat, 0l);
      SimpleWord(aprim.L_fsin, <FONT color="#800000">"fsin"</FONT>, idat, 0l);
      SimpleWord(aprim.L_fsincos, <FONT color="#800000">"fsincos"</FONT>, idat, 0l);
      SimpleWord(aprim.L_fsinh, <FONT color="#800000">"fsinh"</FONT>, idat, 0l);
      SimpleWord(aprim.L_fatan, <FONT color="#800000">"fatan"</FONT>, idat, 0l);
      SimpleWord(aprim.L_ftan, <FONT color="#800000">"ftan"</FONT>, idat, 0l);
      SimpleWord(aprim.L_ftanh, <FONT color="#800000">"ftanh"</FONT>, idat, 0l);
      SimpleWord(aprim.L_fatan2, <FONT color="#800000">"fatan2"</FONT>, idat, 0l);
      SimpleWord(aprim.L_fexp, <FONT color="#800000">"fexp"</FONT>, idat, 0l);
      SimpleWord(aprim.L_fln, <FONT color="#800000">"fln"</FONT>, idat, 0l);
      SimpleWord(aprim.L_flog, <FONT color="#800000">"flog"</FONT>, idat, 0l);
      SimpleWord(aprim.L_sqrt, <FONT color="#800000">"fsqrt"</FONT>, idat, 0l);
      SimpleWord(aprim.L_fdot, <FONT color="#800000">"f."</FONT>, idat, 0l);
      SimpleWord(aprim.L_fmin, <FONT color="#800000">"fmin"</FONT>, idat, 0l);
      SimpleWord(aprim.L_fmax, <FONT color="#800000">"fmax"</FONT>, idat, 0l);
      SimpleWord(aprim.L_fnegate, <FONT color="#800000">"fnegate"</FONT>, idat, 0l);
<I><FONT color="#008080">// end floating point words</FONT></I>

<I><FONT color="#008080">// class defining words</FONT></I>

      SimpleWord(aprim.L_DashRightGreater, <FONT color="#800000">"-&gt;"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_DashDot, <FONT color="#800000">"-:"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_class, <FONT color="#800000">"class:"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_This, <FONT color="#800000">"this"</FONT>, idat, 0l);
      SimpleWord(aprim.L_MethodSemicolon, <FONT color="#800000">"m;"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_MethodColon, <FONT color="#800000">"m:"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_EnclosedByte, <FONT color="#800000">"[byte]"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_EnclosedBytes, <FONT color="#800000">"[bytes]"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_EnclosedWord, <FONT color="#800000">"[word]"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_EnclosedWords, <FONT color="#800000">"[words]"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_EnclosedDWord, <FONT color="#800000">"[dword]"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_EnclosedDWords, <FONT color="#800000">"[dwords]"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_EnclosedPointer, <FONT color="#800000">"[pointer]"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_EnclosedPointers, <FONT color="#800000">"[pointers]"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_EnclosedArrays, <FONT color="#800000">"[arrays]"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_EnclosedClass, <FONT color="#800000">"[class]"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_EnclosedClasses, <FONT color="#800000">"[classes]"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_endclass, <FONT color="#800000">"class;"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_publiccolon, <FONT color="#800000">"public:"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_privatecolon, <FONT color="#800000">"private:"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_protectedcolon, <FONT color="#800000">"protected:"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_DecompileClass, <FONT color="#800000">"(decompile)-class"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_ColonEqual, <FONT color="#800000">":="</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_NewClass, <FONT color="#800000">"new"</FONT>, idat, 0l);
      SimpleWord(aprim.L_DeleteClass, <FONT color="#800000">"delete"</FONT>, idat, 0l);
      SimpleWord(aprim.L_state, <FONT color="#800000">"state"</FONT>, idat, 0l);
       
<I><FONT color="#008080">// end class defining words</FONT></I>

      SimpleWord(aprim.L_bye, <FONT color="#800000">"bye"</FONT>, idat, 0l);

      SimpleWord(aprim.L_evaluate, <FONT color="#800000">"evaluate"</FONT>, idat, 0l);
      SimpleWord(aprim.L_bracketcharbracket, <FONT color="#800000">"[char]"</FONT>, idat, idat.ExecuteCompile);
      SimpleWord(aprim.L_char, <FONT color="#800000">"char"</FONT>, idat, 0l);

      <I><FONT color="#008080">// set up initial return stack to nop</FONT></I>
      string nnn = <FONT color="#800000">"nop"</FONT>;
      Word *ww = idat.IDict()-&gt;Address(nnn);
      RSData ar(ww);
      
      idat.PushR(ar);
  }

 Language(<B><FONT color="#000080">const</FONT></B> Language & lang)
 {
   idat = lang.idat;
   aprim = lang.aprim;
 }

 <B><FONT color="#000080">int</FONT></B> Parse(<B><FONT color="#000080">char</FONT></B> * txt);

<I><FONT color="#008080">// Function name    : SimpleWord</FONT></I>
<I><FONT color="#008080">// Description      : Adds a primitive to the language</FONT></I>
<I><FONT color="#008080">// RSData type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : PVFN p </FONT></I>
<I><FONT color="#008080">// Argument         : char * name</FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<I><FONT color="#008080">// Argument         : unsigned long flg</FONT></I>
 <B><FONT color="#000080">void</FONT></B> SimpleWord(PVFN p, <B><FONT color="#000080">char</FONT></B> * name, InterpreterData & idat, <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> flg)
 {
   string cs;
   cs = name;
   <B><FONT color="#000080">if</FONT></B>(idat.IDict()-&gt;Exists(cs) != -<FONT color="#800000">1</FONT>)
   {
     idat.ShowError(Errors::PRIMITIVE_EXISTS, cs);
     <B><FONT color="#000080">return</FONT></B>;
   }
   Word * awrd = <B><FONT color="#000080">new</FONT></B> Word();
   Element *el = <B><FONT color="#000080">new</FONT></B> Element(p);
   awrd-&gt;NewName(cs);
   awrd-&gt;AddElement(*el);
   <B><FONT color="#000080">delete</FONT></B> el;
   awrd-&gt;SetFlags(flg);
   idat.IDict()-&gt;Add(*awrd);
   <B><FONT color="#000080">delete</FONT></B> awrd;
 }

 string & Out()
 {
   <B><FONT color="#000080">return</FONT></B>(idat.Out());
 }

 <B><FONT color="#000080">void</FONT></B> SetOut(<B><FONT color="#000080">const</FONT></B> <B><FONT color="#000080">char</FONT></B> *path)
 {
   idat.NewOutputFile(path);
 }

 <B><FONT color="#000080">void</FONT></B> SetStdOut()
 {
   idat.UseStdOut();
 }

 <B><FONT color="#000080">void</FONT></B> SetStringOut()
 {
   idat.NewOutputString();
   idat.UseStringOut();
 }

 ostrstream &  GetStringOut()
 {
   <B><FONT color="#000080">return</FONT></B>(idat.GetOutputString());
 }


 <B><FONT color="#000080">void</FONT></B> Prompt(<B><FONT color="#000080">void</FONT></B>)
 {
   idat.IParser()-&gt;Prompt();
 }

<I><FONT color="#008080">// Function name    : = </FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : Language& operator </FONT></I>
<I><FONT color="#008080">// Argument         : const Language & lang</FONT></I>
Language& <B><FONT color="#000080">operator</FONT></B> = (<B><FONT color="#000080">const</FONT></B> Language & lang)
 {
   idat = lang.idat;
   aprim = lang.aprim;
   <B><FONT color="#000080">return</FONT></B>(*<B><FONT color="#000080">this</FONT></B>);
 }

};



<B><FONT color="#000080">#endif</FONT></B> <I><FONT color="#008080">//__CODEELEMENT_H__</FONT></I>
</PRE>