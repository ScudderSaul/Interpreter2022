

<B><FONT color="#000080">#include</FONT></B> <FONT color="#800000">"stdafx.h"</FONT>
<B><FONT color="#000080">#include</FONT></B> &lt;cmath&gt;
<B><FONT color="#000080">#include</FONT></B> &lt;cfloat&gt;
<B><FONT color="#000080">#include</FONT></B> &lt;ctime&gt;
<B><FONT color="#000080">#include</FONT></B> <FONT color="#800000">"codeelement.h"</FONT>
<B><FONT color="#000080">#include</FONT></B> &lt;fcntl.h&gt;
<B><FONT color="#000080">#include</FONT></B> &lt;assert.h&gt;
<B><FONT color="#000080">#include</FONT></B> &lt;cstdlib&gt;
<B><FONT color="#000080">#include</FONT></B> &lt;cstdio&gt;


<B><FONT color="#000080">#pragma</FONT></B> warning(disable: <FONT color="#800000">4786</FONT>)

<B><FONT color="#000080">#include</FONT></B> &lt;vector&gt;

using namespace std;

<I><FONT color="#008080">// ----------------------Errors----------------------</FONT></I>


<I><FONT color="#008080">// Function name    : Errors::Errors</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// RSData type      : </FONT></I>
Errors::Errors()
{   
  errors.reserve(<FONT color="#800000">80</FONT>);
  ErrPrompt.reserve(<FONT color="#800000">120</FONT>);
  ErrPrompt = <FONT color="#800000">"\nERROR:&gt;"</FONT>;
  AddErr(NO_TRAILING_QUOTE,<FONT color="#800000">"No trailing quote "</FONT>);           <I><FONT color="#008080">// error NO_TRAILING_QUOTE</FONT></I>
  AddErr(SYNTAX_ERROR,<FONT color="#800000">"Syntax Error "</FONT>);                     <I><FONT color="#008080">// error SYNTAX_ERROR</FONT></I>
  AddErr(NO_SUCH_WORD,<FONT color="#800000">"No Such Word "</FONT>);                     <I><FONT color="#008080">// error NO_SUCH_WORD</FONT></I>
  AddErr(IS_NUMBER,<FONT color="#800000">"Trying to name a word with a number "</FONT>); <I><FONT color="#008080">// error IS_NUMBER</FONT></I>
  AddErr(WORD_EXISTS,<FONT color="#800000">"Word already exists "</FONT>);               <I><FONT color="#008080">// error WORD_EXISTS </FONT></I>
  AddErr(BUFFER_END,<FONT color="#800000">"buffer end reached "</FONT>);                 <I><FONT color="#008080">// error BUFFER_END</FONT></I>
  AddErr(STACK_UNDERFLOW,<FONT color="#800000">"Stack Underflow "</FONT>);               <I><FONT color="#008080">// error STACK_UNDERFLOW</FONT></I>
  AddErr(AUX_STACK_UNDERFLOW, <FONT color="#800000">"The auxillary (control) stack has underflowed "</FONT>);
  AddErr(ONLY_COMPILED,<FONT color="#800000">"May only be compiled in user words "</FONT>);  <I><FONT color="#008080">// error ONLY_COMPILED</FONT></I>
  AddErr(NO_BEGIN,<FONT color="#800000">"until without begin "</FONT>);                  <I><FONT color="#008080">// error NO_BEGIN</FONT></I>
  AddErr(NO_DO,<FONT color="#800000">"loop without do "</FONT>);                         <I><FONT color="#008080">// error NO_DO</FONT></I>
  AddErr(PRIMITIVE_EXISTS, <FONT color="#800000">"Primitive already exists "</FONT>);
  AddErr(RETURN_STACK_UNDERFLOW, <FONT color="#800000">"RSData Stack Underflow "</FONT>);
  AddErr(ILLEGALDEFINING, <FONT color="#800000">"Defining word: no use when in compile mode "</FONT>);
  AddErr(DIVIDEBYZERO, <FONT color="#800000">"Divide by 0 "</FONT>);
  AddErr(NO_CLOSINGPAREN, <FONT color="#800000">"No closing parenthisis "</FONT>);
  AddErr(NO_EOL, <FONT color="#800000">"End of line not found? "</FONT>);
  AddErr(BAD_STACKPOSITION, <FONT color="#800000">"End of line not found? "</FONT>);
  AddErr(BAD_POINTER, <FONT color="#800000">"Not a valid pointer for use "</FONT>);
  AddErr(NO_CREATE, <FONT color="#800000">"No created word "</FONT>);
  AddErr(STL_ERROR, <FONT color="#800000">"STL sntax error "</FONT>);
  AddErr(NO_CLASS_EXISTS, <FONT color="#800000">"No class exists for operation "</FONT>);
  AddErr(CLASS_EXISTS, <FONT color="#800000">"A class exists with the given name "</FONT>);
  AddErr(NO_MEMBER_FOUND, <FONT color="#800000">"class member does not exist "</FONT>);
  AddErr(METHOD_EXISTED, <FONT color="#800000">"The method was already defined "</FONT>);
  AddErr(COMPILING_METHOD, <FONT color="#800000">" Can't compile new method durring previous method compilation "</FONT>);
  AddErr(NOT_COMPILING_METHOD, <FONT color="#800000">" Not compiling a method when called "</FONT>);
  AddErr(MEMBER_EXISTS, <FONT color="#800000">"A class member of that name already existed "</FONT>);
  AddErr(PRIVATE_METHOD, <FONT color="#800000">"The method is private or a protected member of the class "</FONT>);
  AddErr(PRIVATE_MEMBER, <FONT color="#800000">"The class member is private or a protected member of the class "</FONT>);
  AddErr(AMBIGUIOUS_MEMBER, <FONT color="#800000">" The name given resolves to several class members "</FONT>);
  AddErr(SYSTEM_EXECPTION, <FONT color="#800000">"An exception was generated by the operating system "</FONT>);

  AddErr(UNKNOWNERROR, <FONT color="#800000">"Unknown Error"</FONT>);        <I><FONT color="#008080">// last</FONT></I>
  
  <B><FONT color="#000080">for</FONT></B>(<B><FONT color="#000080">int</FONT></B> qq = <FONT color="#800000">0</FONT>;qq &lt; <FONT color="#800000">5</FONT>;qq++)
  {
    LastError[qq].reserve(<FONT color="#800000">120</FONT>);
  }

  fatal = false;
  ErrIndex = <FONT color="#800000">0</FONT>;
}


<I><FONT color="#008080">// Function name    : Errors::~Errors</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// RSData type      : </FONT></I>
Errors::~Errors()
{

}

<I><FONT color="#008080">// Function name    : Errors::ShowError</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : int ii</FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & intpr</FONT></I>
<B><FONT color="#000080">void</FONT></B> Errors::ShowError(<B><FONT color="#000080">int</FONT></B> ii, InterpreterData & intpr, string& extra)
{
    fatal = true;
    ErrIndex++;
    <B><FONT color="#000080">if</FONT></B>(ErrIndex &gt; ERRLISTMAX)
    {
        ErrIndex = <FONT color="#800000">0</FONT>;
    }
    string ss;
    ss.reserve(<FONT color="#800000">240</FONT>);
    ss = ErrPrompt + Error(ii);
    ss += extra;
    LastError[ErrIndex] = ss;
    
    intpr.Out() += LastError[ErrIndex];
    intpr.WriteOut();
    
    <B><FONT color="#000080">if</FONT></B>(intpr.Tracing())
    {
        intpr.TraceOut(ss);
    }
    
    <B><FONT color="#000080">for</FONT></B> (<B><FONT color="#000080">int</FONT></B> kk = <FONT color="#800000">0</FONT>; kk &lt; <FONT color="#800000">5</FONT>;kk++)
    {
        intpr.DecompileN(kk);
    }
    intpr.LineOut();
}

<I><FONT color="#008080">// ------------------------Dictonary----------------------</FONT></I>


<I><FONT color="#008080">// Function name    : Dictonary::Add</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : Word & wrd</FONT></I>
<B><FONT color="#000080">void</FONT></B> Dictonary::Add(Word & wrd)
{
  words.push_back(wrd);
  vocs[current].AddWord(wrd.Name(), (words.size() - <FONT color="#800000">1</FONT>));
}


<I><FONT color="#008080">// Function name    : Dictonary::Exists</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : int </FONT></I>
<I><FONT color="#008080">// Argument         : CString& nam</FONT></I>
<B><FONT color="#000080">int</FONT></B> Dictonary::Exists(string& nam)
  {
    <B><FONT color="#000080">return</FONT></B>(Find(nam));
  }

Word* Dictonary::FindInContext(string& nam)
 {
   <B><FONT color="#000080">int</FONT></B> vn = vocs[context].Find(nam);

   <B><FONT color="#000080">if</FONT></B>(vn &gt;= <FONT color="#800000">0</FONT>)
   {
      <B><FONT color="#000080">if</FONT></B>(words[vn].Name() == nam)   <I><FONT color="#008080">// extra check</FONT></I>
      {
         <B><FONT color="#000080">return</FONT></B>(&words[vn]);
      }
   }
   <B><FONT color="#000080">return</FONT></B>(NULL);
 }

<B><FONT color="#000080">int</FONT></B> Dictonary::Find(string& nam)
 {
   <B><FONT color="#000080">int</FONT></B> vn = -<FONT color="#800000">1</FONT>;
   list&lt;<B><FONT color="#000080">int</FONT></B>&gt; ::iterator ii;    
   <B><FONT color="#000080">for</FONT></B>(ii = vocorder.begin();ii != vocorder.end();ii++)
   {
     vn = vocs[(*ii)].Find(nam);
     <B><FONT color="#000080">if</FONT></B>(vn &gt;= <FONT color="#800000">0</FONT>)
     {
       <B><FONT color="#000080">break</FONT></B>;
     }
   }
  <B><FONT color="#000080">return</FONT></B>(vn);
 }

Word* Dictonary::FindAddress(string& nam)
 {
   <B><FONT color="#000080">int</FONT></B> nn = Find(nam);
   <B><FONT color="#000080">if</FONT></B>(nn &gt;= <FONT color="#800000">0</FONT>)
   {
     <B><FONT color="#000080">if</FONT></B>(words[nn].Name() == nam)   <I><FONT color="#008080">// temp check</FONT></I>
     {
        <B><FONT color="#000080">return</FONT></B>(&words[nn]);
     }
   }
   <B><FONT color="#000080">return</FONT></B>(NULL);
 }

<B><FONT color="#000080">bool</FONT></B> Dictonary::VocNameForWord(Word * ww , string& result)
{
  string sn;
  sn.reserve(<FONT color="#800000">60</FONT>);
  sn = ww-&gt;Name();

   <B><FONT color="#000080">int</FONT></B> vn = -<FONT color="#800000">1</FONT>;
   list&lt;<B><FONT color="#000080">int</FONT></B>&gt; ::iterator ii;    
   <B><FONT color="#000080">for</FONT></B>(ii = vocorder.begin();ii != vocorder.end();ii++)
   {
     vn = vocs[(*ii)].Find(sn);
     <B><FONT color="#000080">if</FONT></B>(vn != -<FONT color="#800000">1</FONT>)
     {
       result = vocs[(*ii)].Name();
       <B><FONT color="#000080">return</FONT></B>(true);
     }
   }
  <B><FONT color="#000080">return</FONT></B>(false);  
}

<I><FONT color="#008080">// Function name    : Dictonary::Address</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : Word* </FONT></I>
<I><FONT color="#008080">// Argument         : int nn</FONT></I>
Word* Dictonary::Address(<B><FONT color="#000080">int</FONT></B> nn)
{
  <B><FONT color="#000080">return</FONT></B>(&words[nn]);
}


<I><FONT color="#008080">// Function name    : Dictonary::Address</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : Word* </FONT></I>
<I><FONT color="#008080">// Argument         : CString& nam</FONT></I>
Word* Dictonary::Address(string& nam)
{
<I><FONT color="#008080">//  int ind;</FONT></I>

    <B><FONT color="#000080">return</FONT></B>(FindAddress(nam));

<I><FONT color="#008080">//  if((ind = Exists(nam)) != -1)</FONT></I>
<I><FONT color="#008080">//  {</FONT></I>
<I><FONT color="#008080">//    return(&words[ind]);</FONT></I>
<I><FONT color="#008080">//  }</FONT></I>
<I><FONT color="#008080">//  else</FONT></I>
<I><FONT color="#008080">//  {</FONT></I>
<I><FONT color="#008080">//    return(NULL);</FONT></I>
<I><FONT color="#008080">//  }</FONT></I>
}

<I><FONT color="#008080">// Function name    : Dictonary::Address</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : Word* </FONT></I>
<I><FONT color="#008080">// Argument         : char* namw</FONT></I>
Word* Dictonary::Address(<B><FONT color="#000080">char</FONT></B>* namw)
{
  string nams;
  nams.reserve(<FONT color="#800000">60</FONT>);
  nams = namw;
  <B><FONT color="#000080">return</FONT></B>(Address(nams));
}

Word * Dictonary::MostRecent(<B><FONT color="#000080">void</FONT></B>)
{
  <B><FONT color="#000080">return</FONT></B>(&words[(words.size() - <FONT color="#800000">1</FONT>)]);
}

<I><FONT color="#008080">// Function name    : Dictonary::Execute</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : int wordindex</FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Dictonary::Execute(<B><FONT color="#000080">int</FONT></B> wordindex, InterpreterData & idat)
{
    words[wordindex].Execute(<FONT color="#800000">0</FONT>, idat);
}

<I><FONT color="#008080">// ---------------------------Language---------------------------</FONT></I>

<I><FONT color="#008080">// Function name    : Language::Parse</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : int </FONT></I>
<I><FONT color="#008080">// Argument         : char * txt</FONT></I>
<B><FONT color="#000080">int</FONT></B> Language::Parse(<B><FONT color="#000080">char</FONT></B> * txt)
{ 
    <I><FONT color="#008080">//  int errorv;</FONT></I>
    <B><FONT color="#000080">char</FONT></B> *wrd;
    string awrd;
    awrd.reserve(<FONT color="#800000">120</FONT>);
    <B><FONT color="#000080">int</FONT></B> wordindex;
    Element *anel = NULL;
    idat.ResetFatal();
    <B><FONT color="#000080">if</FONT></B>(idat.Tracing() == false)
    {
      idat.TraceOn();
    }
    idat.DebugTrace(<FONT color="#800000">"Interpreter language Parser"</FONT>); 
    
    Parser * par = idat.IParser();
    par-&gt;PushBuf(txt);
    
    <B><FONT color="#000080">while</FONT></B>((wrd = par-&gt;NextWord()) != NULL)
    {
        anel = NULL;
        awrd = wrd;

        <B><FONT color="#000080">if</FONT></B>(idat.ParseClass(awrd, par) == false)  <I><FONT color="#008080">// the word exists add the element</FONT></I>
        {
            <B><FONT color="#000080">if</FONT></B>((wordindex = idat.IDict()-&gt;Exists(awrd)) != -<FONT color="#800000">1</FONT>)
            {    
                <B><FONT color="#000080">if</FONT></B>((idat.IDict()-&gt;Address(wordindex)-&gt;FlagsMatch(idat.ExecuteCompile)))
                {
<I><FONT color="#008080">//                  idat.StartRunImmediate();                      </FONT></I>
                }         
                idat.IDict()-&gt;Execute(wordindex, idat); <I><FONT color="#008080">// element added by word itself when compiling                             </FONT></I>
                <B><FONT color="#000080">if</FONT></B>((idat.IDict()-&gt;Address(wordindex)-&gt;FlagsMatch(idat.ExecuteCompile)))
                {
<I><FONT color="#008080">//                  idat.StopRunImmediate();                      </FONT></I>
                }      
            }                
            <B><FONT color="#000080">else</FONT></B> <I><FONT color="#008080">// word does not exist so see if its a digit</FONT></I>
            {        
                <B><FONT color="#000080">if</FONT></B>(idat.ParseDigits(wrd, par) == false)
                {                    
                   idat.ShowError(Errors::NO_SUCH_WORD, awrd);  
                   <B><FONT color="#000080">break</FONT></B>;
                }
            }
        }
        <B><FONT color="#000080">if</FONT></B>(idat.Fatal())
        {
<I><FONT color="#008080">//           par-&gt;PopBuf();</FONT></I>
           <B><FONT color="#000080">break</FONT></B>;
        }
    }
    idat.DebugTrace(<FONT color="#800000">"Emptied input buffer"</FONT>);
        <B><FONT color="#000080">if</FONT></B>(idat.Fatal())
        {
           idat.DebugTrace(<FONT color="#800000">"fatal error in language, poping buffer"</FONT>); 
           par-&gt;PopBuf();
           <B><FONT color="#000080">return</FONT></B>(false);
        }    

    <B><FONT color="#000080">return</FONT></B>(true);
}

<I><FONT color="#008080">// ----------------------Element-----------------------------</FONT></I>

<B><FONT color="#000080">void</FONT></B> Element::Execute(InterpreterData & intrp, <B><FONT color="#000080">int</FONT></B> imed)
{
    Primitives *prim = intrp.ToPrimitives();

    <B><FONT color="#000080">switch</FONT></B>(type)
    {
      <B><FONT color="#000080">case</FONT></B> Primitive:         
             (prim-&gt;*fun)(intrp);
          <B><FONT color="#000080">break</FONT></B>;
      <B><FONT color="#000080">case</FONT></B> Literal:
             intrp.PushD(literal);
          <B><FONT color="#000080">break</FONT></B>;
      <B><FONT color="#000080">case</FONT></B> Definition:
             call-&gt;Execute(<FONT color="#800000">0</FONT>, intrp, imed);
           <B><FONT color="#000080">break</FONT></B>;
      <B><FONT color="#000080">case</FONT></B> LitString:
             intrp.PushD(litstring);
          <B><FONT color="#000080">break</FONT></B>;
      <B><FONT color="#000080">case</FONT></B> AddressV:
             intrp.PushD((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>) &literal);
            <B><FONT color="#000080">break</FONT></B>;
      <B><FONT color="#000080">case</FONT></B> MethodDefinition:
             method-&gt;Execute(<FONT color="#800000">0</FONT>, intrp, imed);
            <B><FONT color="#000080">break</FONT></B>;
      <B><FONT color="#000080">case</FONT></B> DataDefinition:
             data-&gt;Resolve(intrp);
            <B><FONT color="#000080">break</FONT></B>;
      <B><FONT color="#000080">default</FONT></B>:
          <B><FONT color="#000080">break</FONT></B>;
    }
}


<B><FONT color="#000080">bool</FONT></B> Element::SameWord(<B><FONT color="#000080">char</FONT></B> *nam, InterpreterData & idat)
{
  <B><FONT color="#000080">if</FONT></B>(type == Definition)
  {
    Word *ww = (idat.IDict()-&gt;Address(nam));
    <B><FONT color="#000080">if</FONT></B>(ww == call)
    {
       <B><FONT color="#000080">return</FONT></B>(true);
    }
  }

  <B><FONT color="#000080">return</FONT></B>(false);
}

 <B><FONT color="#000080">bool</FONT></B> Element::FetchDefinitionName(string & s)
 {
    <B><FONT color="#000080">if</FONT></B>(type == Definition)
    {
      Word * ww = call;
      s = ww-&gt;Name();
      <B><FONT color="#000080">return</FONT></B>(true);
    }
    <B><FONT color="#000080">else</FONT></B>
    {
        <B><FONT color="#000080">if</FONT></B>(type == MethodDefinition)
        {
           ClassMethod * md = method;
           s = md-&gt;Name();
           <B><FONT color="#000080">return</FONT></B>(true);
        }
        <B><FONT color="#000080">else</FONT></B>
        {
            <B><FONT color="#000080">if</FONT></B>(type == DataDefinition)
            {
               ClassData * pd = data;
               s = pd-&gt;Name();
               <B><FONT color="#000080">return</FONT></B>(true);
            }
        }
    }   
   <B><FONT color="#000080">return</FONT></B>(false);
 }

<I><FONT color="#008080">// -------------------Word----------------------------------</FONT></I>

 <B><FONT color="#000080">int</FONT></B> Word::Execute(<B><FONT color="#000080">int</FONT></B> index, InterpreterData & intrp, <B><FONT color="#000080">int</FONT></B> imed)
 {
     <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> fm = <FONT color="#800000">0</FONT>;
<I><FONT color="#008080">//     bool savec = false;</FONT></I>
     RSData rr(<B><FONT color="#000080">this</FONT></B>);
     rr.SetIndex(index);
     <B><FONT color="#000080">int</FONT></B> ty;
     
     <B><FONT color="#000080">if</FONT></B>(intrp.Tracing())
     {
         string ts;
         ts.reserve(<FONT color="#800000">120</FONT>);
         ts = <FONT color="#800000">" Entered word \""</FONT>;
         ts += Name();
         ts+= <FONT color="#800000">"\" "</FONT>;
         intrp.TraceOut(ts);
     }
     
     fm = FlagsMatch(intrp.ExecuteCompile);
     
     <B><FONT color="#000080">if</FONT></B>(fm)
     {
<I><FONT color="#008080">//        intrp.StartRunImmediate();</FONT></I>
     }

     <B><FONT color="#000080">if</FONT></B>((intrp.Compiling() == false) || fm || imed)
     {
   
         intrp.SetExv(rr);
         <B><FONT color="#000080">while</FONT></B>(intrp.ExvIndex() &lt; word.size())
         {
             ty = word[intrp.ExvIndex()].Type();
             <B><FONT color="#000080">if</FONT></B>(ty == Element::Definition || ty == Element::MethodDefinition)
             {
                 rr.SetIndex(intrp.ExvIndex());
                 intrp.PushR(rr);
             }
             
             try
             {
                 word[intrp.ExvIndex()].Execute(intrp, (imed | fm));
             }
             <B><FONT color="#000080">catch</FONT></B>(...)
             {
<B><FONT color="#000080">#ifdef</FONT></B> USING_WINDOWS
                 intrp.WindowsError();
<B><FONT color="#000080">#endif</FONT></B>
                 intrp.ShowError(Errors::SYSTEM_EXECPTION, Name());
                 intrp.FatalError();
             }
             
             <B><FONT color="#000080">if</FONT></B>(ty == Element::Definition  || ty == Element::MethodDefinition)
             {
                 intrp.SetExv(intrp.PopR());
                 rr = intrp.GetExv();
             }
             
             intrp.IncExv();
         }
<I><FONT color="#008080">//         if(fm)</FONT></I>
<I><FONT color="#008080">//         {</FONT></I>
<I><FONT color="#008080">//             intrp.SetCompiling(savec);</FONT></I>
<I><FONT color="#008080">//         }</FONT></I>
     }
     <B><FONT color="#000080">else</FONT></B>
     {
         
          intrp.BuildAddElement(<B><FONT color="#000080">this</FONT></B>);   
           
     }
     <B><FONT color="#000080">if</FONT></B>(fm)
     {
<I><FONT color="#008080">//        intrp.StopRunImmediate();</FONT></I>
     }
     
     <B><FONT color="#000080">if</FONT></B>(intrp.Tracing())
     {
         string ds;
         ds.reserve(<FONT color="#800000">120</FONT>);
         ds = <FONT color="#800000">" ---Exited word \""</FONT>;
         ds += Name();
         ds += <FONT color="#800000">"\" "</FONT>;
         intrp.TraceOut(ds);
     }
     
     <B><FONT color="#000080">return</FONT></B>(Ok);
 }

<B><FONT color="#000080">void</FONT></B> Word::Decompile(string& dtext, InterpreterData & intrp)
{
  dtext += <FONT color="#800000">"\nName: \""</FONT>;
  dtext += name;
  dtext += <FONT color="#800000">"\""</FONT>;
  <B><FONT color="#000080">char</FONT></B> tstr[<FONT color="#800000">50</FONT>]; 

  <B><FONT color="#000080">for</FONT></B>(<B><FONT color="#000080">int</FONT></B> ii = <FONT color="#800000">0</FONT>;ii &lt; word.size();ii++)
  {
     <B><FONT color="#000080">int</FONT></B> tt = word[ii].Type();
     sprintf(tstr,<FONT color="#800000">"\n--&gt;Element %i is "</FONT>, ii);
     dtext += tstr;
     <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> p1;
     string ss;
     ss.reserve(<FONT color="#800000">120</FONT>);
     string ns;
     ns.reserve(<FONT color="#800000">120</FONT>);

     <B><FONT color="#000080">switch</FONT></B> (tt)
     {
       <B><FONT color="#000080">case</FONT></B> Element::Primitive:
           dtext += <FONT color="#800000">" a primitive"</FONT>;
           <B><FONT color="#000080">break</FONT></B>;
       <B><FONT color="#000080">case</FONT></B> Element::Literal:
           dtext += <FONT color="#800000">" a literal == to "</FONT>;
           word[ii].FetchLiteralVal(&p1);
           sprintf(tstr,<FONT color="#800000">"%i"</FONT>, p1);
           dtext += tstr;
           <B><FONT color="#000080">break</FONT></B>;
       <B><FONT color="#000080">case</FONT></B> Element::Definition:
           dtext += <FONT color="#800000">" a call to the word "</FONT>;
           <B><FONT color="#000080">if</FONT></B>(word[ii].FetchDefinitionName(ns))
           {
             dtext += (ns);
           }
           <B><FONT color="#000080">break</FONT></B>;
       <B><FONT color="#000080">case</FONT></B> Element::LitString:
           dtext += <FONT color="#800000">" a pointer to the string literal "</FONT>; 
           word[ii].FetchLitString(ss);
           dtext += ss;
           <B><FONT color="#000080">break</FONT></B>;
       <B><FONT color="#000080">case</FONT></B> Element::AddressV:
           dtext += <FONT color="#800000">" a value set to "</FONT>;
           word[ii].FetchLiteralVal(&p1);
           sprintf(tstr,<FONT color="#800000">"%i "</FONT>, p1);
           dtext += tstr;
           <B><FONT color="#000080">break</FONT></B>;
       <B><FONT color="#000080">case</FONT></B> Element::MethodDefinition:
            dtext += <FONT color="#800000">" a call to the method "</FONT>; 
            <B><FONT color="#000080">if</FONT></B>(word[ii].FetchDefinitionName(ns))
            {
               dtext += (ns);
            }
            <B><FONT color="#000080">break</FONT></B>;
       <B><FONT color="#000080">case</FONT></B> Element::DataDefinition:
            dtext += <FONT color="#800000">" a referenve to the class data object "</FONT>; 
            <B><FONT color="#000080">if</FONT></B>(word[ii].FetchDefinitionName(ns))
            {
               dtext += (ns);
            }
            <B><FONT color="#000080">break</FONT></B>;
       <B><FONT color="#000080">default</FONT></B>:
           dtext += <FONT color="#800000">" Corrupt element of unknown type"</FONT>;
           <B><FONT color="#000080">break</FONT></B>;
     }
  }
  dtext += <FONT color="#800000">"\n --End-of-decompile----"</FONT>; 
}


<I><FONT color="#008080">// -------------------InterpreterData-----------------------</FONT></I>

InterpreterData::InterpreterData()
 {
   dictonary = <B><FONT color="#000080">new</FONT></B> Dictonary();
   usestdout = false;
   pparser = <B><FONT color="#000080">new</FONT></B> Parser(<B><FONT color="#000080">this</FONT></B>);
   cdescript = <B><FONT color="#000080">new</FONT></B> ClassDescriptions();
   <B><FONT color="#000080">if</FONT></B>(cdescript != NULL)
   {
      cdescript-&gt;SetInterpreterData(<B><FONT color="#000080">this</FONT></B>);
   }
   compiling = false;
   immediate = false;
   numericbase = <FONT color="#800000">10</FONT>;
   nbufpos = <FONT color="#800000">0</FONT>;
   nbufflg = false;
   memset(nbuffer, <FONT color="#800000">0</FONT>, <FONT color="#800000">60</FONT>);
   INloc = <FONT color="#800000">0</FONT>;
   nwordbuf = wordbuf;

   retdepth = <FONT color="#800000">0</FONT>;
   OutFile = <FONT color="#800000">" "</FONT>;
   <B><FONT color="#000080">char</FONT></B> TraceStr[<FONT color="#800000">256</FONT>];
   sprintf(TraceStr,<FONT color="#800000">".\\InterpTrace%i.txt"</FONT>,time(NULL));
   NewTraceFile(TraceStr);
   TraceOut(<FONT color="#800000">"Started "</FONT>);
   TraceOff();
   ufcnt = <FONT color="#800000">0</FONT>;
   rets.reserve(<FONT color="#800000">200</FONT>);
   dats.reserve(<FONT color="#800000">400</FONT>);
   aux.reserve(<FONT color="#800000">200</FONT>);
   tempintrp.reserve(<FONT color="#800000">300</FONT>);
   Output.reserve(<FONT color="#800000">1000</FONT>);
   OutFile.reserve(<FONT color="#800000">256</FONT>);
   NoStdOut();
   NoStringOut();
   building = NULL;
 }

InterpreterData::InterpreterData(<B><FONT color="#000080">const</FONT></B> InterpreterData& idat)
 {
   rets.reserve(<FONT color="#800000">200</FONT>);
   dats.reserve(<FONT color="#800000">400</FONT>);
   aux.reserve(<FONT color="#800000">200</FONT>);
   tempintrp.reserve(<FONT color="#800000">300</FONT>);
   Output.reserve(<FONT color="#800000">1000</FONT>);
   numericbase = idat.numericbase;
   nbufpos = idat.nbufpos;;
   nbufflg = idat.nbufflg;;
   memcpy(nbuffer, idat.nbuffer, <FONT color="#800000">60</FONT>);
   INloc = idat.INloc;
   nwordbuf = idat.nwordbuf;

   rets = idat.rets;
   dats = idat.dats;
   aux = idat.aux;
   dictonary = <B><FONT color="#000080">new</FONT></B> Dictonary((*(idat.dictonary)));
   pparser = <B><FONT color="#000080">new</FONT></B> Parser((*(idat.pparser)));
   cdescript = <B><FONT color="#000080">new</FONT></B> ClassDescriptions(*(idat.cdescript));
   mmanager = idat.mmanager;
   allprim = idat.allprim;
   Err = idat.Err;
   immediate = idat.immediate;


   compiling = false;
   retdepth = <FONT color="#800000">0</FONT>;
   OutFile = <FONT color="#800000">" "</FONT>;
   <B><FONT color="#000080">char</FONT></B> TraceStr[<FONT color="#800000">256</FONT>];
   sprintf(TraceStr,<FONT color="#800000">".\\InterpTrace%i.txt"</FONT>,time(NULL));
   NewTraceFile(TraceStr);
   TraceOut(<FONT color="#800000">"Started "</FONT>);
   TraceOff();
   NoStdOut();
   NoStringOut();
   ufcnt = <FONT color="#800000">0</FONT>;

   building = NULL;
 }

InterpreterData & InterpreterData::<B><FONT color="#000080">operator</FONT></B> = (<B><FONT color="#000080">const</FONT></B> InterpreterData& idat)
{
   rets.reserve(<FONT color="#800000">200</FONT>);
   dats.reserve(<FONT color="#800000">400</FONT>);
   aux.reserve(<FONT color="#800000">200</FONT>);
   tempintrp.reserve(<FONT color="#800000">300</FONT>);
   Output.reserve(<FONT color="#800000">1000</FONT>);
   numericbase = idat.numericbase;
   nbufpos = idat.nbufpos;;
   nbufflg = idat.nbufflg;;
   memcpy(nbuffer, idat.nbuffer, <FONT color="#800000">60</FONT>);
   INloc = idat.INloc;
   nwordbuf = idat.nwordbuf;

   rets = idat.rets;
   dats = idat.dats;
   aux = idat.aux;
   dictonary = <B><FONT color="#000080">new</FONT></B> Dictonary((*(idat.dictonary)));
   pparser = <B><FONT color="#000080">new</FONT></B> Parser((*(idat.pparser)));
   cdescript = <B><FONT color="#000080">new</FONT></B> ClassDescriptions(*(idat.cdescript));
   mmanager = idat.mmanager;
   allprim = idat.allprim;
   Err = idat.Err;

   compiling = false;
   immediate = idat.immediate;
   retdepth = <FONT color="#800000">0</FONT>;
   OutFile = <FONT color="#800000">" "</FONT>;
   <B><FONT color="#000080">char</FONT></B> TraceStr[<FONT color="#800000">256</FONT>];
   sprintf(TraceStr,<FONT color="#800000">".\\InterpTrace%i.txt"</FONT>,time(NULL));
   NewTraceFile(TraceStr);
   TraceOut(<FONT color="#800000">"Started "</FONT>);
   TraceOff();
   ufcnt = <FONT color="#800000">0</FONT>;
   NoStdOut();
   NoStringOut();

   building = NULL;
   <B><FONT color="#000080">return</FONT></B>(*<B><FONT color="#000080">this</FONT></B>);
}

InterpreterData::~InterpreterData()
 {
   <B><FONT color="#000080">if</FONT></B>(outstream.is_open())
   {
      outstream.close();
   }

 <B><FONT color="#000080">if</FONT></B>(tracestream.is_open())
   {
      tracestream.close();
   }

   <B><FONT color="#000080">while</FONT></B>(!rets.empty())
   {
     rets.pop_back();
   }

   <B><FONT color="#000080">while</FONT></B>(!dats.empty())
   {
     dats.pop_back();
   }

   <B><FONT color="#000080">while</FONT></B>(!aux.empty())
   {
     aux.pop_back();
   }

   <B><FONT color="#000080">if</FONT></B>(pparser != NULL)
   {
     <B><FONT color="#000080">delete</FONT></B> pparser;
   }
  <B><FONT color="#000080">delete</FONT></B> dictonary;
  <B><FONT color="#000080">if</FONT></B>(cdescript != NULL)
  {
    <B><FONT color="#000080">delete</FONT></B> cdescript;
  }
 }

string& InterpreterData::NameRunning(<B><FONT color="#000080">void</FONT></B>)
 {
   <B><FONT color="#000080">if</FONT></B>(retdepth &gt; <FONT color="#800000">0</FONT>)
   {
      Word* ww = exv0.Code();
      <B><FONT color="#000080">return</FONT></B>((*ww).Name());
   }
   <B><FONT color="#000080">else</FONT></B>
   {
      tempintrp = <FONT color="#800000">"Unknown"</FONT>;
      <B><FONT color="#000080">return</FONT></B>(tempintrp);
   }
 }

 <B><FONT color="#000080">void</FONT></B> InterpreterData::UseStdOut(<B><FONT color="#000080">void</FONT></B>)
 {
     usestdout = true;
     <B><FONT color="#000080">if</FONT></B>(pparser != NULL)
     {
        pparser-&gt;UseStdOut();
     }
 }

 <B><FONT color="#000080">void</FONT></B> InterpreterData::NoStdOut(<B><FONT color="#000080">void</FONT></B>)
 {
     usestdout = false;
     <B><FONT color="#000080">if</FONT></B>(pparser != NULL)
     {
        pparser-&gt;NoStdOut();
     }
 }

<B><FONT color="#000080">void</FONT></B> InterpreterData::UseStringOut()
{
  usestringout = true;
  <B><FONT color="#000080">if</FONT></B>(pparser != NULL)
   {
       pparser-&gt;NoStdOut();
   }
}

<B><FONT color="#000080">void</FONT></B> InterpreterData::NoStringOut()
{
  usestringout = false;
  <B><FONT color="#000080">if</FONT></B>(pparser != NULL)
   {
       pparser-&gt;NoStdOut();
   }
}


<B><FONT color="#000080">void</FONT></B> InterpreterData::ParseContainedClass(Parser * par, ClassDescription * nc)
{
    <B><FONT color="#000080">char</FONT></B> *zwrd;
    string szwrd;
    szwrd.reserve(<FONT color="#800000">120</FONT>);
    string ncmp;
    ncmp.reserve(<FONT color="#800000">120</FONT>);
    ncmp = <FONT color="#800000">"-:"</FONT>;
    Element *nel = NULL;
    <B><FONT color="#000080">char</FONT></B> ntst[<FONT color="#800000">120</FONT>];
    
    <B><FONT color="#000080">if</FONT></B>(nc != NULL)
    {
        <B><FONT color="#000080">if</FONT></B>((zwrd = par-&gt;NextWord()) != NULL)
        {
            szwrd = zwrd;
            sprintf(ntst, <FONT color="#800000">"%s == %s"</FONT>, szwrd.c_str(), ncmp.c_str());
            DebugTrace(ntst);
            <B><FONT color="#000080">if</FONT></B>(szwrd == ncmp)
            {
                <B><FONT color="#000080">if</FONT></B>((zwrd = par-&gt;NextWord()) != NULL)
                {
                    szwrd = zwrd; 
                    ClassMethod * pcm = NULL;
                    <B><FONT color="#000080">if</FONT></B>((pcm = nc-&gt;MethodDesc(szwrd)) != NULL)
                    {
                        <B><FONT color="#000080">if</FONT></B>(pcm-&gt;FlagsMatch(ClassMethod::Private) == <FONT color="#800000">0</FONT> && pcm-&gt;FlagsMatch(ClassMethod::Protected) == <FONT color="#800000">0</FONT>)
                        {
                            Element *nel = <B><FONT color="#000080">new</FONT></B> Element(pcm);
                            (Building())-&gt;AddElement(*nel);
                            <B><FONT color="#000080">delete</FONT></B> nel;  
                        }
                        <B><FONT color="#000080">else</FONT></B>
                        {
                            ShowError(Errors::PRIVATE_METHOD, szwrd);
                        }
                    }
                    <B><FONT color="#000080">else</FONT></B>
                    {
                        ClassData * pcd = NULL;
                        <B><FONT color="#000080">if</FONT></B>((pcd = nc-&gt;DataDesc(szwrd)) != NULL)
                        {
                            <B><FONT color="#000080">if</FONT></B>(pcd-&gt;FlagsMatch(ClassData::Private) == <FONT color="#800000">0</FONT> && pcd-&gt;FlagsMatch(ClassData::Protected) == <FONT color="#800000">0</FONT>)
                            {
                                Element *nel = <B><FONT color="#000080">new</FONT></B> Element(pcd);
                                (Building())-&gt;AddElement(*nel);
                                <B><FONT color="#000080">delete</FONT></B> nel;
                                <B><FONT color="#000080">if</FONT></B>(pcd-&gt;IsClass())
                                {
                                    ClassDescription * rc = pcd-&gt;DClassDesc();
                                    ParseContainedClass(par, rc);
                                }      
                            }
                            <B><FONT color="#000080">else</FONT></B>
                            {
                                ShowError(Errors::PRIVATE_METHOD, szwrd);
                            }
                        }
                        <B><FONT color="#000080">else</FONT></B>
                        {
                            ShowError(Errors::NO_MEMBER_FOUND, szwrd);
                        }
                    }
                }
            }
            <B><FONT color="#000080">else</FONT></B>
            {
                ShowError(Errors::SYNTAX_ERROR, szwrd);
            }
        }
        <B><FONT color="#000080">else</FONT></B>
        {
            ShowError(Errors::BUFFER_END);
        }
    }
    <B><FONT color="#000080">else</FONT></B>
    {
      ShowError(Errors::NO_CLASS_EXISTS);
    }
}

<B><FONT color="#000080">bool</FONT></B> InterpreterData::ParseClass(string &awrd, Parser * par)
{
  Element *anel = NULL;

         ClassDescription * pcd = ClassDSCR()-&gt;CompilingWhat();
         <B><FONT color="#000080">bool</FONT></B> bv = false;
         <B><FONT color="#000080">if</FONT></B>(pcd != NULL)
         {
           bv = pcd-&gt;IsMethodCompiling();
         }
         <B><FONT color="#000080">if</FONT></B>(Compiling() && bv)
         {
      
              ClassMethod * pcm = NULL;
              <B><FONT color="#000080">if</FONT></B>((pcm = pcd-&gt;MethodDesc(awrd)) != NULL)
              {
                 anel = <B><FONT color="#000080">new</FONT></B> Element(((<B><FONT color="#000080">long</FONT></B>)pcd));
                 (Building())-&gt;AddElement(*anel);
                 <B><FONT color="#000080">delete</FONT></B> anel;   
                 string act;
                 act.reserve(<FONT color="#800000">256</FONT>);
                 act = <FONT color="#800000">"this"</FONT>;
                 Word * thiscall = IDict()-&gt;Address(act);
                 anel = <B><FONT color="#000080">new</FONT></B> Element(thiscall);
                 (Building())-&gt;AddElement(*anel);
                 <B><FONT color="#000080">delete</FONT></B> anel;   
                 anel = <B><FONT color="#000080">new</FONT></B> Element(pcm);
                 (Building())-&gt;AddElement(*anel);
                 <B><FONT color="#000080">delete</FONT></B> anel;     
                 <B><FONT color="#000080">return</FONT></B>(true);
              }
              <B><FONT color="#000080">else</FONT></B>
              {
                  ClassData * pdd = NULL;
                  <B><FONT color="#000080">if</FONT></B>((pdd = pcd-&gt;DataDesc(awrd)) != NULL)
                  {
                     <B><FONT color="#000080">char</FONT></B> drdr[<FONT color="#800000">120</FONT>];
                     sprintf(drdr, <FONT color="#800000">"Found data object in method %s, (Language parse)"</FONT>, pdd-&gt;Name().c_str());
                     DebugTrace(drdr);
                     anel = <B><FONT color="#000080">new</FONT></B> Element(((<B><FONT color="#000080">long</FONT></B>)pcd));
                     (Building())-&gt;AddElement(*anel);  <I><FONT color="#008080">// add cd</FONT></I>
                     <B><FONT color="#000080">delete</FONT></B> anel;   
                     string act;
                     act.reserve(<FONT color="#800000">256</FONT>);
                     act = <FONT color="#800000">"this"</FONT>;
                     Word * thiscall = IDict()-&gt;Address(act);
                     anel = <B><FONT color="#000080">new</FONT></B> Element(thiscall);
                     (Building())-&gt;AddElement(*anel);
                     <B><FONT color="#000080">delete</FONT></B> anel;   
                     anel = <B><FONT color="#000080">new</FONT></B> Element(pdd);
                     (Building())-&gt;AddElement(*anel);
                     <B><FONT color="#000080">if</FONT></B>(pdd-&gt;IsClass() != <FONT color="#800000">0</FONT>)
                     {
                         DebugTrace(<FONT color="#800000">"Class object found (Language parse)"</FONT>);
                         ClassDescription * nc = pdd-&gt;DClassDesc();
                         ParseContainedClass(par, nc);

                     }         
                     <B><FONT color="#000080">else</FONT></B>
                     {
                        DebugTrace(<FONT color="#800000">"data object was not class (Language parse)"</FONT>);
                     }
                     <B><FONT color="#000080">delete</FONT></B> anel;
                     <B><FONT color="#000080">return</FONT></B>(true);
                  }
                  <B><FONT color="#000080">else</FONT></B>
                  {
                       <I><FONT color="#008080">//  "No Such Word"</FONT></I>
                       <B><FONT color="#000080">return</FONT></B>(false);
                  }
              }
         }
         <B><FONT color="#000080">else</FONT></B>
         {
             <I><FONT color="#008080">//  "No Such Word"</FONT></I>
             <B><FONT color="#000080">return</FONT></B>(false);
         }
}

<B><FONT color="#000080">bool</FONT></B> InterpreterData::ParseDigits(<B><FONT color="#000080">char</FONT></B> *wrd, Parser * par)
{
    <B><FONT color="#000080">long</FONT></B> aa;
    Element *anel = NULL;
    <B><FONT color="#000080">char</FONT></B> * ws = &wrd[<FONT color="#800000">0</FONT>];
    <B><FONT color="#000080">char</FONT></B> * we = NULL;
  
<I><FONT color="#008080">//    if(par-&gt;AllDigits(wrd))  // is it a literal long ??</FONT></I>
 <I><FONT color="#008080">//{</FONT></I>
        <B><FONT color="#000080">if</FONT></B>(Compiling())
        {
            aa = strtoul( ws, &we, numericbase);
            <B><FONT color="#000080">if</FONT></B>(*we != <FONT color="#800000">0</FONT>)
            {
               <B><FONT color="#000080">return</FONT></B>(false);
            }
            anel = <B><FONT color="#000080">new</FONT></B> Element(aa);
            (Building())-&gt;AddElement(*anel);
            <B><FONT color="#000080">delete</FONT></B> anel;
        }
        <B><FONT color="#000080">else</FONT></B>
        {
            aa = strtoul( ws, &we, numericbase);
            <B><FONT color="#000080">if</FONT></B>(*we != <FONT color="#800000">0</FONT>)
            {
               <B><FONT color="#000080">return</FONT></B>(false);
            }
            PushD(aa);
        }
        <B><FONT color="#000080">return</FONT></B>(true);
<I><FONT color="#008080">//    }</FONT></I>
<I><FONT color="#008080">//    return(false);</FONT></I>
}

<B><FONT color="#000080">int</FONT></B> InterpreterData::Parse(<B><FONT color="#000080">char</FONT></B> * txt, <B><FONT color="#000080">bool</FONT></B> once)
{ 
    <I><FONT color="#008080">//  int errorv;</FONT></I>
    <B><FONT color="#000080">char</FONT></B> *wrd;
    string awrd;
    awrd.reserve(<FONT color="#800000">120</FONT>);
    <B><FONT color="#000080">int</FONT></B> wordindex;
    Element *anel = NULL;
    
    DebugTrace(<FONT color="#800000">"Interpreter Entered Parser"</FONT>); 
    Parser * par = IParser();
    par-&gt;PushBuf(txt);
    
    <B><FONT color="#000080">while</FONT></B>((wrd = par-&gt;NextWord(once)) != NULL)
    {
        anel = NULL;
        awrd = wrd;
              
        <B><FONT color="#000080">if</FONT></B>(ParseClass(awrd, par) == false)
        {       
            <B><FONT color="#000080">if</FONT></B>((wordindex = IDict()-&gt;Exists(awrd)) != -<FONT color="#800000">1</FONT>)  <I><FONT color="#008080">// the word exists add the element</FONT></I>
            {
                IDict()-&gt;Execute(wordindex, *<B><FONT color="#000080">this</FONT></B>); <I><FONT color="#008080">// element added by word itself when compiling</FONT></I>
            }
            <B><FONT color="#000080">else</FONT></B> <I><FONT color="#008080">// word does not exist so see if its a digit or class method</FONT></I>
            {             
               <B><FONT color="#000080">if</FONT></B>(ParseDigits(wrd, par) == false)
               { 
                    <I><FONT color="#008080">//  "No Such Word"</FONT></I>
                    ShowError(Errors::NO_SUCH_WORD, awrd);                    
               }
            }
        }
        <B><FONT color="#000080">if</FONT></B>(Fatal())
        {
            par-&gt;PopBuf();
            DebugTrace(<FONT color="#800000">"Fatal error in Interpreter poping buffer"</FONT>); 
<I><FONT color="#008080">//            ResetFatal();</FONT></I>
            <B><FONT color="#000080">break</FONT></B>;
        }
    }
    DebugTrace(<FONT color="#800000">"Emptied input buffer in interpreter"</FONT>);
    
    <B><FONT color="#000080">return</FONT></B>(true);
}

 <B><FONT color="#000080">void</FONT></B> InterpreterData::DecompileCurrent()
 {
    <B><FONT color="#000080">if</FONT></B>(retdepth &gt; <FONT color="#800000">0</FONT>)
    {
      string dcs;
      <B><FONT color="#000080">char</FONT></B> astr[<FONT color="#800000">50</FONT>];

      RSData rv = exv0;
      rv.Code()-&gt;Decompile(dcs, *<B><FONT color="#000080">this</FONT></B>);

      sprintf(astr,<FONT color="#800000">" &lt;&lt;&lt; Element %i is executing &gt;&gt;&gt;\n"</FONT>, rv.Index());
      dcs += astr; 
      rv.Index();
      Out() += dcs;
      WriteOut();
      <B><FONT color="#000080">if</FONT></B>(Tracing())
      {
        TraceOut(dcs);
      }
    }
 }

 <B><FONT color="#000080">void</FONT></B> InterpreterData::DecompileOne()
 {
    <B><FONT color="#000080">if</FONT></B>(retdepth &gt; <FONT color="#800000">1</FONT>)
    {
      string dcs;
      RSData rv = GetRsv(<FONT color="#800000">0</FONT>);
      rv.Code()-&gt;Decompile(dcs, *<B><FONT color="#000080">this</FONT></B>);

      <B><FONT color="#000080">char</FONT></B> astr[<FONT color="#800000">60</FONT>];
      sprintf(astr,<FONT color="#800000">" &lt;&lt;&lt; Element %i is executing &gt;&gt;&gt;\n"</FONT>, rv.Index());
      dcs += astr;
      Out() += dcs;
      WriteOut();
      <B><FONT color="#000080">if</FONT></B>(Tracing())
      {
        TraceOut(dcs);
      }
    }
 }


 <B><FONT color="#000080">void</FONT></B> InterpreterData::DecompileN(<B><FONT color="#000080">int</FONT></B> n)
 {
    <B><FONT color="#000080">if</FONT></B>(retdepth &gt; n)
    {
      <B><FONT color="#000080">char</FONT></B> astr[<FONT color="#800000">60</FONT>];
      sprintf(astr, <FONT color="#800000">" \n----------RSData stack %i -----"</FONT>, n);
      string dcs = astr;
      RSData rv = GetRsv(n);
      rv.Code()-&gt;Decompile(dcs, *<B><FONT color="#000080">this</FONT></B>); 
      sprintf(astr,<FONT color="#800000">" \n&lt;&lt;&lt; Element %i is executing &gt;&gt;&gt;\n"</FONT>, rv.Index());

      dcs += astr;
      Out() += dcs;
      WriteOut();
      <B><FONT color="#000080">if</FONT></B>(Tracing())
      {
        TraceOut(dcs);
      }
    }
 }

 <B><FONT color="#000080">void</FONT></B> InterpreterData::BuildWithName(string & name)
 {
   building = <B><FONT color="#000080">new</FONT></B> Word();
   building-&gt;NewName(name);
 }

 <B><FONT color="#000080">void</FONT></B> InterpreterData::BuildAddElement(Element& el)
 {
   building-&gt;AddElement(el);
 }

 <B><FONT color="#000080">void</FONT></B> InterpreterData::BuildAddElement(<B><FONT color="#000080">long</FONT></B> qq)
 {
   Element *pel = <B><FONT color="#000080">new</FONT></B> Element(qq);
   building-&gt;AddElement(*pel);
   <B><FONT color="#000080">delete</FONT></B> pel;
 }

 <B><FONT color="#000080">void</FONT></B> InterpreterData::BuildAddElement(<B><FONT color="#000080">long</FONT></B>* pqq)
 {
   Element *pel = <B><FONT color="#000080">new</FONT></B> Element(pqq);
   building-&gt;AddElement(*pel);
   <B><FONT color="#000080">delete</FONT></B> pel;
 }

 <B><FONT color="#000080">void</FONT></B> InterpreterData::BuildAddElement(string* pss)
 {
   Element *pel = <B><FONT color="#000080">new</FONT></B> Element(pss);
   building-&gt;AddElement(*pel);
   <B><FONT color="#000080">delete</FONT></B> pel;
 }

 <B><FONT color="#000080">void</FONT></B> InterpreterData::BuildAddElement(Word* pww)
 {
   Element *pel = <B><FONT color="#000080">new</FONT></B> Element(pww);
   building-&gt;AddElement(*pel);
   <B><FONT color="#000080">delete</FONT></B> pel;
 }

 <B><FONT color="#000080">void</FONT></B> InterpreterData::BuildAddElement(ClassMethod* pm)
 {
   Element *pel = <B><FONT color="#000080">new</FONT></B> Element(pm);
   building-&gt;AddElement(*pel);
   <B><FONT color="#000080">delete</FONT></B> pel;
 }

 <B><FONT color="#000080">void</FONT></B> InterpreterData::BuildAddElement(ClassData* pd)
 {
   Element *pel = <B><FONT color="#000080">new</FONT></B> Element(pd);
   building-&gt;AddElement(*pel);
   <B><FONT color="#000080">delete</FONT></B> pel;
 }

 <B><FONT color="#000080">void</FONT></B> InterpreterData::BuildFinishWord(<B><FONT color="#000080">void</FONT></B>)
 {
   dictonary-&gt;Add(*building);
   <B><FONT color="#000080">delete</FONT></B> building;
   building = NULL;
 }

 <B><FONT color="#000080">int</FONT></B> InterpreterData::BuildLastUsedElement()
 {
    <B><FONT color="#000080">return</FONT></B>((building-&gt;NextIndex() - <FONT color="#800000">1</FONT>));
 }

 <B><FONT color="#000080">int</FONT></B> InterpreterData::BuildLastElementCalling(Word *pwrd)
 {
    <B><FONT color="#000080">int</FONT></B> lu = BuildLastUsedElement();
    <B><FONT color="#000080">if</FONT></B>(lu &gt;= <FONT color="#800000">0</FONT>)
    {
       <B><FONT color="#000080">return</FONT></B>((building-&gt;LastUse(pwrd, lu)));
    }
    <B><FONT color="#000080">else</FONT></B>
    {
       <B><FONT color="#000080">return</FONT></B>(-<FONT color="#800000">1</FONT>);
    }
 }

<I><FONT color="#008080">// ------------ClassMethod----------------------------</FONT></I>

 <B><FONT color="#000080">int</FONT></B> ClassMethod::Execute(<B><FONT color="#000080">int</FONT></B> index, InterpreterData & idat, <B><FONT color="#000080">int</FONT></B> imed)
 {
     <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> fm;
<I><FONT color="#008080">//     bool savec;</FONT></I>
     RSData rr(<B><FONT color="#000080">this</FONT></B>);
     rr.SetIndex(index);
     <B><FONT color="#000080">int</FONT></B> ty;
     
     <B><FONT color="#000080">if</FONT></B>(idat.Tracing())
     {
         string ts;
         ts.reserve(<FONT color="#800000">120</FONT>);
         ts = <FONT color="#800000">" Entered method \""</FONT>;
         ts += Name();
         ts += <FONT color="#800000">"\" "</FONT>;
         idat.TraceOut(ts);
     }
     
     <B><FONT color="#000080">char</FONT></B> * tv = (<B><FONT color="#000080">char</FONT></B> *) idat.PopD();
     ClassDescription * myclass = GetClassDescription();
     myclass-&gt;PushThis(tv);
     
     fm = FlagsMatch(idat.ExecuteCompile);
<I><FONT color="#008080">//     if(fm)</FONT></I>
<I><FONT color="#008080">//     {</FONT></I>
<I><FONT color="#008080">//         if(idat.Compiling())</FONT></I>
<I><FONT color="#008080">//         {</FONT></I>
<I><FONT color="#008080">//           savec = true;</FONT></I>
<I><FONT color="#008080">//         }</FONT></I>
<I><FONT color="#008080">//         idat.EndCompile();</FONT></I>
<I><FONT color="#008080">//     }</FONT></I>
     
     <B><FONT color="#000080">if</FONT></B>((idat.Compiling() == false) || fm || imed)
     {
         idat.SetExv(rr);
         
         <B><FONT color="#000080">while</FONT></B>(idat.ExvIndex() &lt; method.size())
         {
             ty = method[idat.ExvIndex()].Type();
             <B><FONT color="#000080">if</FONT></B>(ty == Element::Definition || ty == Element::MethodDefinition)
             {
                 rr.SetIndex(idat.ExvIndex());
                 idat.PushR(rr);
             }
             
             try
             {
                 method[idat.ExvIndex()].Execute(idat, (fm | imed));
             }
             <B><FONT color="#000080">catch</FONT></B>(...)
             {
<B><FONT color="#000080">#ifdef</FONT></B> USING_WINDOWS
                 idat.WindowsError();
<B><FONT color="#000080">#endif</FONT></B>
                 idat.ShowError(Errors::SYSTEM_EXECPTION, Name());
             }
             
             <B><FONT color="#000080">if</FONT></B>(ty == Element::Definition || ty == Element::MethodDefinition)
             {
                 idat.SetExv(idat.PopR());
                 rr = idat.GetExv();
             }
             
             idat.IncExv();
         }
<I><FONT color="#008080">//         if(fm)</FONT></I>
<I><FONT color="#008080">//         {</FONT></I>
<I><FONT color="#008080">//             idat.SetCompiling(savec);</FONT></I>
<I><FONT color="#008080">//         }</FONT></I>
     }
     <B><FONT color="#000080">else</FONT></B>
     {
         idat.BuildAddElement(<B><FONT color="#000080">this</FONT></B>);   
     }
     
     myclass-&gt;PopThis();
     <B><FONT color="#000080">if</FONT></B>(idat.Tracing())
     {
         string ds;
         ds.reserve(<FONT color="#800000">120</FONT>);
         ds = <FONT color="#800000">" ---Exited method \""</FONT>;
         ds += Name();
         ds += <FONT color="#800000">"\" "</FONT>;
         idat.TraceOut(ds);
     }
     
     <B><FONT color="#000080">return</FONT></B>(<FONT color="#800000">0</FONT>);
 }

<B><FONT color="#000080">void</FONT></B> ClassMethod::Decompile(string& dtext, InterpreterData & intrp)
{
  dtext += <FONT color="#800000">"\nMethod Name: \""</FONT>;
  dtext += name;
  dtext += <FONT color="#800000">"\""</FONT>;
  <B><FONT color="#000080">char</FONT></B> tstr[<FONT color="#800000">150</FONT>]; 

  <B><FONT color="#000080">for</FONT></B>(<B><FONT color="#000080">int</FONT></B> ii = <FONT color="#800000">0</FONT>;ii &lt; method.size();ii++)
  {
     <B><FONT color="#000080">int</FONT></B> tt = method[ii].Type();
     sprintf(tstr,<FONT color="#800000">"\n--&gt;Element %i is "</FONT>, ii);
     dtext += tstr;
     <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> p1;
     string ss;
     ss.reserve(<FONT color="#800000">120</FONT>);
     string ns;
     ns.reserve(<FONT color="#800000">120</FONT>);

     <B><FONT color="#000080">switch</FONT></B> (tt)
     {
       <B><FONT color="#000080">case</FONT></B> Element::Primitive:
           dtext += <FONT color="#800000">" a primitive"</FONT>;
           <B><FONT color="#000080">break</FONT></B>;
       <B><FONT color="#000080">case</FONT></B> Element::Literal:
           dtext += <FONT color="#800000">" a literal == to "</FONT>;
           method[ii].FetchLiteralVal(&p1);
           sprintf(tstr,<FONT color="#800000">"%i"</FONT>, p1);
           dtext += tstr;
           <B><FONT color="#000080">break</FONT></B>;
       <B><FONT color="#000080">case</FONT></B> Element::Definition:
           dtext += <FONT color="#800000">" a call to the word "</FONT>;
           <B><FONT color="#000080">if</FONT></B>(method[ii].FetchDefinitionName(ns))
           {
             dtext += (ns);
           }
           <B><FONT color="#000080">break</FONT></B>;
       <B><FONT color="#000080">case</FONT></B> Element::LitString:
           dtext += <FONT color="#800000">" a pointer to the string literal "</FONT>; 
           method[ii].FetchLitString(ss);
           dtext += ss;
           <B><FONT color="#000080">break</FONT></B>;
       <B><FONT color="#000080">case</FONT></B> Element::AddressV:
           dtext += <FONT color="#800000">" a value set to "</FONT>;
           method[ii].FetchLiteralVal(&p1);
           sprintf(tstr,<FONT color="#800000">"%i "</FONT>, p1);
           dtext += tstr;
           <B><FONT color="#000080">break</FONT></B>;
       <B><FONT color="#000080">case</FONT></B> Element::MethodDefinition:
            dtext += <FONT color="#800000">" a call to the method "</FONT>; 
            <B><FONT color="#000080">if</FONT></B>(method[ii].FetchDefinitionName(ns))
            {
               dtext += (ns);
            }
            <B><FONT color="#000080">break</FONT></B>;
       <B><FONT color="#000080">case</FONT></B> Element::DataDefinition:
            dtext += <FONT color="#800000">" a reference to the class data object "</FONT>; 
            <B><FONT color="#000080">if</FONT></B>(method[ii].FetchDefinitionName(ns))
            {
               dtext += (ns);
            }
            <B><FONT color="#000080">break</FONT></B>;
       <B><FONT color="#000080">default</FONT></B>:
           dtext += <FONT color="#800000">" Corrupt element of unknown type"</FONT>;
           <B><FONT color="#000080">break</FONT></B>;
     }
  }
  sprintf(tstr, <FONT color="#800000">"\n --End-of-decompile of %s----"</FONT>, Name().c_str());
  dtext += tstr;
}


<I><FONT color="#008080">// ---------------ClassData-------------------</FONT></I>

 ClassData::ClassData(string & nam, <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> siz, ClassDescription *pc, 
     <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> num, ClassDescription *dc)
   {
      name.reserve(<FONT color="#800000">120</FONT>);
      name = nam;
      flags = 0l;

      <B><FONT color="#000080">if</FONT></B>(num &gt; <FONT color="#800000">1</FONT>)
      {
        size = num *siz;
        number_of = num;
        element_size = siz;
        SetFlags(ArrayType);
      }
      <B><FONT color="#000080">else</FONT></B>
      {
        size = siz;
        number_of = <FONT color="#800000">1</FONT>;
        element_size = siz; 
      }

      <B><FONT color="#000080">if</FONT></B>(dc != NULL)
      {
        dclass_desc = dc;
        SetFlags(ClassType);
      }
      <B><FONT color="#000080">else</FONT></B>
      {
        dclass_desc = NULL;
      }
  
      pclassdecription = pc;
      offset = pc-&gt;CurrentOffset();
   }

 <B><FONT color="#000080">int</FONT></B> ClassData::Resolve(InterpreterData & idat)
 {
   <B><FONT color="#000080">long</FONT></B> adr;

   <B><FONT color="#000080">if</FONT></B>(idat.Tracing())
   {
      string ts;
      ts.reserve(<FONT color="#800000">120</FONT>);
      ts = <FONT color="#800000">" Resolve Class data "</FONT>;
      ts += Name();
      idat.TraceOut(ts);
   }

   <B><FONT color="#000080">char</FONT></B> * tv = (<B><FONT color="#000080">char</FONT></B> *) idat.PopD();
   ClassDescription * myclass = GetClassDescription();
   myclass-&gt;PushThis(tv);   

   <B><FONT color="#000080">char</FONT></B> test1[<FONT color="#800000">200</FONT>];

   <B><FONT color="#000080">if</FONT></B>(FlagsMatch(ArrayType))
   {
     <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> nn = idat.PopD();
     adr = ((nn * element_size) + offset + ((<B><FONT color="#000080">long</FONT></B>)myclass-&gt;ThisFront()));

     sprintf(test1, <FONT color="#800000">"Class Data %s array[index %li], element size %li, offset %li, class address %li, total %li"</FONT>, 
         Name().c_str(), nn, element_size, offset, ((<B><FONT color="#000080">long</FONT></B>)myclass-&gt;ThisFront()), adr);
     idat.DebugTrace(test1); 

   }
   <B><FONT color="#000080">else</FONT></B>
   {
     adr = (offset + ((<B><FONT color="#000080">long</FONT></B>)myclass-&gt;ThisFront()));
      sprintf(test1, <FONT color="#800000">"Class Data %s offset %li, class address %li, total %li"</FONT>, 
         Name().c_str(), offset, ((<B><FONT color="#000080">long</FONT></B>)myclass-&gt;ThisFront()), adr);
      idat.DebugTrace(test1); 
   }

<I><FONT color="#008080">//   if(FlagsMatch(ClassType))</FONT></I>
<I><FONT color="#008080">//   {</FONT></I>
 <I><FONT color="#008080">//    idat.PushD(((long)DClassDesc()));</FONT></I>
<I><FONT color="#008080">//     idat.PushD((adr));</FONT></I>
<I><FONT color="#008080">//   }</FONT></I>
<I><FONT color="#008080">//   else</FONT></I>
<I><FONT color="#008080">//   {</FONT></I>
     idat.PushD((adr));
<I><FONT color="#008080">//  }</FONT></I>

   myclass-&gt;PopThis();

 <B><FONT color="#000080">if</FONT></B>(idat.Tracing())
  {
    string ds;
    ds.reserve(<FONT color="#800000">120</FONT>);
    ds = <FONT color="#800000">" ---Exited Resolve class Data "</FONT>;
    ds += Name();
    idat.TraceOut(ds);
  }

   <B><FONT color="#000080">return</FONT></B>(<FONT color="#800000">0</FONT>);
 }

 <B><FONT color="#000080">void</FONT></B> ClassData::Decompile(string& dtext, InterpreterData & idat)
 {
   dtext += <FONT color="#800000">"\nName: \""</FONT>;
   dtext += name;
   dtext += <FONT color="#800000">"\""</FONT>;
   <B><FONT color="#000080">char</FONT></B> astr[<FONT color="#800000">150</FONT>];
   <B><FONT color="#000080">char</FONT></B> cstr[<FONT color="#800000">150</FONT>];
   <B><FONT color="#000080">char</FONT></B> tstr[<FONT color="#800000">150</FONT>];
   <B><FONT color="#000080">char</FONT></B> pstr[<FONT color="#800000">150</FONT>];

   <B><FONT color="#000080">if</FONT></B>(IsPrivate())
   {
     sprintf(pstr, <FONT color="#800000">"A private "</FONT>);
   }
   <B><FONT color="#000080">else</FONT></B>
   {
     sprintf(pstr, <FONT color="#800000">"A public "</FONT>);
   }

   <B><FONT color="#000080">if</FONT></B>(IsClass())
   {
     sprintf(cstr, <FONT color="#800000">"class %s instance "</FONT>,  DClassDesc()-&gt;Name().c_str());
   }
   <B><FONT color="#000080">else</FONT></B>
   {
     sprintf(cstr, <FONT color="#800000">"object "</FONT>);
   }

   <B><FONT color="#000080">if</FONT></B>(Array())
   {
     sprintf(astr, <FONT color="#800000">"array of %li elements. each of %li bytes (total size = %li)"</FONT>, ElementNumber(), ElementSize(), Size());
   }
   <B><FONT color="#000080">else</FONT></B>
   {
     sprintf(astr, <FONT color="#800000">"(size = %li)"</FONT>, Size());
   }

   sprintf(tstr, <FONT color="#800000">"%s%s%s"</FONT>, pstr, cstr, astr);
   dtext += tstr;
   sprintf(tstr, <FONT color="#800000">"\n --End-of-decompile of %s----"</FONT>, Name().c_str());
   dtext += tstr ;
 }


<I><FONT color="#008080">// ---------------ClassDescriptions-------------------</FONT></I>
 
 <B><FONT color="#000080">void</FONT></B> ClassDescription::ResetNamesForInherit(string &prepend)
 {
     string nnam;
     string dnam;
     string ndnam;
     <B><FONT color="#000080">char</FONT></B> ntxt[<FONT color="#800000">1024</FONT>]; 
     
     nnam.reserve(<FONT color="#800000">1024</FONT>);
     dnam.reserve(<FONT color="#800000">1024</FONT>);
     ndnam.reserve(<FONT color="#800000">1024</FONT>);
     nnam = ((prepend + <FONT color="#800000">"::"</FONT>) + Name());
     dnam = (<FONT color="#800000">"~"</FONT> + Name());
     ndnam = (<FONT color="#800000">"~"</FONT> + nnam);
     
     sprintf(ntxt, <FONT color="#800000">"Inherited %s becomes %s with constr name %s and destr name %s"</FONT>, 
         name.c_str(), nnam.c_str(), nnam.c_str(), ndnam.c_str());
     pidat-&gt;DebugTrace(ntxt);

     RenameMethod(name, nnam);
     RenameMethod(dnam, ndnam);
     SetName(nnam);
 }

 <B><FONT color="#000080">void</FONT></B> ClassDescription::Inherit(string &nam, <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> mode)
 {
     map&lt;string, ClassData, less&lt;string&gt; &gt;:: iterator dt;
     map&lt;string, ClassMethod, less&lt;string&gt; &gt;:: iterator mt;
     ClassData * pdd;
     <B><FONT color="#000080">char</FONT></B> ttxt[<FONT color="#800000">1024</FONT>]; 

     ClassDescription * cd = pidat-&gt;ClassDSCR()-&gt;Find(nam);
     <B><FONT color="#000080">if</FONT></B>(cd != NULL && cd != <B><FONT color="#000080">this</FONT></B>)
     {
         ClassDescription cpyd = (*cd);
         cpyd.ResetNamesForInherit(Name());
         string nnam;
         nnam.reserve(<FONT color="#800000">1024</FONT>);
         nnam = cpyd.Name();

         sprintf(ttxt, <FONT color="#800000">"%s := ' %i %s' as %s"</FONT>, Name().c_str(), cd, nam.c_str(), nnam.c_str());
         pidat-&gt;DebugTrace(ttxt);

    
         <B><FONT color="#000080">if</FONT></B>(mode == ClassDescription::CompilePrivate)
         {
             cpyd.ResetAllPrivate();
         }
         <B><FONT color="#000080">else</FONT></B>
         {
             <B><FONT color="#000080">if</FONT></B>(mode == ClassDescription::CompileProtected)
             {
                 cpyd.ResetAllProtected();
             }
         }
        pidat-&gt;ClassDSCR()-&gt;AddInheritedDescription(cpyd);
        cd = pidat-&gt;ClassDSCR()-&gt;Find(nnam);
        <B><FONT color="#000080">if</FONT></B>(cd == NULL)
        {
           pidat-&gt;DebugTrace(<FONT color="#800000">" NO new cd for inherit??"</FONT>); 
        }

        sprintf(ttxt, <FONT color="#800000">"%s new object description inherited %s = %lx"</FONT>, name.c_str(), cd-&gt;Name().c_str(), cd);
        pidat-&gt;DebugTrace(ttxt);

        pdd = <B><FONT color="#000080">new</FONT></B> ClassData(nnam, cpyd.Size(), <B><FONT color="#000080">this</FONT></B>,  <FONT color="#800000">1</FONT>, cd);
        AddData(*pdd);
        <B><FONT color="#000080">delete</FONT></B> pdd;
        AddInheretedName(nnam);
     }
     <B><FONT color="#000080">else</FONT></B>
     {
        pidat-&gt;ShowError(Errors::NO_CLASS_EXISTS, nam);
     }
 }

 ClassDescription * ClassDescription::InheritedClassDescription(string & cn)
 {
    ClassDescription * pcd = pidat-&gt;ClassDSCR()-&gt;Find(cn);
    <B><FONT color="#000080">return</FONT></B>(pcd);
 }

 ClassData * ClassDescription::InheritedClassData(string & nam)
 {
     ClassData * ndat[<FONT color="#800000">5</FONT>];
     ClassDescription * inhcl = NULL;
     <B><FONT color="#000080">int</FONT></B> indix = <FONT color="#800000">0</FONT>;
     <B><FONT color="#000080">char</FONT></B> ttxt[<FONT color="#800000">256</FONT>];
     ndat[<FONT color="#800000">0</FONT>] = NULL;

     <B><FONT color="#000080">for</FONT></B>(<B><FONT color="#000080">int</FONT></B> ii = <FONT color="#800000">0</FONT>; ii &lt; inherited_order.size();ii++)
     {
         inhcl = InheritedClassDescription(inherited_order[ii]);
         <B><FONT color="#000080">if</FONT></B>(inhcl != NULL)
         {
             sprintf(ttxt, <FONT color="#800000">"%s found inherited cd %s at %lx in InheritedClassData() (search for %s)"</FONT>, 
                 Name().c_str(), inhcl-&gt;Name().c_str(), inhcl, nam.c_str());
             pidat-&gt;DebugTrace(ttxt);
             ndat[indix] = inhcl-&gt;DataDesc(nam);
             <B><FONT color="#000080">if</FONT></B>(ndat[indix] != NULL)
             {
                 sprintf(ttxt, <FONT color="#800000">"%s Found data in inherited %s"</FONT>, name.c_str(), ndat[indix]-&gt;Name().c_str());
                 pidat-&gt;DebugTrace(ttxt);
                 indix++;
                 <B><FONT color="#000080">if</FONT></B>(indix &gt; <FONT color="#800000">4</FONT>)
                 {
                   <B><FONT color="#000080">break</FONT></B>;
                 }
             }
         }
         <B><FONT color="#000080">else</FONT></B>
         {
             pidat-&gt;DebugTrace(<FONT color="#800000">"NULL from InheritedClassDescription(inherited_order[ii])"</FONT>);
             <I><FONT color="#008080">// fatal error</FONT></I>
         }
     }

     <B><FONT color="#000080">if</FONT></B>(indix &gt; <FONT color="#800000">1</FONT>)
     {
         sprintf(ttxt, <FONT color="#800000">"%s found ambiuguious names %s"</FONT>, name.c_str(), ndat[indix]-&gt;Name().c_str());
         pidat-&gt;DebugTrace(ttxt);
         <I><FONT color="#008080">// error ambiguious name</FONT></I>
         pidat-&gt;ShowError(Errors::AMBIGUIOUS_MEMBER, nam);
     }

     <B><FONT color="#000080">return</FONT></B>(ndat[<FONT color="#800000">0</FONT>]);
 }

 <B><FONT color="#000080">void</FONT></B> ClassDescription::PushInheritedThis(<B><FONT color="#000080">char</FONT></B> * nths)
 {
     ClassData * ndat = NULL;
     ClassDescription * inhcl = NULL;
     <B><FONT color="#000080">for</FONT></B>(<B><FONT color="#000080">int</FONT></B> ii = <FONT color="#800000">0</FONT>; ii &lt; inherited_order.size();ii++)
     {
         inhcl = InheritedClassDescription(inherited_order[ii]);
         ndat = DataDesc(inherited_order[ii]);
         <B><FONT color="#000080">if</FONT></B>(ndat != NULL)
         {
             inhcl-&gt;PushThis((ndat-&gt;Offset() + nths));
         }
         <B><FONT color="#000080">else</FONT></B>
         {
             <I><FONT color="#008080">// error ambiguious name</FONT></I>
             pidat-&gt;ShowError(Errors::AMBIGUIOUS_MEMBER);
             <B><FONT color="#000080">break</FONT></B>;
         }
     }
 }

 <B><FONT color="#000080">void</FONT></B> ClassDescription::PopInheritedThis(<B><FONT color="#000080">void</FONT></B>)
 {
     ClassData * ndat = NULL;
     ClassDescription * inhcl = NULL;
     <B><FONT color="#000080">for</FONT></B>(<B><FONT color="#000080">int</FONT></B> ii = <FONT color="#800000">0</FONT>; ii &lt; inherited_order.size();ii++)
     {
         inhcl = InheritedClassDescription(inherited_order[ii]);
         ndat = DataDesc(inherited_order[ii]);
         <B><FONT color="#000080">if</FONT></B>(ndat != NULL)
         {
             inhcl-&gt;PopThis();
         }
         <B><FONT color="#000080">else</FONT></B>
         {
             <I><FONT color="#008080">// error ambiguious name</FONT></I>
             pidat-&gt;ShowError(Errors::AMBIGUIOUS_MEMBER);
             <B><FONT color="#000080">break</FONT></B>;
         }
     }
 }
 
 ClassMethod * ClassDescription::InheritedClassMethod(string & nam)
 {
     ClassMethod* ndat[<FONT color="#800000">5</FONT>];
     ClassDescription * inhcl = NULL;
     <B><FONT color="#000080">int</FONT></B> indix = <FONT color="#800000">0</FONT>;
     <B><FONT color="#000080">char</FONT></B> ttxt[<FONT color="#800000">100</FONT>];
     ndat[<FONT color="#800000">0</FONT>] = NULL;

     <B><FONT color="#000080">for</FONT></B>(<B><FONT color="#000080">int</FONT></B> ii = <FONT color="#800000">0</FONT>; ii &lt; inherited_order.size();ii++)
     {
         inhcl = InheritedClassDescription(inherited_order[ii]);
         <B><FONT color="#000080">if</FONT></B>(inhcl != NULL)
         {
             sprintf(ttxt, <FONT color="#800000">"found inherited cd %s %lx in InheritedClassMethod() (search for %s)"</FONT>, 
                 inhcl-&gt;Name().c_str(), inhcl, nam.c_str());
             pidat-&gt;DebugTrace(ttxt);

             ndat[indix] = inhcl-&gt;MethodDesc(nam);

             <B><FONT color="#000080">if</FONT></B>(ndat[indix] != NULL)
             {
                 sprintf(ttxt, <FONT color="#800000">"Found method in inherited %s"</FONT>, ndat[indix]-&gt;Name().c_str());
                 pidat-&gt;DebugTrace(ttxt);
                 indix++;
                 <B><FONT color="#000080">if</FONT></B>(indix &gt; <FONT color="#800000">4</FONT>)
                 {
                   <B><FONT color="#000080">break</FONT></B>;
                 }
             }
         }
         <B><FONT color="#000080">else</FONT></B>
         {
             pidat-&gt;DebugTrace(<FONT color="#800000">"NULL from InheritedClassDescription(inherited_order[ii])"</FONT>);
             <I><FONT color="#008080">// fatal error</FONT></I>
         }
     }

     <B><FONT color="#000080">if</FONT></B>(indix &gt; <FONT color="#800000">1</FONT>)
     {
         sprintf(ttxt, <FONT color="#800000">"ambiuguious method name %s"</FONT>, ndat[indix]-&gt;Name().c_str());
         pidat-&gt;DebugTrace(ttxt);
         <I><FONT color="#008080">// error ambiguious name</FONT></I>
         pidat-&gt;ShowError(Errors::AMBIGUIOUS_MEMBER, nam);
     }

     <B><FONT color="#000080">return</FONT></B>(ndat[<FONT color="#800000">0</FONT>]);
 }
 
 <B><FONT color="#000080">void</FONT></B> ClassDescription::CallDestructor(<B><FONT color="#000080">void</FONT></B>)
 {
     string gn;
     gn.reserve(<FONT color="#800000">512</FONT>);
     gn = <FONT color="#800000">"~"</FONT>;
     gn += Name();
     ClassDescription * inhcl = NULL;
     <B><FONT color="#000080">int</FONT></B> kk = inherited_order.size() - <FONT color="#800000">1</FONT>;
     ClassMethod * pm = NULL;
     
     <B><FONT color="#000080">char</FONT></B> * tt = (<B><FONT color="#000080">char</FONT></B> *) pidat-&gt;PopD();
     <B><FONT color="#000080">if</FONT></B>(tt != NULL)
     {
         PushThis(tt);
         
         <B><FONT color="#000080">for</FONT></B>(<B><FONT color="#000080">int</FONT></B> ii = kk; ii &gt;= <FONT color="#800000">0</FONT>;ii--)
         {
             inhcl = InheritedClassDescription(inherited_order[ii]);
             <B><FONT color="#000080">if</FONT></B>(inhcl != NULL)
             {
                 pidat-&gt;PushD((<B><FONT color="#000080">long</FONT></B>)inhcl-&gt;ThisFront());
                 inhcl-&gt;CallDestructor();
             }
         }
         PopThis();
         <B><FONT color="#000080">if</FONT></B>((pm = MethodDesc(gn)) != NULL)
         {
             pidat-&gt;PushD((<B><FONT color="#000080">long</FONT></B>)tt);
             pm-&gt;Execute(<FONT color="#800000">0</FONT>, *pidat);
         }
     }
 }

<B><FONT color="#000080">void</FONT></B> ClassDescription::CallConstructor(<B><FONT color="#000080">char</FONT></B> * tt)
 {
     string gn;
     gn.reserve(<FONT color="#800000">512</FONT>);
     gn = Name();
     ClassDescription * inhcl = NULL;
     <B><FONT color="#000080">int</FONT></B> kk = inherited_order.size() - <FONT color="#800000">1</FONT>;
     ClassMethod * pm = NULL;
     <B><FONT color="#000080">char</FONT></B> atxt[<FONT color="#800000">1024</FONT>];
     sprintf(atxt, <FONT color="#800000">"%s Calling constructors for instance %lx"</FONT>, Name().c_str(), tt); 
     pidat-&gt;DebugTrace(atxt);
     
     <B><FONT color="#000080">if</FONT></B>(tt != NULL)
     {
         PushThis(tt);
         <B><FONT color="#000080">for</FONT></B>(<B><FONT color="#000080">int</FONT></B> ii = kk; ii &gt;= <FONT color="#800000">0</FONT>;ii--)
         {
             inhcl = InheritedClassDescription(inherited_order[ii]);
             <B><FONT color="#000080">if</FONT></B>(inhcl != NULL)
             {
                 <B><FONT color="#000080">char</FONT></B> * nn = inhcl-&gt;ThisFront();
                 sprintf(atxt, <FONT color="#800000">"%s inherited a constructor for %s at %lx"</FONT>, Name().c_str(), inhcl-&gt;Name().c_str(), nn); 
                 pidat-&gt;DebugTrace(atxt);
                 inhcl-&gt;CallConstructor(nn);
             }
         }
         PopThis();

         map&lt;string, ClassMethod, less&lt;string&gt; &gt;::iterator jj;
         jj = methods.find(name);
      
         <B><FONT color="#000080">if</FONT></B>(jj == methods.end())
         {
             sprintf(atxt, <FONT color="#800000">"%s instance NULL constructor"</FONT>, name.c_str()); 
             pidat-&gt;DebugTrace(atxt);            
         }
         <B><FONT color="#000080">else</FONT></B>
         { 
             pm = &(*jj).second;
             pidat-&gt;PushD((<B><FONT color="#000080">long</FONT></B>)tt);
             sprintf(atxt, <FONT color="#800000">" %s instance %lx executing method %s"</FONT>, name.c_str(), tt, pm-&gt;Name().c_str()); 
             pidat-&gt;DebugTrace(atxt);
             pm-&gt;Execute(<FONT color="#800000">0</FONT>, *pidat);
         }
     }
 }


<I><FONT color="#008080">// ---------------Primitives---------------------------</FONT></I>


<I><FONT color="#008080">// Function name    : Primitives::L_plus</FONT></I>
<I><FONT color="#008080">// Description      : ( a b -- a+b )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_plus(InterpreterData & idat)
 {
   <B><FONT color="#000080">long</FONT></B> aa = idat.PopD();
   <B><FONT color="#000080">long</FONT></B> bb = idat.PopD();
   idat.PushD(aa + bb);
 }


<I><FONT color="#008080">// Function name    : Primitives::L_minus</FONT></I>
<I><FONT color="#008080">// Description      : ( b a -- a-b )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_minus(InterpreterData & idat)
 {
   <B><FONT color="#000080">long</FONT></B> aa = idat.PopD();
   <B><FONT color="#000080">long</FONT></B> bb = idat.PopD();
   idat.PushD(bb - aa);
 }

<B><FONT color="#000080">void</FONT></B> Primitives::L_runif(InterpreterData & idat)
{
    <B><FONT color="#000080">int</FONT></B> tind = idat.PopD();
    <I><FONT color="#008080">//      sprintf(twom, "stack in if poped tind %li", tind);</FONT></I>
    <I><FONT color="#008080">//      idat.DebugTrace(twom);</FONT></I>
    <B><FONT color="#000080">int</FONT></B> eind = idat.PopD();
    <I><FONT color="#008080">//      sprintf(twom, "stack in if poped eind %li", eind);</FONT></I>
    <I><FONT color="#008080">//      idat.DebugTrace(twom);</FONT></I>
    <B><FONT color="#000080">long</FONT></B> aa = idat.PopD();
    <I><FONT color="#008080">//      sprintf(twom, "stack in if poped testv %li", aa);</FONT></I>
    <I><FONT color="#008080">//      idat.DebugTrace(twom);</FONT></I>
    <B><FONT color="#000080">if</FONT></B>(aa != <FONT color="#800000">0</FONT>)
    {
        <B><FONT color="#000080">return</FONT></B>;
    }
    RSData ar = idat.GetRsv(<FONT color="#800000">0</FONT>);
    <B><FONT color="#000080">if</FONT></B>(eind &lt; tind && eind &gt; <FONT color="#800000">0</FONT>)
    {
        <I><FONT color="#008080">//        sprintf(twom, "if's  eind &lt; tind && eind &gt; 0 go to (else)ind");</FONT></I>
        <I><FONT color="#008080">//        idat.DebugTrace(twom);</FONT></I>
        ar.SetIndex(eind); 
        idat.SetRsv(ar, <FONT color="#800000">0</FONT>);
    }
    <B><FONT color="#000080">else</FONT></B>
    {
        <B><FONT color="#000080">if</FONT></B>(tind &gt; <FONT color="#800000">0</FONT>)
        {
            <I><FONT color="#008080">//          sprintf(twom, "if's tind &gt; 0 go to (then)ind");</FONT></I>
            <I><FONT color="#008080">//          idat.DebugTrace(twom);</FONT></I>
            
            ar.SetIndex(tind);    <I><FONT color="#008080">// index set to then</FONT></I>
            idat.SetRsv(ar, <FONT color="#800000">0</FONT>);
        }
    }
}

<I><FONT color="#008080">// Function name    : Primitives::L_if</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">//    When called the current word is if and word second</FONT></I>
<I><FONT color="#008080">//    on the return stack is the word with the if .. then</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>

<B><FONT color="#000080">void</FONT></B> Primitives::L_if(InterpreterData & idat)
 {
<I><FONT color="#008080">//   char twom[60];     </FONT></I>
   
   <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
   {
      idat.BuildAddElement((<B><FONT color="#000080">long</FONT></B>) -<FONT color="#800000">1</FONT>);           <I><FONT color="#008080">// for else index</FONT></I>
      idat.BuildAddElement((<B><FONT color="#000080">long</FONT></B>) -<FONT color="#800000">1</FONT>);           <I><FONT color="#008080">// for then index</FONT></I>
      Word *fif;
      string Bif = <FONT color="#800000">"runif"</FONT>;
      fif = idat.IDict()-&gt;Address(Bif);
      idat.BuildAddElement(fif);
      <B><FONT color="#000080">long</FONT></B> ee = idat.BuildLastUsedElement();   
<I><FONT color="#008080">//      sprintf(twom, "ADPush two 'if' index = %li", ee);</FONT></I>
<I><FONT color="#008080">//      idat.DebugTrace(twom);      </FONT></I>
      idat.PushLabeledAD((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>) fif, ee);
<I><FONT color="#008080">//      sprintf(twom, "ADPush two 'else' index = %li", -1);</FONT></I>
<I><FONT color="#008080">//      idat.DebugTrace(twom);      </FONT></I>
      idat.PushLabeledAD(<FONT color="#800000">"runelse"</FONT>, -<FONT color="#800000">1</FONT>);
   }
   <B><FONT color="#000080">else</FONT></B>
   {
      <B><FONT color="#000080">int</FONT></B> tind = idat.PopD();
<I><FONT color="#008080">//      sprintf(twom, "stack in if poped tind %li", tind);</FONT></I>
<I><FONT color="#008080">//      idat.DebugTrace(twom);</FONT></I>
      <B><FONT color="#000080">int</FONT></B> eind = idat.PopD();
<I><FONT color="#008080">//      sprintf(twom, "stack in if poped eind %li", eind);</FONT></I>
<I><FONT color="#008080">//      idat.DebugTrace(twom);</FONT></I>
      <B><FONT color="#000080">long</FONT></B> aa = idat.PopD();
<I><FONT color="#008080">//      sprintf(twom, "stack in if poped testv %li", aa);</FONT></I>
<I><FONT color="#008080">//      idat.DebugTrace(twom);</FONT></I>
      <B><FONT color="#000080">if</FONT></B>(aa != <FONT color="#800000">0</FONT>)
      {
         <B><FONT color="#000080">return</FONT></B>;
      }
      RSData ar = idat.GetRsv(<FONT color="#800000">0</FONT>);
      <B><FONT color="#000080">if</FONT></B>(eind &lt; tind && eind &gt; <FONT color="#800000">0</FONT>)
      {
<I><FONT color="#008080">//        sprintf(twom, "if's  eind &lt; tind && eind &gt; 0 go to (else)ind");</FONT></I>
<I><FONT color="#008080">//        idat.DebugTrace(twom);</FONT></I>
        ar.SetIndex(eind); 
        idat.SetRsv(ar, <FONT color="#800000">0</FONT>);
      }
      <B><FONT color="#000080">else</FONT></B>
      {
        <B><FONT color="#000080">if</FONT></B>(tind &gt; <FONT color="#800000">0</FONT>)
        {
<I><FONT color="#008080">//          sprintf(twom, "if's tind &gt; 0 go to (then)ind");</FONT></I>
<I><FONT color="#008080">//          idat.DebugTrace(twom);</FONT></I>

          ar.SetIndex(tind);    <I><FONT color="#008080">// index set to then</FONT></I>
          idat.SetRsv(ar, <FONT color="#800000">0</FONT>);
        }
      }
   }
 }

<I><FONT color="#008080">// Function name    : Primitives::L_else</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_runelse(InterpreterData & idat)
{
       <B><FONT color="#000080">int</FONT></B> tind = idat.PopD();
       RSData ar = idat.GetRsv(<FONT color="#800000">0</FONT>);
       ar.SetIndex(tind); 
       idat.SetRsv(ar, <FONT color="#800000">0</FONT>);  
}

<I><FONT color="#008080">// Function name    : Primitives::L_else</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_else(InterpreterData & idat)
 {
   <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
   {
      idat.PopLabeledAD();
      <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> ifi = idat.PopLabeledAD();  
      <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> ifeind = ifi - <FONT color="#800000">2</FONT>;

      idat.PushLabeledAD(<FONT color="#800000">"runif"</FONT>, ifi);

      idat.BuildAddElement((<B><FONT color="#000080">long</FONT></B>) -<FONT color="#800000">1</FONT>);   <I><FONT color="#008080">// for then index </FONT></I>
      
      string Belse = <FONT color="#800000">"runelse"</FONT>;
      Word *felse = idat.IDict()-&gt;Address(Belse);
      idat.BuildAddElement(felse);
      <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> ee = idat.BuildLastUsedElement();           <I><FONT color="#008080">// testing</FONT></I>
      idat.Building()-&gt;SetLiteralValue(ifeind, &ee);
      idat.PushLabeledAD(<FONT color="#800000">"runelse"</FONT>, ee);
   }
   <B><FONT color="#000080">else</FONT></B>
   {
       <B><FONT color="#000080">int</FONT></B> tind = idat.PopD();
       RSData ar = idat.GetRsv(<FONT color="#800000">0</FONT>);
       ar.SetIndex(tind); 
       idat.SetRsv(ar, <FONT color="#800000">0</FONT>);
   }
 }


<I><FONT color="#008080">// Function name    : Primitives::L_nop</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_nop(InterpreterData & idat)
 {
   <B><FONT color="#000080">int</FONT></B> nn = <FONT color="#800000">1</FONT>;  <I><FONT color="#008080">// nop</FONT></I>
 }

<I><FONT color="#008080">// Function name    : Primitives::L_then</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_runthen(InterpreterData & idat)
{
 ;  
}

<I><FONT color="#008080">// Function name    : Primitives::L_then</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_then(InterpreterData & idat)
 {
<I><FONT color="#008080">//  char twom[60];     </FONT></I>

   <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
   {
      <B><FONT color="#000080">long</FONT></B> elsei = idat.PopLabeledAD() - <FONT color="#800000">1</FONT>;        <I><FONT color="#008080">// else index - 1</FONT></I>
      <B><FONT color="#000080">long</FONT></B> ifi = idat.PopLabeledAD() - <FONT color="#800000">1</FONT>;          <I><FONT color="#008080">// if index - 1</FONT></I>

<I><FONT color="#008080">//      sprintf(twom, "PolLAD then of 'else' index = %li", elsei);</FONT></I>
<I><FONT color="#008080">//      idat.DebugTrace(twom);         </FONT></I>
<I><FONT color="#008080">//      sprintf(twom, "PolLAD then of 'if' index = %li", ifi);</FONT></I>
<I><FONT color="#008080">//      idat.DebugTrace(twom);    </FONT></I>

      string Bthen = <FONT color="#800000">"runthen"</FONT>;
      Word *fthen = idat.IDict()-&gt;Address(Bthen);

      idat.BuildAddElement(fthen);
      <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> ee = idat.BuildLastUsedElement();

<I><FONT color="#008080">//      sprintf(twom, "PolLAD then found ifi index = %li", ee);</FONT></I>
<I><FONT color="#008080">//      idat.DebugTrace(twom);         </FONT></I>

      idat.Building()-&gt;SetLiteralValue(ifi, &ee);
      <B><FONT color="#000080">if</FONT></B>(elsei &gt; <FONT color="#800000">1</FONT>)
      {
        idat.Building()-&gt;SetLiteralValue(elsei, &ee);
      }
   }
 }

<I><FONT color="#008080">// Function name    : Primitives::L_colon</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_colon(InterpreterData & idat)
{
  string awrd;
  Parser * par = idat.IParser();
  <B><FONT color="#000080">char</FONT></B> * wrd;

  <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
  {
     <I><FONT color="#008080">// already compiling a new word error</FONT></I>

      <B><FONT color="#000080">return</FONT></B>;
  }

  <B><FONT color="#000080">if</FONT></B>((wrd = par-&gt;NextWord()) != NULL)
  {
     awrd = wrd;
     <B><FONT color="#000080">if</FONT></B>(idat.IDict()-&gt;Exists(awrd) == -<FONT color="#800000">1</FONT>)  <I><FONT color="#008080">// word does not exist</FONT></I>
     {
       <B><FONT color="#000080">if</FONT></B>(!par-&gt;AllDigits(wrd))  <I><FONT color="#008080">// word is not a number</FONT></I>
       {
         idat.BuildWithName(awrd);
         idat.Compile();
       }
       <B><FONT color="#000080">else</FONT></B>
       {
          <I><FONT color="#008080">// trying to name a word with a number error</FONT></I>
          idat.ShowError(Errors::IS_NUMBER);
       }
     }
     <B><FONT color="#000080">else</FONT></B>
     {
        <I><FONT color="#008080">// word already exists error</FONT></I>
        idat.ShowError(Errors::WORD_EXISTS , awrd);
     }
  } 
  <B><FONT color="#000080">else</FONT></B>
  {
      <I><FONT color="#008080">// buffer end reached</FONT></I>
      idat.ShowError(Errors::BUFFER_END);
  }
}


<I><FONT color="#008080">// Function name    : Primitives::L_semicolon</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_semicolon(InterpreterData & idat)
{
 <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
  {
    idat.EndCompile();
    idat.BuildFinishWord();
  }
 <B><FONT color="#000080">else</FONT></B>
 {
    <I><FONT color="#008080">// Show Error 1 Syntax error</FONT></I>
     idat.ShowError(Errors::SYNTAX_ERROR);
 }
}


<I><FONT color="#008080">// Function name    : Primitives::L_quote</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_quote(InterpreterData & idat)
{
 string *textliteral = NULL;
 Parser * par = idat.IParser(); 

 <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
  {
    textliteral = <B><FONT color="#000080">new</FONT></B> string();
    textliteral-&gt;reserve(<FONT color="#800000">200</FONT>);

    <B><FONT color="#000080">if</FONT></B>(par-&gt;GetAny(*textliteral, false, <FONT color="#800000">'"'</FONT>))
    {
        idat.BuildAddElement(textliteral);
        par-&gt;Advance();
    }
    <B><FONT color="#000080">else</FONT></B>  <I><FONT color="#008080">// no trailing quote</FONT></I>
    {
        <I><FONT color="#008080">// Show Error 0 no trialing quote </FONT></I>
        <B><FONT color="#000080">delete</FONT></B> textliteral;
        idat.ShowError(Errors::NO_TRAILING_QUOTE);
    } 
  }
 <B><FONT color="#000080">else</FONT></B>
 {
    idat.EmptyTempString();
    <B><FONT color="#000080">if</FONT></B>(par-&gt;GetAny(idat.TempString(), false, <FONT color="#800000">'"'</FONT>))
    {
<I><FONT color="#008080">//      idat.DebugTrace(" L_quote has string"); </FONT></I>
      idat.PushD(&idat.TempString()); 
      par-&gt;Advance();
    }
    <B><FONT color="#000080">else</FONT></B>  <I><FONT color="#008080">// no trailing quote</FONT></I>
    {
        <I><FONT color="#008080">// Show Error 0 no trialing quote </FONT></I>
        idat.ShowError(Errors::NO_TRAILING_QUOTE);
    } 
 }
}


<I><FONT color="#008080">// Function name    : Primitives::L_dotquote</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_dotquote(InterpreterData & idat)
{
 string *textliteral;
 Parser * par = idat.IParser(); 

 <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
  {
    textliteral = <B><FONT color="#000080">new</FONT></B> string();
    textliteral-&gt;reserve(<FONT color="#800000">300</FONT>);

    <B><FONT color="#000080">if</FONT></B>(par-&gt;GetAny(*textliteral, false, <FONT color="#800000">'"'</FONT>))
    {
        idat.BuildAddElement(textliteral);
        par-&gt;Advance();
    }
    <B><FONT color="#000080">else</FONT></B>  <I><FONT color="#008080">// no trailing quote</FONT></I>
    {
        <I><FONT color="#008080">// Show Error 0 no trialing quote </FONT></I>
        idat.ShowError(Errors::NO_TRAILING_QUOTE);
    } 
  }
 <B><FONT color="#000080">else</FONT></B>
 {
   L_printstring(idat); 
 }
}

<I><FONT color="#008080">// Function name    : Primitives::L_dotquote</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_squote(InterpreterData & idat)
{
 string *textliteral;
 Parser * par = idat.IParser(); 

 <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
  {
    textliteral = <B><FONT color="#000080">new</FONT></B> string();
    textliteral-&gt;reserve(<FONT color="#800000">300</FONT>);

    <B><FONT color="#000080">if</FONT></B>(par-&gt;GetAny(*textliteral, false, <FONT color="#800000">'"'</FONT>))  <I><FONT color="#008080">// add room for the 's" '</FONT></I>
    {
        <B><FONT color="#000080">int</FONT></B> sz = textliteral-&gt;size();
        
        <B><FONT color="#000080">void</FONT></B> * vp = idat.MManager().AllocateType(MemInstDat::m_CharArray, (sz + <FONT color="#800000">6</FONT>));
        <B><FONT color="#000080">char</FONT></B> * np = ((((<B><FONT color="#000080">char</FONT></B>*) vp) + <FONT color="#800000">4</FONT>));
        memcpy(np, textliteral-&gt;c_str(), sz);
        np[sz] = <FONT color="#800000">0</FONT>;
        np[sz+<FONT color="#800000">1</FONT>] = <FONT color="#800000">0</FONT>;
        <B><FONT color="#000080">delete</FONT></B> textliteral;
        idat.BuildAddElement((<B><FONT color="#000080">long</FONT></B>)np);
        idat.BuildAddElement((<B><FONT color="#000080">long</FONT></B>)sz);
        par-&gt;Advance();
    }
    <B><FONT color="#000080">else</FONT></B>  <I><FONT color="#008080">// no trailing quote</FONT></I>
    {
        <I><FONT color="#008080">// Show Error 0 no trialing quote </FONT></I>
        idat.ShowError(Errors::NO_TRAILING_QUOTE);
    } 
  }
}

<I><FONT color="#008080">// Function name    : Primitives::L_dotquote</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_cquote(InterpreterData & idat)
{
 string *textliteral;
 Parser * par = idat.IParser(); 

 <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
  {
    textliteral = <B><FONT color="#000080">new</FONT></B> string();
    textliteral-&gt;reserve(<FONT color="#800000">300</FONT>);

    <B><FONT color="#000080">if</FONT></B>(par-&gt;GetAny(*textliteral, false, <FONT color="#800000">'"'</FONT>))  <I><FONT color="#008080">// add room for the 'c" '</FONT></I>
    {
        <B><FONT color="#000080">int</FONT></B> sz = textliteral-&gt;size();
        
        <B><FONT color="#000080">void</FONT></B> * vp = idat.MManager().AllocateType(MemInstDat::m_CharArray, (sz + <FONT color="#800000">6</FONT>));
        <B><FONT color="#000080">char</FONT></B> * np = ((((<B><FONT color="#000080">char</FONT></B>*) vp) + <FONT color="#800000">4</FONT>));
        <B><FONT color="#000080">long</FONT></B> * lp = (<B><FONT color="#000080">long</FONT></B>*) vp;
        *lp = sz;
        memcpy(np, textliteral-&gt;c_str(), sz);
        np[sz] = <FONT color="#800000">0</FONT>;
        <B><FONT color="#000080">delete</FONT></B> textliteral;
        idat.BuildAddElement((<B><FONT color="#000080">long</FONT></B>)vp);
        par-&gt;Advance();
    }
    <B><FONT color="#000080">else</FONT></B>  <I><FONT color="#008080">// no trailing quote</FONT></I>
    {
        <I><FONT color="#008080">// Show Error 0 no trialing quote </FONT></I>
        idat.ShowError(Errors::NO_TRAILING_QUOTE);
    } 
  }
}



<I><FONT color="#008080">// Function name    : Primitives::EndParen</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_Comment(InterpreterData & idat)
{
 string textliteral;

 textliteral.reserve(<FONT color="#800000">200</FONT>);
 Parser * par = idat.IParser(); 

 <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
  {
    <B><FONT color="#000080">if</FONT></B>(!par-&gt;GetAny(textliteral, false, <FONT color="#800000">')'</FONT>))
    {
        idat.ShowError(Errors::NO_CLOSINGPAREN);
    } 
    par-&gt;Advance();
  }
 <B><FONT color="#000080">else</FONT></B>
 {
    <B><FONT color="#000080">if</FONT></B>(!par-&gt;GetAny(textliteral, false, <FONT color="#800000">')'</FONT>))
    {
        idat.ShowError(Errors::NO_CLOSINGPAREN);
    } 
    par-&gt;Advance();
 }
}

<I><FONT color="#008080">// Function name    : Primitives::L_CppComment</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_CppComment(InterpreterData & idat)
{
 Parser * par = idat.IParser(); 

 <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
  {
    <B><FONT color="#000080">if</FONT></B>(!par-&gt;NewLine(false))
    {
        idat.ShowError(Errors::NO_EOL);
    } 
  }
 <B><FONT color="#000080">else</FONT></B>
 {
    <B><FONT color="#000080">if</FONT></B>(!par-&gt;NewLine(false))
    {
        idat.ShowError(Errors::NO_EOL);
    } 
 }
}

<I><FONT color="#008080">// Function name    : Primitives::L_ForthComment</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_ForthComment(InterpreterData & idat)
{
 string textliteral;
 Parser * par = idat.IParser();  

 <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
  {
    <B><FONT color="#000080">if</FONT></B>(!par-&gt;NewLine(false))
    {
        idat.ShowError(Errors::NO_EOL);
    } 
  }
 <B><FONT color="#000080">else</FONT></B>
 {
    <B><FONT color="#000080">if</FONT></B>(!par-&gt;NewLine(false))
    {
        idat.ShowError(Errors::NO_EOL);
    } 
 }
}

<I><FONT color="#008080">// Function name    : Primitives::L_dot</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_dot(InterpreterData & idat)
{
  <B><FONT color="#000080">char</FONT></B> ss[<FONT color="#800000">35</FONT>];
  idat.Out() +=  _ltoa( idat.PopD(), ss, *idat.Base());
  idat.Out() += <FONT color="#800000">" "</FONT>;
  idat.WriteOut();
}

<I><FONT color="#008080">// Function name    : Primitives::L_space</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_space(InterpreterData & idat)
{
  idat.Out() += <FONT color="#800000">" "</FONT>;
  idat.WriteOut();
}

<I><FONT color="#008080">// Function name    : Primitives::L_space</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_spaces(InterpreterData & idat)
{
  <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> s = idat.PopD();
  <B><FONT color="#000080">for</FONT></B>(<B><FONT color="#000080">int</FONT></B> ii = <FONT color="#800000">0</FONT>;ii &lt; s;ii++)
  {
    idat.Out() += <FONT color="#800000">" "</FONT>;
  }
  idat.WriteOut();
}

<I><FONT color="#008080">// Function name    : Primitives::L_udot</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_udot(InterpreterData & idat)
{
  <B><FONT color="#000080">unsigned</FONT></B>  <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> aa = idat.PopD();
  <B><FONT color="#000080">char</FONT></B> ss[<FONT color="#800000">35</FONT>];
 <I><FONT color="#008080">// sprintf(ss," %lu ",aa);</FONT></I>
  idat.Out() += _ultoa(labs(idat.PopD()), ss, *idat.Base());;
  idat.WriteOut();
}

__int64 Primitives::Pop64(InterpreterData & idat)
{
   __int64 aa;
   
   <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> *high = (((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> *)&aa) + <FONT color="#800000">1</FONT>);
   <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> *low = (<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> *)&aa;
   *high = idat.PopD();
   *low = idat.PopD();

   <B><FONT color="#000080">return</FONT></B>(aa);
}

<B><FONT color="#000080">void</FONT></B> Primitives::Push64(<B><FONT color="#000080">unsigned</FONT></B> __int64 vv, InterpreterData & idat)
{
   <B><FONT color="#000080">unsigned</FONT></B> __int64 aa = vv;
   
   <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> *high = (((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> *)&aa) + <FONT color="#800000">1</FONT>);
   <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> *low = (<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> *)&aa;
   
   idat.PushD(((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>) *low));
   idat.PushD(((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>) *high));
}

<I><FONT color="#008080">// Function name    : Primitives::dplus</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_dplus(InterpreterData & idat)
{
  __int64 aa = Pop64(idat);
  __int64 bb = Pop64(idat);
  Push64((aa + bb), idat);
}

<I><FONT color="#008080">// Function name    : Primitives::L_dtwostar</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_dtwostar(InterpreterData & idat)
{
  __int64 aa = Pop64(idat);
  Push64((aa &lt;&lt; <FONT color="#800000">1</FONT>), idat);
}

<I><FONT color="#008080">// Function name    : Primitives::L_dtwoslash</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_dtwoslash(InterpreterData & idat)
{
  __int64 aa = Pop64(idat);
  Push64((aa &gt;&gt; <FONT color="#800000">1</FONT>), idat);
}

<I><FONT color="#008080">// Function name    : Primitives::dplus</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_dnegate(InterpreterData & idat)
{
  __int64 aa = -Pop64(idat);
  Push64(aa, idat);
}

<I><FONT color="#008080">// Function name    : Primitives::L_dzeroless</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_dzeroless(InterpreterData & idat)
{
  __int64 aa = Pop64(idat);
  <B><FONT color="#000080">if</FONT></B>(aa &lt; ((__int64)0l))
  {
    idat.PushD(-<FONT color="#800000">1</FONT>);
  }
  <B><FONT color="#000080">else</FONT></B>
  {
    idat.PushD(0l);
  }
}

<I><FONT color="#008080">// Function name    : Primitives::L_dmax</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_dmax(InterpreterData & idat)
{
  __int64 aa = Pop64(idat);
  __int64 bb = Pop64(idat);

  <B><FONT color="#000080">if</FONT></B>(aa &lt; bb)
  {
    Push64(bb, idat);
  }
  <B><FONT color="#000080">else</FONT></B>
  {
    Push64(aa, idat);
  }
}

<I><FONT color="#008080">// Function name    : Primitives::L_dmin</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_dmin(InterpreterData & idat)
{
  __int64 aa = Pop64(idat);
  __int64 bb = Pop64(idat);

  <B><FONT color="#000080">if</FONT></B>(aa &lt; bb)
  {
    Push64(aa, idat);
  }
  <B><FONT color="#000080">else</FONT></B>
  {
    Push64(bb, idat);
  }
}

<I><FONT color="#008080">// Function name    : Primitives::L_dzeroequal</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_dzeroequal(InterpreterData & idat)
{
  __int64 aa = Pop64(idat);
  <B><FONT color="#000080">if</FONT></B>(aa &lt; ((__int64)0l))
  {
    idat.PushD(-<FONT color="#800000">1</FONT>);
  }
  <B><FONT color="#000080">else</FONT></B>
  {
    idat.PushD(0l);
  }
}

<I><FONT color="#008080">// Function name    : Primitives::dminus</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_dminus(InterpreterData & idat)
{
  __int64 aa = Pop64(idat);
  __int64 bb = Pop64(idat);
  Push64((bb - <FONT color="#800000">11</FONT>), idat);
}

<I><FONT color="#008080">// Function name    : Primitives::L_sgreaterd</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_sTod(InterpreterData & idat)
{
  __int64 aa = (__int64 ) idat.PopD();

 <I><FONT color="#008080">// sprintf(ss," %lu ",aa);</FONT></I>
 idat.PushD(*((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> *)&aa));
 idat.PushD(*(((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> *)&aa) + <FONT color="#800000">1</FONT>));
}

<I><FONT color="#008080">// Function name    : Primitives:L_umtimes</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_mtimes(InterpreterData & idat)
{
   <B><FONT color="#000080">unsigned</FONT></B> __int64 aa = (__int64 )idat.PopD();
   <B><FONT color="#000080">unsigned</FONT></B> __int64 bb = (__int64 )idat.PopD();
   <B><FONT color="#000080">unsigned</FONT></B> __int64 cc = aa * bb;

   Push64(cc, idat);
}

<I><FONT color="#008080">// Function name    : Primitives:L_mtimes</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_umtimes(InterpreterData & idat)
{
 <B><FONT color="#000080">unsigned</FONT></B> __int64 aa = (__int64 )idat.PopD();
 <B><FONT color="#000080">unsigned</FONT></B> __int64 bb = (__int64 )idat.PopD();
 <B><FONT color="#000080">unsigned</FONT></B> __int64 cc = aa * bb;

 Push64(cc, idat);
}

<I><FONT color="#008080">// Function name    : Primitives:L_smslashrem</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_umslashmod(InterpreterData & idat)
{
   <B><FONT color="#000080">unsigned</FONT></B> __int64 divi = (__int64 )idat.PopD();
   <B><FONT color="#000080">unsigned</FONT></B> __int64 tg = Pop64(idat);
   <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> q = (<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>) (tg / divi);
   <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> m = (<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>) (tg % divi);

 idat.PushD(m);
 idat.PushD(q);
}

<I><FONT color="#008080">// Function name    : Primitives:L_smslashrem</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_smslashrem(InterpreterData & idat)
{
   __int64 divi = (__int64 )idat.PopD();
   __int64 tg = Pop64(idat);
   __int64 q = tg / divi;
   __int64 m = tg % divi;

 idat.PushD((<B><FONT color="#000080">long</FONT></B>)m);
 idat.PushD((<B><FONT color="#000080">long</FONT></B>)q);
}

<I><FONT color="#008080">// Function name    : Primitives:L_fmslashmod</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_fmslashmod(InterpreterData & idat)
{
   __int64 divi = (__int64 )idat.PopD();
   __int64 tg = Pop64(idat);
   __int64 q = tg / divi;
   __int64 m = tg % divi;
   <B><FONT color="#000080">if</FONT></B>(m != (__int64)<FONT color="#800000">0</FONT>)
   {
      <B><FONT color="#000080">if</FONT></B>((tg &gt; ((__int64)<FONT color="#800000">0</FONT>)))
      {
          <B><FONT color="#000080">if</FONT></B>(divi &lt; ((__int64)<FONT color="#800000">0</FONT>))
          {
             m =  (((__int64)-<FONT color="#800000">1</FONT>) - m); 
             q -= ((__int64)<FONT color="#800000">1.0</FONT>);
          }
      }
      <B><FONT color="#000080">else</FONT></B>
      {
          <B><FONT color="#000080">if</FONT></B>(divi &gt; ((__int64)<FONT color="#800000">0</FONT>))
          {
            q -= ((__int64)<FONT color="#800000">1.0</FONT>);
            m = (((__int64)<FONT color="#800000">1</FONT>) - m); 
          }
      }
   }

 <I><FONT color="#008080">// sprintf(ss," %lu ",aa);</FONT></I>
 idat.PushD((<B><FONT color="#000080">long</FONT></B>)m);
 idat.PushD((<B><FONT color="#000080">long</FONT></B>)q);
}



<I><FONT color="#008080">// Function name    : Primitives::L_emit</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_emit(InterpreterData & idat)
{
  <B><FONT color="#000080">long</FONT></B> aa = idat.PopD();
  <B><FONT color="#000080">char</FONT></B> ss[<FONT color="#800000">25</FONT>];
  sprintf(ss,<FONT color="#800000">" %c "</FONT>,aa);
  idat.Out() += ss;
  idat.WriteOut();
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_CR(InterpreterData & idat)
{
  idat.LineOut();
}

<I><FONT color="#008080">// Function name    : Primitives::L_printstring</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_printstring(InterpreterData & idat)
{
  string *ss = (string *) ((<B><FONT color="#000080">void</FONT></B> *) idat.PopD());
  idat.DebugString(ss-&gt;c_str());
  idat.Out() += (*ss);
  idat.WriteOut();
}


<I><FONT color="#008080">// Function name    : Primitives::L_begin</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_runbegin(InterpreterData & idat)
{
 ;
}

<I><FONT color="#008080">// Function name    : Primitives::L_begin</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_begin(InterpreterData & idat)
{
  <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
  {  
      Word *fbegin;
      string Blook = <FONT color="#800000">"runbegin"</FONT>;
      fbegin = idat.IDict()-&gt;Address(Blook);
      idat.BuildAddElement(fbegin);
      <B><FONT color="#000080">long</FONT></B> ee = idat.BuildLastUsedElement();           
      idat.PushLabeledAD((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>)fbegin, ee);
  }
}

<I><FONT color="#008080">// Function name    : Primitives::L_rununtil</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_rununtil(InterpreterData & idat)
{
      <B><FONT color="#000080">long</FONT></B> jb = idat.PopD();   <I><FONT color="#008080">// index to return to</FONT></I>
      <B><FONT color="#000080">long</FONT></B> sv = idat.PopD();   <I><FONT color="#008080">// test </FONT></I>
      <B><FONT color="#000080">if</FONT></B>(sv == <FONT color="#800000">0</FONT>)
      {
          RSData ar = idat.GetRsv(<FONT color="#800000">0</FONT>);
          ar.SetIndex(jb); 
          idat.SetRsv(ar, <FONT color="#800000">0</FONT>);
      }
}

<I><FONT color="#008080">// Function name    : Primitives::L_until</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_until(InterpreterData & idat)
{
    <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
    {    
      Word *funtil;
      string Ulook = <FONT color="#800000">"rununtil"</FONT>;
      <B><FONT color="#000080">int</FONT></B> bnd;

      funtil = idat.IDict()-&gt;Address(Ulook);
      bnd = idat.PopLabeledAD();
      <B><FONT color="#000080">if</FONT></B>(bnd &gt;= <FONT color="#800000">0</FONT>)
      {
             idat.BuildAddElement((<B><FONT color="#000080">long</FONT></B>)bnd);
             idat.BuildAddElement(funtil);
      }
      <B><FONT color="#000080">else</FONT></B>
      {
             idat.ShowError(Errors::NO_BEGIN); 
      }
    }
    <B><FONT color="#000080">else</FONT></B>
    {
      <B><FONT color="#000080">long</FONT></B> jb = idat.PopD();   <I><FONT color="#008080">// index to return to</FONT></I>
      <B><FONT color="#000080">long</FONT></B> sv = idat.PopD();   <I><FONT color="#008080">// test </FONT></I>
      <B><FONT color="#000080">if</FONT></B>(sv == <FONT color="#800000">0</FONT>)
      {
          RSData ar = idat.GetRsv(<FONT color="#800000">0</FONT>);
          ar.SetIndex(jb); 
          idat.SetRsv(ar, <FONT color="#800000">0</FONT>);
      }
    }
}

<I><FONT color="#008080">// Function name    : Primitives::L_runwhile</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_runwhile(InterpreterData & idat)
{
     <B><FONT color="#000080">long</FONT></B> jb = idat.PopD();   <I><FONT color="#008080">// index of repeat</FONT></I>
      <B><FONT color="#000080">long</FONT></B> sv = idat.PopD();   <I><FONT color="#008080">// test </FONT></I>
      <B><FONT color="#000080">if</FONT></B>(sv == false)
      {
          RSData ar = idat.GetRsv(<FONT color="#800000">0</FONT>);
          ar.SetIndex(jb); 
          idat.SetRsv(ar, <FONT color="#800000">0</FONT>);
      }
}

<I><FONT color="#008080">// Function name    : Primitives::L_while</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_while(InterpreterData & idat)
{
    <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
    {    
      Word *fwhile = idat.IDict()-&gt;Address(<FONT color="#800000">"runwhile"</FONT>);
      <B><FONT color="#000080">int</FONT></B> bnd = idat.PeekLabeledAD();

      <B><FONT color="#000080">if</FONT></B>(bnd &gt;= <FONT color="#800000">0</FONT>)
      {
             idat.BuildAddElement((<B><FONT color="#000080">long</FONT></B>)bnd);     <I><FONT color="#008080">// for repeat</FONT></I>
             idat.BuildAddElement(fwhile);
             <B><FONT color="#000080">long</FONT></B> ee = idat.BuildLastUsedElement();           
             idat.PushLabeledAD((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>)fwhile, ee);
      }
      <B><FONT color="#000080">else</FONT></B>
      {
             idat.ShowError(Errors::NO_BEGIN); 
      }
    }
    <B><FONT color="#000080">else</FONT></B>
    {
      <B><FONT color="#000080">long</FONT></B> jb = idat.PopD();   <I><FONT color="#008080">// index of repeat</FONT></I>
      <B><FONT color="#000080">long</FONT></B> sv = idat.PopD();   <I><FONT color="#008080">// test </FONT></I>
      <B><FONT color="#000080">if</FONT></B>(sv == false)
      {
          RSData ar = idat.GetRsv(<FONT color="#800000">0</FONT>);
          ar.SetIndex(jb); 
          idat.SetRsv(ar, <FONT color="#800000">0</FONT>);
      }
    }
}

<I><FONT color="#008080">// Function name    : Primitives::L_repeat</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_runrepeat(InterpreterData & idat)
{
     <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> jb = idat.PopD();   <I><FONT color="#008080">// index to 'begin'</FONT></I>
     RSData ar = idat.GetRsv(<FONT color="#800000">0</FONT>);
     ar.SetIndex(jb); 
     idat.SetRsv(ar, <FONT color="#800000">0</FONT>);
}

<I><FONT color="#008080">// Function name    : Primitives::L_repeat</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_repeat(InterpreterData & idat)
{
    <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
    {    
      Word *frepeat = idat.IDict()-&gt;Address(<FONT color="#800000">"runrepeat"</FONT>);
      <B><FONT color="#000080">int</FONT></B> whi = idat.PopLabeledAD();
      <B><FONT color="#000080">int</FONT></B> bnd = idat.PopLabeledAD();
      
      <B><FONT color="#000080">if</FONT></B>(bnd &gt;= <FONT color="#800000">0</FONT>)
      {
             idat.BuildAddElement((<B><FONT color="#000080">long</FONT></B>)bnd);
             idat.BuildAddElement(frepeat);
             <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> ee = idat.BuildLastUsedElement();  
             idat.Building()-&gt;SetLiteralValue(whi - <FONT color="#800000">1</FONT>, &ee);
      }
      <B><FONT color="#000080">else</FONT></B>
      {
             idat.ShowError(Errors::NO_BEGIN); 
      }
    }
    <B><FONT color="#000080">else</FONT></B>
    {
      <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> jb = idat.PopD();   <I><FONT color="#008080">// index to 'begin'</FONT></I>
      RSData ar = idat.GetRsv(<FONT color="#800000">0</FONT>);
      ar.SetIndex(jb); 
      idat.SetRsv(ar, <FONT color="#800000">0</FONT>);
    }
}

<I><FONT color="#008080">// Function name    : Primitives::L_again</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_runagain(InterpreterData & idat)
{
     <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> jb = idat.PopD();   <I><FONT color="#008080">// index to 'begin'</FONT></I>
     RSData ar = idat.GetRsv(<FONT color="#800000">0</FONT>);
     ar.SetIndex(jb); 
     idat.SetRsv(ar, <FONT color="#800000">0</FONT>);
}

<I><FONT color="#008080">// Function name    : Primitives::L_again</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_again(InterpreterData & idat)
{
    <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
    {    
      Word *fagain = idat.IDict()-&gt;Address(<FONT color="#800000">"runagain"</FONT>);
      <B><FONT color="#000080">int</FONT></B> bnd = idat.PopLabeledAD();
      
      <B><FONT color="#000080">if</FONT></B>(bnd &gt;= <FONT color="#800000">0</FONT>)
      {
             idat.BuildAddElement((<B><FONT color="#000080">long</FONT></B>)bnd);
             idat.BuildAddElement(fagain);
      }
      <B><FONT color="#000080">else</FONT></B>
      {
             idat.ShowError(Errors::NO_BEGIN); 
      }
    }
    <B><FONT color="#000080">else</FONT></B>
    {
      <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> jb = idat.PopD();   <I><FONT color="#008080">// index to 'begin'</FONT></I>
      RSData ar = idat.GetRsv(<FONT color="#800000">0</FONT>);
      ar.SetIndex(jb); 
      idat.SetRsv(ar, <FONT color="#800000">0</FONT>);
    }
}

<I><FONT color="#008080">// Function name    : Primitives::L_questiondup</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_questiondup(InterpreterData & idat)
{
  <B><FONT color="#000080">long</FONT></B> aa = idat.PopD();
  <B><FONT color="#000080">if</FONT></B>(aa)
  {
    idat.PushD(aa);
    idat.PushD(aa);
  }
  <B><FONT color="#000080">else</FONT></B>
  {
    idat.PushD(aa);
  }
}


<I><FONT color="#008080">// Function name    : Primitives::L_dup</FONT></I>
<I><FONT color="#008080">// Description      : ( a -- a a )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_dup(InterpreterData & idat)
{
  <B><FONT color="#000080">long</FONT></B> aa = idat.PopD();
  idat.PushD(aa);
  idat.PushD(aa);
}

<I><FONT color="#008080">// Function name    : Primitives::L_swap</FONT></I>
<I><FONT color="#008080">// Description      : ( a b -- b a )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_swap(InterpreterData & idat)
{
  <B><FONT color="#000080">long</FONT></B> aa = idat.PopD();
  <B><FONT color="#000080">long</FONT></B> bb = idat.PopD();
  idat.PushD(aa);
  idat.PushD(bb);
}

<I><FONT color="#008080">// Function name    : Primitives::L_questionrundo</FONT></I>
<I><FONT color="#008080">// Description      : ( start limit -- )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_runquestiondo(InterpreterData & idat)
{
       <B><FONT color="#000080">long</FONT></B> *pind = (<B><FONT color="#000080">long</FONT></B> *) idat.PopD();              <I><FONT color="#008080">// get pushed addresses</FONT></I>
       <B><FONT color="#000080">long</FONT></B> *plim = (<B><FONT color="#000080">long</FONT></B> *) idat.PopD();              <I><FONT color="#008080">// either keys of index limit</FONT></I>
       <B><FONT color="#000080">long</FONT></B> lind = idat.PopD();                        <I><FONT color="#008080">// index of "loop or +loop"</FONT></I>
       <B><FONT color="#000080">if</FONT></B>((*plim) == <FONT color="#800000">1234567</FONT> && (*pind) == <FONT color="#800000">1234567</FONT>)    <I><FONT color="#008080">// if they are keys first loop</FONT></I>
       {
          *pind = idat.PopD();                         <I><FONT color="#008080">// set to index</FONT></I>
          *plim = idat.PopD();                         <I><FONT color="#008080">// set to limit </FONT></I>
          <B><FONT color="#000080">if</FONT></B>((*pind) == (*plim))                       <I><FONT color="#008080">// if equal we jump to "loop or +loop"</FONT></I>
          {                                            
            RSData ar = idat.GetRsv(<FONT color="#800000">0</FONT>);
            Word *wn = ar.Code();
            <B><FONT color="#000080">if</FONT></B>(wn-&gt;SameWord(lind, <FONT color="#800000">"runloop"</FONT>, idat))
            {
               ar.SetIndex((lind - <FONT color="#800000">2</FONT>));   <I><FONT color="#008080">// loop</FONT></I>
            }
            <B><FONT color="#000080">else</FONT></B>
            {
               ar.SetIndex((lind - <FONT color="#800000">2</FONT>));  <I><FONT color="#008080">// +loop</FONT></I>
            }
            idat.SetRsv(ar, <FONT color="#800000">0</FONT>);              
          }
       }
}

<I><FONT color="#008080">// Function name    : Primitives::L_questiondo</FONT></I>
<I><FONT color="#008080">// Description      : ( start limit -- )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_questiondo(InterpreterData & idat)
{
    <B><FONT color="#000080">if</FONT></B>(idat.Compiling())                   <I><FONT color="#008080">// compiling ??</FONT></I>
    {   
          Word *fqdo;                       <I><FONT color="#008080">// a pointer for us</FONT></I>
          string Dlook = <FONT color="#800000">"?rundo"</FONT>;             <I><FONT color="#008080">// my name</FONT></I>
          fqdo = idat.IDict()-&gt;Address(Dlook);  <I><FONT color="#008080">// address of word 'do'</FONT></I>
          
          <B><FONT color="#000080">long</FONT></B> key1 = (<B><FONT color="#000080">long</FONT></B>)<FONT color="#800000">1234567</FONT>;

          idat.BuildAddElement((<B><FONT color="#000080">long</FONT></B>)<FONT color="#800000">0</FONT>);   <I><FONT color="#008080">// for index of "loop or +loop"</FONT></I>
          idat.BuildAddElement(&key1);     <I><FONT color="#008080">// variable for limit</FONT></I>
          idat.BuildAddElement(&key1);     <I><FONT color="#008080">// variable for index</FONT></I>
          idat.BuildAddElement(fqdo);
          <B><FONT color="#000080">long</FONT></B> ee = idat.BuildLastUsedElement();           
          idat.PushLabeledAD((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>)fqdo, ee);
    }
    <B><FONT color="#000080">else</FONT></B>  <I><FONT color="#008080">// not compiling</FONT></I>
    {
       <B><FONT color="#000080">long</FONT></B> *pind = (<B><FONT color="#000080">long</FONT></B> *) idat.PopD();              <I><FONT color="#008080">// get pushed addresses</FONT></I>
       <B><FONT color="#000080">long</FONT></B> *plim = (<B><FONT color="#000080">long</FONT></B> *) idat.PopD();              <I><FONT color="#008080">// either keys of index limit</FONT></I>
       <B><FONT color="#000080">long</FONT></B> lind = idat.PopD();                        <I><FONT color="#008080">// index of "loop or +loop"</FONT></I>
       <B><FONT color="#000080">if</FONT></B>((*plim) == <FONT color="#800000">1234567</FONT> && (*pind) == <FONT color="#800000">1234567</FONT>)    <I><FONT color="#008080">// if they are keys first loop</FONT></I>
       {
          *pind = idat.PopD();                         <I><FONT color="#008080">// set to index</FONT></I>
          *plim = idat.PopD();                         <I><FONT color="#008080">// set to limit </FONT></I>
          <B><FONT color="#000080">if</FONT></B>((*pind) == (*plim))                       <I><FONT color="#008080">// if equal we jump to "loop or +loop"</FONT></I>
          {                                            
            RSData ar = idat.GetRsv(<FONT color="#800000">0</FONT>);
            Word *wn = ar.Code();
            <B><FONT color="#000080">if</FONT></B>(wn-&gt;SameWord(lind, <FONT color="#800000">"loop"</FONT>, idat))
            {
               ar.SetIndex((lind - <FONT color="#800000">2</FONT>));   <I><FONT color="#008080">// loop</FONT></I>
            }
            <B><FONT color="#000080">else</FONT></B>
            {
               ar.SetIndex((lind - <FONT color="#800000">2</FONT>));  <I><FONT color="#008080">// +loop</FONT></I>
            }
            idat.SetRsv(ar, <FONT color="#800000">0</FONT>);              
          }
       }
    }
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_rundo(InterpreterData & idat)
{
       <B><FONT color="#000080">long</FONT></B> *pind = (<B><FONT color="#000080">long</FONT></B> *) idat.PopD();              <I><FONT color="#008080">// get pushed addresses</FONT></I>
       <B><FONT color="#000080">long</FONT></B> *plim = (<B><FONT color="#000080">long</FONT></B> *) idat.PopD();              <I><FONT color="#008080">// either keys of index limit</FONT></I>
       <B><FONT color="#000080">long</FONT></B> qdo = idat.PopD();                         <I><FONT color="#008080">// for ?do index of "loop or +loop"</FONT></I>
       <B><FONT color="#000080">if</FONT></B>((*plim) == <FONT color="#800000">1234567</FONT> && (*pind) == <FONT color="#800000">1234567</FONT>)   <I><FONT color="#008080">// if they are keys first loop</FONT></I>
       {
          *pind = idat.PopD();                         <I><FONT color="#008080">// set to index</FONT></I>
          *plim = idat.PopD();                         <I><FONT color="#008080">// set to limit                 </FONT></I>
       }
}

<I><FONT color="#008080">// Function name    : Primitives::L_do</FONT></I>
<I><FONT color="#008080">// Description      : ( start limit -- )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_do(InterpreterData & idat)
{
    <B><FONT color="#000080">if</FONT></B>(idat.CompilingNI())                   <I><FONT color="#008080">// compiling ??</FONT></I>
    {   
          Word *fdo;                       <I><FONT color="#008080">// a pointer for us</FONT></I>
          string Dlook = <FONT color="#800000">"rundo"</FONT>;             <I><FONT color="#008080">// runtime do</FONT></I>
          fdo = idat.IDict()-&gt;Address(Dlook);  <I><FONT color="#008080">// address of word 'do'</FONT></I>
          
          <B><FONT color="#000080">long</FONT></B> key1 = (<B><FONT color="#000080">long</FONT></B>)<FONT color="#800000">1234567</FONT>;

          idat.BuildAddElement((<B><FONT color="#000080">long</FONT></B>)<FONT color="#800000">0</FONT>);   <I><FONT color="#008080">// for ?do index of "loop or +loop"</FONT></I>
          idat.BuildAddElement(&key1);     <I><FONT color="#008080">// variable for limit</FONT></I>
          idat.BuildAddElement(&key1);     <I><FONT color="#008080">// variable for index</FONT></I>
          idat.BuildAddElement(fdo);
          <B><FONT color="#000080">long</FONT></B> ee = idat.BuildLastUsedElement();
          idat.PushLabeledAD((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>) fdo, ee);
    }
    <B><FONT color="#000080">else</FONT></B>  <I><FONT color="#008080">// not compiling</FONT></I>
    {
       <B><FONT color="#000080">long</FONT></B> *pind = (<B><FONT color="#000080">long</FONT></B> *) idat.PopD();              <I><FONT color="#008080">// get pushed addresses</FONT></I>
       <B><FONT color="#000080">long</FONT></B> *plim = (<B><FONT color="#000080">long</FONT></B> *) idat.PopD();              <I><FONT color="#008080">// either keys of index limit</FONT></I>
       <B><FONT color="#000080">long</FONT></B> qdo = idat.PopD();                         <I><FONT color="#008080">// for ?do index of "loop or +loop"</FONT></I>
       <B><FONT color="#000080">if</FONT></B>((*plim) == <FONT color="#800000">1234567</FONT> && (*pind) == <FONT color="#800000">1234567</FONT>)   <I><FONT color="#008080">// if they are keys first loop</FONT></I>
       {
          *pind = idat.PopD();                         <I><FONT color="#008080">// set to index</FONT></I>
          *plim = idat.PopD();                         <I><FONT color="#008080">// set to limit                 </FONT></I>
       }
    }
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_runloop(InterpreterData & idat)
{
      <B><FONT color="#000080">int</FONT></B> doindex = (<B><FONT color="#000080">int</FONT></B> ) idat.PopD();               <I><FONT color="#008080">// index of 'do' on stack </FONT></I>
      RSData ar = idat.GetRsv(<FONT color="#800000">0</FONT>);              <I><FONT color="#008080">// get return stack entry (it called me)</FONT></I>
      Word *calling = ar.Code();               <I><FONT color="#008080">// get the address of the word that called</FONT></I>

      <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> lim = <FONT color="#800000">1001</FONT>;                    
      <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> ind = <FONT color="#800000">1001</FONT>;

      calling-&gt;LiteralValue((doindex - <FONT color="#800000">1</FONT>), &ind);  
      calling-&gt;LiteralValue((doindex - <FONT color="#800000">2</FONT>), &lim);


      ind++;                                     <I><FONT color="#008080">// increment index</FONT></I>
      <B><FONT color="#000080">if</FONT></B>(ind &lt; lim)                              <I><FONT color="#008080">// loop not done ??</FONT></I>
      { 
         calling-&gt;SetLiteralValue((doindex - <FONT color="#800000">1</FONT>), &ind); 
         ar.SetIndex(doindex);                       <I><FONT color="#008080">// set up jump back to do index</FONT></I>
         idat.SetRsv(ar, <FONT color="#800000">0</FONT>);                         <I><FONT color="#008080">// reset return stack</FONT></I>
      }
      <B><FONT color="#000080">else</FONT></B>
      {
          <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> key1 = (<B><FONT color="#000080">long</FONT></B>)<FONT color="#800000">1234567</FONT>;
          calling-&gt;SetLiteralValue((doindex - <FONT color="#800000">1</FONT>), &key1); 
          calling-&gt;SetLiteralValue((doindex - <FONT color="#800000">2</FONT>), &key1); 
      }
}


<I><FONT color="#008080">// Function name    : Primitives::L_loop</FONT></I>
<I><FONT color="#008080">// Description      : ( </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_loop(InterpreterData & idat)
{
    <B><FONT color="#000080">if</FONT></B>(idat.CompilingNI())                          <I><FONT color="#008080">// compiling ?</FONT></I>
    {   
          Word *floop;                            <I><FONT color="#008080">// a pointer for me (loop)</FONT></I>
          <B><FONT color="#000080">int</FONT></B> ido;                          
          <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> ee;
          string Llook = <FONT color="#800000">"runloop"</FONT>;                  <I><FONT color="#008080">// my name</FONT></I>
          floop = idat.IDict()-&gt;Address(Llook);   <I><FONT color="#008080">// set to address of word loop</FONT></I>

          Parser * par = idat.IParser();

          ido = idat.PopLabeledAD();
          <B><FONT color="#000080">if</FONT></B>(ido &gt;= <FONT color="#800000">3</FONT>)  <I><FONT color="#008080">// do uses ii, ii+1, ii+2 ii+3</FONT></I>
          {
             idat.BuildAddElement((<B><FONT color="#000080">long</FONT></B>)ido);
             idat.BuildAddElement(floop);
             ee = idat.BuildLastUsedElement();
             idat.Building()-&gt;SetLiteralValue((ido - <FONT color="#800000">3</FONT>), &ee);   <I><FONT color="#008080">// set the value to loop's index</FONT></I>
          }
          <B><FONT color="#000080">else</FONT></B>   <I><FONT color="#008080">// 'do' not found ??</FONT></I>
          {
             idat.ShowError(Errors::NO_DO); 
          }
    }
    <B><FONT color="#000080">else</FONT></B>   <I><FONT color="#008080">// not compiling</FONT></I>
    {
      <B><FONT color="#000080">int</FONT></B> doindex = (<B><FONT color="#000080">int</FONT></B> ) idat.PopD();               <I><FONT color="#008080">// index of 'do' on stack </FONT></I>
      RSData ar = idat.GetRsv(<FONT color="#800000">0</FONT>);              <I><FONT color="#008080">// get return stack entry (it called me)</FONT></I>
      Word *calling = ar.Code();               <I><FONT color="#008080">// get the address of the word that called</FONT></I>

      <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> lim = <FONT color="#800000">1001</FONT>;                    
      <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> ind = <FONT color="#800000">1001</FONT>;

      calling-&gt;LiteralValue((doindex - <FONT color="#800000">1</FONT>), &ind);  
      calling-&gt;LiteralValue((doindex - <FONT color="#800000">2</FONT>), &lim);


      ind++;                                     <I><FONT color="#008080">// increment index</FONT></I>
      <B><FONT color="#000080">if</FONT></B>(ind &lt; lim)                              <I><FONT color="#008080">// loop not done ??</FONT></I>
      { 
         calling-&gt;SetLiteralValue((doindex - <FONT color="#800000">1</FONT>), &ind); 
         ar.SetIndex(doindex);                       <I><FONT color="#008080">// set up jump back to do index</FONT></I>
         idat.SetRsv(ar, <FONT color="#800000">0</FONT>);                         <I><FONT color="#008080">// reset return stack</FONT></I>
      }
      <B><FONT color="#000080">else</FONT></B>
      {
          <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> key1 = (<B><FONT color="#000080">long</FONT></B>)<FONT color="#800000">1234567</FONT>;
          calling-&gt;SetLiteralValue((doindex - <FONT color="#800000">1</FONT>), &key1); 
          calling-&gt;SetLiteralValue((doindex - <FONT color="#800000">2</FONT>), &key1); 
      }
    }
}

<I><FONT color="#008080">// Function name    : Primitives::L_runplusloop</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_runplusloop(InterpreterData & idat)
{
        <B><FONT color="#000080">int</FONT></B> doindex = (<B><FONT color="#000080">int</FONT></B> ) idat.PopD();        <I><FONT color="#008080">// index of 'do' on stack </FONT></I>
        
        RSData ar = idat.GetRsv(<FONT color="#800000">0</FONT>);              <I><FONT color="#008080">// get return stack entry (it called me)</FONT></I>
        Word *calling = ar.Code();               <I><FONT color="#008080">// get the address of the word with +lopp in it</FONT></I>
        
        <B><FONT color="#000080">long</FONT></B> incr = <FONT color="#800000">0</FONT>;
        <B><FONT color="#000080">long</FONT></B> lim = <FONT color="#800000">1001</FONT>;                    
        <B><FONT color="#000080">long</FONT></B> ind = <FONT color="#800000">1001</FONT> ;
        
        calling-&gt;LiteralValue((doindex - <FONT color="#800000">1</FONT>), (<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> *)&ind);  
        calling-&gt;LiteralValue((doindex - <FONT color="#800000">2</FONT>), (<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> *)&lim);
        
        <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> tst = (ind &lt; lim);
        
        <B><FONT color="#000080">if</FONT></B>(ind != lim)                         <I><FONT color="#008080">// ?do no execute check</FONT></I>
        { 
            incr = idat.PopD();                 <I><FONT color="#008080">// get increment</FONT></I>
            <B><FONT color="#000080">if</FONT></B>(ind &lt; lim)
            {
                ind += incr;  
                tst = (ind &lt; lim);
            }
            <B><FONT color="#000080">else</FONT></B>
            {
                ind += incr;
                tst = (ind &gt;= lim);
            }
        }
        <I><FONT color="#008080">// increment index</FONT></I>
        
        
        <B><FONT color="#000080">if</FONT></B>(tst)                          <I><FONT color="#008080">// loop not done ??</FONT></I>
        { 
            calling-&gt;SetLiteralValue((doindex - <FONT color="#800000">1</FONT>), (<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> *)&ind); 
            ar.SetIndex(doindex);                       <I><FONT color="#008080">// set up jump back to do index</FONT></I>
            idat.SetRsv(ar, <FONT color="#800000">0</FONT>);                         <I><FONT color="#008080">// reset return stack</FONT></I>
        }
        <B><FONT color="#000080">else</FONT></B>
        {
            <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> key1 = (<B><FONT color="#000080">long</FONT></B>)<FONT color="#800000">1234567</FONT>;
            calling-&gt;SetLiteralValue((doindex - <FONT color="#800000">1</FONT>), &key1); 
            calling-&gt;SetLiteralValue((doindex - <FONT color="#800000">2</FONT>), &key1); 
        }
}

<I><FONT color="#008080">// Function name    : Primitives::L_plusloop</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_plusloop(InterpreterData & idat)
{
    <B><FONT color="#000080">if</FONT></B>(idat.Compiling())                          <I><FONT color="#008080">// compiling ?</FONT></I>
    {   
        
        Word *fploop;                            <I><FONT color="#008080">// a pointer for me (+loop)</FONT></I>
        <B><FONT color="#000080">int</FONT></B> ido;                          
        <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> ee;
        string Llook = <FONT color="#800000">"+runloop"</FONT>;                  <I><FONT color="#008080">// my name</FONT></I>
        
        fploop = idat.IDict()-&gt;Address(Llook);   <I><FONT color="#008080">// set to address of word +loop</FONT></I>
        
        Parser * par = idat.IParser();
        
        ido = idat.PopLabeledAD();              <I><FONT color="#008080">// get the index of do</FONT></I>
        <B><FONT color="#000080">if</FONT></B>(ido &gt;= <FONT color="#800000">3</FONT>)  <I><FONT color="#008080">// do uses ii, ii+1, ii+2 ii+3</FONT></I>
        {
            idat.BuildAddElement((<B><FONT color="#000080">long</FONT></B>)ido);
            idat.BuildAddElement(fploop);
            ee = idat.BuildLastUsedElement();
            idat.Building()-&gt;SetLiteralValue((ido - <FONT color="#800000">3</FONT>), &ee);
        }
        <B><FONT color="#000080">else</FONT></B>   <I><FONT color="#008080">// 'do' not found ??</FONT></I>
        {
            idat.ShowError(Errors::NO_DO); 
        }
    }
    <B><FONT color="#000080">else</FONT></B>   <I><FONT color="#008080">// not compiling</FONT></I>
    {
        <B><FONT color="#000080">int</FONT></B> doindex = (<B><FONT color="#000080">int</FONT></B> ) idat.PopD();        <I><FONT color="#008080">// index of 'do' on stack </FONT></I>
        
        RSData ar = idat.GetRsv(<FONT color="#800000">0</FONT>);              <I><FONT color="#008080">// get return stack entry (it called me)</FONT></I>
        Word *calling = ar.Code();               <I><FONT color="#008080">// get the address of the word with +lopp in it</FONT></I>
        
        <B><FONT color="#000080">long</FONT></B> incr = <FONT color="#800000">0</FONT>;
        <B><FONT color="#000080">long</FONT></B> lim = <FONT color="#800000">1001</FONT>;                    
        <B><FONT color="#000080">long</FONT></B> ind = <FONT color="#800000">1001</FONT> ;
        
        calling-&gt;LiteralValue((doindex - <FONT color="#800000">1</FONT>), (<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> *)&ind);  
        calling-&gt;LiteralValue((doindex - <FONT color="#800000">2</FONT>), (<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> *)&lim);
        
        <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> tst = (ind &lt; lim);
        
        <B><FONT color="#000080">if</FONT></B>(ind != lim)                         <I><FONT color="#008080">// ?do no execute check</FONT></I>
        { 
            incr = idat.PopD();                 <I><FONT color="#008080">// get increment</FONT></I>
            <B><FONT color="#000080">if</FONT></B>(ind &lt; lim)
            {
                ind += incr;  
                tst = (ind &lt; lim);
            }
            <B><FONT color="#000080">else</FONT></B>
            {
                ind += incr;
                tst = (ind &gt;= lim);
            }
        }
        <I><FONT color="#008080">// increment index</FONT></I>
        
        
        <B><FONT color="#000080">if</FONT></B>(tst)                          <I><FONT color="#008080">// loop not done ??</FONT></I>
        { 
            calling-&gt;SetLiteralValue((doindex - <FONT color="#800000">1</FONT>), (<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> *)&ind); 
            ar.SetIndex(doindex);                       <I><FONT color="#008080">// set up jump back to do index</FONT></I>
            idat.SetRsv(ar, <FONT color="#800000">0</FONT>);                         <I><FONT color="#008080">// reset return stack</FONT></I>
        }
        <B><FONT color="#000080">else</FONT></B>
        {
            <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> key1 = (<B><FONT color="#000080">long</FONT></B>)<FONT color="#800000">1234567</FONT>;
            calling-&gt;SetLiteralValue((doindex - <FONT color="#800000">1</FONT>), &key1); 
            calling-&gt;SetLiteralValue((doindex - <FONT color="#800000">2</FONT>), &key1); 
        }
    }
}

<I><FONT color="#008080">// Function name    : Primitives::L_drop</FONT></I>
<I><FONT color="#008080">// Description      : ( n --- )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_drop(InterpreterData & idat)
{
   <B><FONT color="#000080">long</FONT></B> aa = idat.PopD();
}

<I><FONT color="#008080">// Function name    : Primitives::L_over</FONT></I>
<I><FONT color="#008080">// Description      : ( n1 n2 --- n1 n2 n1 )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_over(InterpreterData & idat)
{
   <B><FONT color="#000080">long</FONT></B> aa = idat.PopD();  <I><FONT color="#008080">// n2</FONT></I>
   <B><FONT color="#000080">long</FONT></B> bb = idat.PopD();  <I><FONT color="#008080">// n1</FONT></I>
   idat.PushD(bb);         <I><FONT color="#008080">// n1</FONT></I>
   idat.PushD(aa);         <I><FONT color="#008080">// n2</FONT></I>
   idat.PushD(bb);         <I><FONT color="#008080">// n1</FONT></I>
}

<I><FONT color="#008080">// Function name    : Primitives::L_rot</FONT></I>
<I><FONT color="#008080">// Description      : ( n1 n2 n3 --- n2 n3 n1 )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_rot(InterpreterData & idat)
{
   <B><FONT color="#000080">long</FONT></B> aa = idat.PopD();  <I><FONT color="#008080">// a</FONT></I>
   <B><FONT color="#000080">long</FONT></B> bb = idat.PopD();  <I><FONT color="#008080">// b</FONT></I>
   <B><FONT color="#000080">long</FONT></B> cc = idat.PopD();  <I><FONT color="#008080">// c</FONT></I>
   idat.PushD(bb);
   idat.PushD(aa);
   idat.PushD(cc);
}

<I><FONT color="#008080">// Function name    : Primitives::L_reverserot</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_reverserot(InterpreterData & idat)
{
   <B><FONT color="#000080">long</FONT></B> aa = idat.PopD();  <I><FONT color="#008080">// n3</FONT></I>
   <B><FONT color="#000080">long</FONT></B> bb = idat.PopD();  <I><FONT color="#008080">// n2</FONT></I>
   <B><FONT color="#000080">long</FONT></B> cc = idat.PopD();  <I><FONT color="#008080">// n1</FONT></I>
   idat.PushD(aa);
   idat.PushD(cc);
   idat.PushD(bb);
}

<I><FONT color="#008080">// Function name    : Primitives::L_multiply</FONT></I>
<I><FONT color="#008080">// Description      : ( a b --- a*b )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_multiply(InterpreterData & idat)
{
   <B><FONT color="#000080">long</FONT></B> aa = idat.PopD();  
   <B><FONT color="#000080">long</FONT></B> bb = idat.PopD(); 
   <B><FONT color="#000080">long</FONT></B> cc = aa * bb;
   idat.PushD(cc);
}

<I><FONT color="#008080">// Function name    : Primitives::L_starslash</FONT></I>
<I><FONT color="#008080">// Description      : ( n1 n2 n3 -- [n1*n2]/n3 )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_starslash(InterpreterData & idat)
{
   __int64 aa = (__int64) idat.PopD();  <I><FONT color="#008080">// n3</FONT></I>
   __int64 bb = (__int64) idat.PopD();  <I><FONT color="#008080">// n2</FONT></I>
   __int64 cc = (__int64) idat.PopD();  <I><FONT color="#008080">// n1</FONT></I>
   __int64 dd = (bb * cc) / aa;
   idat.PushD((<B><FONT color="#000080">long</FONT></B>)dd);
}

<I><FONT color="#008080">// Function name    : Primitives::L_starslashmod</FONT></I>
<I><FONT color="#008080">// Description      : ( n1 n2 n3 -- [n1*n2]%n3 [n1*n2]/n3 )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_starslashmod(InterpreterData & idat)
{
   __int64 aa = (__int64) idat.PopD();  <I><FONT color="#008080">// n3</FONT></I>
   __int64 bb = (__int64) idat.PopD();  <I><FONT color="#008080">// n2</FONT></I>
   __int64 cc = (__int64) idat.PopD();  <I><FONT color="#008080">// n1</FONT></I>
   __int64 dd = (bb * cc) / aa;
   __int64 ee = (bb * cc) % aa;
   idat.PushD((<B><FONT color="#000080">long</FONT></B>)ee);
   idat.PushD((<B><FONT color="#000080">long</FONT></B>)dd);
}

<I><FONT color="#008080">// Function name    : Primitives::L_slashmod</FONT></I>
<I><FONT color="#008080">// Description      : ( n1 n2 -- n3 n4 )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_slashmod(InterpreterData & idat)
{
   <B><FONT color="#000080">long</FONT></B> n2 = idat.PopD();  <I><FONT color="#008080">// n2</FONT></I>
   <B><FONT color="#000080">long</FONT></B> n1 = idat.PopD();  <I><FONT color="#008080">// n1</FONT></I>
   <B><FONT color="#000080">long</FONT></B> n4 = n1 / n2;
   <B><FONT color="#000080">long</FONT></B> n3 = n1 % n2;
   idat.PushD(n3);
   idat.PushD(n4);
}

<I><FONT color="#008080">// Function name    : Primitives::L_mod</FONT></I>
<I><FONT color="#008080">// Description      : ( n1 n2 -- n3 n4 )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_mod(InterpreterData & idat)
{
   <B><FONT color="#000080">long</FONT></B> n2 = idat.PopD();  <I><FONT color="#008080">// n2</FONT></I>
   <B><FONT color="#000080">long</FONT></B> n1 = idat.PopD();  <I><FONT color="#008080">// n1</FONT></I>
    <B><FONT color="#000080">long</FONT></B> n3 = n1 % n2;
   idat.PushD(n3);
}

<I><FONT color="#008080">// Function name    : Primitives::L_divide</FONT></I>
<I><FONT color="#008080">// Description      : ( b a -- b/a )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_divide(InterpreterData & idat)
{
   <B><FONT color="#000080">long</FONT></B> aa = idat.PopD();  
   <B><FONT color="#000080">long</FONT></B> bb = idat.PopD(); 
   
   <B><FONT color="#000080">if</FONT></B>(aa == <FONT color="#800000">0</FONT>)
   {
     idat.ShowError(Errors::DIVIDEBYZERO);
   }
   <B><FONT color="#000080">else</FONT></B>
   {
     <B><FONT color="#000080">long</FONT></B> dd = bb / aa;
     idat.PushD(dd);
   }
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_greaternumber(InterpreterData & idat)
{
   <B><FONT color="#000080">long</FONT></B> slen = idat.PopD();  
   <B><FONT color="#000080">char</FONT></B> *cstr = (<B><FONT color="#000080">char</FONT></B> *)idat.PopD(); 
   <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> rn = (idat.PopD()) * (*idat.Base());
 
   <B><FONT color="#000080">char</FONT></B> * eptr;
   <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> uu;

   uu = strtoul(cstr, &eptr, (*idat.Base())); 
   rn += uu;
   idat.PushD(rn);
   idat.PushD(eptr);
   idat.PushD(slen - (eptr - cstr));
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_hex(InterpreterData & idat)
{
   (*idat.Base()) = <FONT color="#800000">16</FONT>;
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_octal(InterpreterData & idat)
{
   (*idat.Base()) = <FONT color="#800000">8</FONT>;
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_decimal(InterpreterData & idat)
{
   (*idat.Base()) = <FONT color="#800000">10</FONT>;
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_base(InterpreterData & idat)
{
   idat.PushD((<B><FONT color="#000080">long</FONT></B>)idat.Base());
}

<I><FONT color="#008080">// Function name    : Primitives::L_constant</FONT></I>
<I><FONT color="#008080">// Description      : defines a constant</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_constant(InterpreterData & idat)
{
  string awrd;
  Parser * par = idat.IParser();
  <B><FONT color="#000080">char</FONT></B> * wrd;

  <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
  {
     <I><FONT color="#008080">// the word constant is only interpreted "to compile a constant'</FONT></I>
     <I><FONT color="#008080">// then the name it compiles is a new forth word</FONT></I>
      idat.ShowError(Errors::ILLEGALDEFINING);
      <B><FONT color="#000080">return</FONT></B>;
  }

 <B><FONT color="#000080">if</FONT></B>((wrd = par-&gt;NextWord()) != NULL)
 {
    awrd = wrd;
    <B><FONT color="#000080">if</FONT></B>(idat.IDict()-&gt;Exists(awrd) == -<FONT color="#800000">1</FONT>)  <I><FONT color="#008080">// word does not exist</FONT></I>
    {
         <B><FONT color="#000080">if</FONT></B>(!par-&gt;AllDigits(wrd))  <I><FONT color="#008080">// word is not a number</FONT></I>
         {
           idat.BuildWithName(awrd);
           
           <B><FONT color="#000080">long</FONT></B> aa = idat.PopD();  
           idat.BuildAddElement((<B><FONT color="#000080">long</FONT></B>) aa);
           idat.BuildFinishWord();
         }
         <B><FONT color="#000080">else</FONT></B>
         {
            <I><FONT color="#008080">// trying to name a word with a number error</FONT></I>
            idat.ShowError(Errors::IS_NUMBER);
         }
    }
    <B><FONT color="#000080">else</FONT></B>
     {
        <I><FONT color="#008080">// word already exists error</FONT></I>
        idat.ShowError(Errors::WORD_EXISTS, awrd);
     }
 } 
 <B><FONT color="#000080">else</FONT></B>
 {
      <I><FONT color="#008080">// buffer end reached</FONT></I>
      idat.ShowError(Errors::BUFFER_END);
 }
}


<I><FONT color="#008080">// Function name    : Primitives::L_variable</FONT></I>
<I><FONT color="#008080">// Description      : defines a variable</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_variable(InterpreterData & idat)
{
  string awrd;
  awrd.reserve(<FONT color="#800000">120</FONT>);
  Parser * par = idat.IParser();
  <B><FONT color="#000080">char</FONT></B> * wrd;

  <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
  {
     <I><FONT color="#008080">// the word variable is only interpreted "to compile a variable'</FONT></I>
     <I><FONT color="#008080">// then the name it compiles is a new forth word</FONT></I>
      idat.ShowError(Errors::ILLEGALDEFINING);
      <B><FONT color="#000080">return</FONT></B>;
  }

 <B><FONT color="#000080">if</FONT></B>((wrd = par-&gt;NextWord()) != NULL)
 {
    awrd = wrd;
    <B><FONT color="#000080">if</FONT></B>(idat.IDict()-&gt;Exists(awrd) == -<FONT color="#800000">1</FONT>)  <I><FONT color="#008080">// word does not exist</FONT></I>
    {
         <B><FONT color="#000080">if</FONT></B>(!par-&gt;AllDigits(wrd))  <I><FONT color="#008080">// word is not a number</FONT></I>
         {
           idat.BuildWithName(awrd);
           
           <B><FONT color="#000080">long</FONT></B> aa = idat.PopD();  
           idat.BuildAddElement(&aa);           <I><FONT color="#008080">// put long in new AddressV element</FONT></I>
           idat.BuildFinishWord();
         }
         <B><FONT color="#000080">else</FONT></B>
         {
            <I><FONT color="#008080">// trying to name a word with a number error</FONT></I>
            idat.ShowError(Errors::IS_NUMBER);
         }
    }
    <B><FONT color="#000080">else</FONT></B>
     {
        <I><FONT color="#008080">// word already exists error</FONT></I>
        idat.ShowError(Errors::WORD_EXISTS, awrd);
     }
 } 
 <B><FONT color="#000080">else</FONT></B>
 {
      <I><FONT color="#008080">// buffer end reached</FONT></I>
      idat.ShowError(Errors::BUFFER_END);
 }
}

<I><FONT color="#008080">// -------------------------class methods------------------</FONT></I>

<B><FONT color="#000080">void</FONT></B> Primitives::L_EnclosedByte(InterpreterData & idat)
{
    string awrd;
    awrd.reserve(<FONT color="#800000">120</FONT>);
    Parser * par = idat.IParser();
    <B><FONT color="#000080">char</FONT></B> * wrd;
    
    <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
    {
        <I><FONT color="#008080">// the word variable is only interpreted "to compile a class'</FONT></I>
        <I><FONT color="#008080">// then the name it compiles is a new forth word</FONT></I>
        idat.ShowError(Errors::ILLEGALDEFINING);
        <B><FONT color="#000080">return</FONT></B>;
    }
    
    <B><FONT color="#000080">if</FONT></B>((wrd = par-&gt;NextWord()) != NULL)
    {
        awrd = wrd;
        <B><FONT color="#000080">if</FONT></B>(idat.IDict()-&gt;Exists(awrd) == -<FONT color="#800000">1</FONT>)  <I><FONT color="#008080">// word does not exist</FONT></I>
        {
            <B><FONT color="#000080">if</FONT></B>(!par-&gt;AllDigits(wrd))  <I><FONT color="#008080">// word is not a number</FONT></I>
            {
                ClassDescription * cd = idat.ClassDSCR()-&gt;CompilingWhat(); 
                <B><FONT color="#000080">if</FONT></B>(cd != NULL)
                {
                    ClassData * dptr = <B><FONT color="#000080">new</FONT></B> ClassData(awrd, <FONT color="#800000">1</FONT>, cd, <FONT color="#800000">1</FONT>, NULL);
                    <B><FONT color="#000080">if</FONT></B>(cd-&gt;AddData(*dptr) == false)
                    {
                        <I><FONT color="#008080">// error data exists with name</FONT></I>
                         idat.ShowError(Errors::MEMBER_EXISTS);
                    }
                    <B><FONT color="#000080">delete</FONT></B> dptr;
                }
                <B><FONT color="#000080">else</FONT></B>
                {
                    <I><FONT color="#008080">// error not compiling class</FONT></I>
                    idat.ShowError(Errors::NO_CLASS_EXISTS);
                }
            }
            <B><FONT color="#000080">else</FONT></B>
            {
                <I><FONT color="#008080">// error method name expected</FONT></I>
                <I><FONT color="#008080">// trying to name a word with a number error</FONT></I>
                idat.ShowError(Errors::IS_NUMBER);
            }
        }
        <B><FONT color="#000080">else</FONT></B>
        {
            <I><FONT color="#008080">// error word exists</FONT></I>
            <I><FONT color="#008080">// word already exists error</FONT></I>
            idat.ShowError(Errors::WORD_EXISTS, awrd);
        }
    }
    <B><FONT color="#000080">else</FONT></B>
    {
        <I><FONT color="#008080">// buffer end reached</FONT></I>
        idat.ShowError(Errors::BUFFER_END);
    }
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_EnclosedBytes(InterpreterData & idat)
{
    string awrd;
    awrd.reserve(<FONT color="#800000">120</FONT>);
    Parser * par = idat.IParser();
    <B><FONT color="#000080">char</FONT></B> * wrd;
    
    <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
    {
        <I><FONT color="#008080">// the word variable is only interpreted "to compile a class'</FONT></I>
        <I><FONT color="#008080">// then the name it compiles is a new forth word</FONT></I>
        idat.ShowError(Errors::ILLEGALDEFINING);
        <B><FONT color="#000080">return</FONT></B>;
    }
    
    <B><FONT color="#000080">if</FONT></B>((wrd = par-&gt;NextWord()) != NULL)
    {
        awrd = wrd;
        <B><FONT color="#000080">if</FONT></B>(idat.IDict()-&gt;Exists(awrd) == -<FONT color="#800000">1</FONT>)  <I><FONT color="#008080">// word does not exist</FONT></I>
        {
            <B><FONT color="#000080">if</FONT></B>(!par-&gt;AllDigits(wrd))  <I><FONT color="#008080">// word is not a number</FONT></I>
            {
                ClassDescription * cd = idat.ClassDSCR()-&gt;CompilingWhat(); 
                <B><FONT color="#000080">if</FONT></B>(cd != NULL)
                {
                    <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> nn = idat.PopD();
                    ClassData * dptr = <B><FONT color="#000080">new</FONT></B> ClassData(awrd, <FONT color="#800000">1</FONT>, cd, nn, NULL);
                    <B><FONT color="#000080">if</FONT></B>(cd-&gt;AddData(*dptr) == false)
                    {
                        <I><FONT color="#008080">// error data exists with name</FONT></I>
                         idat.ShowError(Errors::MEMBER_EXISTS);
                    }
                    <B><FONT color="#000080">delete</FONT></B> dptr;
                }
                <B><FONT color="#000080">else</FONT></B>
                {
                    <I><FONT color="#008080">// error not compiling class</FONT></I>
                    idat.ShowError(Errors::NO_CLASS_EXISTS);
                }
            }
            <B><FONT color="#000080">else</FONT></B>
            {
                <I><FONT color="#008080">// error method name expected</FONT></I>
                <I><FONT color="#008080">// trying to name a word with a number error</FONT></I>
                idat.ShowError(Errors::IS_NUMBER);
            }
        }
        <B><FONT color="#000080">else</FONT></B>
        {
            <I><FONT color="#008080">// error word exists</FONT></I>
            <I><FONT color="#008080">// word already exists error</FONT></I>
            idat.ShowError(Errors::WORD_EXISTS, awrd);
        }
    }
    <B><FONT color="#000080">else</FONT></B>
    {
        <I><FONT color="#008080">// buffer end reached</FONT></I>
        idat.ShowError(Errors::BUFFER_END);
    }
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_EnclosedWord(InterpreterData & idat)
{
    string awrd;
    awrd.reserve(<FONT color="#800000">120</FONT>);
    Parser * par = idat.IParser();
    <B><FONT color="#000080">char</FONT></B> * wrd;
    
    <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
    {
        <I><FONT color="#008080">// the word variable is only interpreted "to compile a class'</FONT></I>
        <I><FONT color="#008080">// then the name it compiles is a new forth word</FONT></I>
        idat.ShowError(Errors::ILLEGALDEFINING);
        <B><FONT color="#000080">return</FONT></B>;
    }
    
    <B><FONT color="#000080">if</FONT></B>((wrd = par-&gt;NextWord()) != NULL)
    {
        awrd = wrd;
        <B><FONT color="#000080">if</FONT></B>(idat.IDict()-&gt;Exists(awrd) == -<FONT color="#800000">1</FONT>)  <I><FONT color="#008080">// word does not exist</FONT></I>
        {
            <B><FONT color="#000080">if</FONT></B>(!par-&gt;AllDigits(wrd))  <I><FONT color="#008080">// word is not a number</FONT></I>
            {
                ClassDescription * cd = idat.ClassDSCR()-&gt;CompilingWhat(); 
                <B><FONT color="#000080">if</FONT></B>(cd != NULL)
                {
                    ClassData * dptr = <B><FONT color="#000080">new</FONT></B> ClassData(awrd, <FONT color="#800000">2</FONT>, cd, <FONT color="#800000">1</FONT>, NULL);
                    <B><FONT color="#000080">if</FONT></B>(cd-&gt;AddData(*dptr) == false)
                    {
                        <I><FONT color="#008080">// error data exists with name</FONT></I>
                         idat.ShowError(Errors::MEMBER_EXISTS);
                    }
                    <B><FONT color="#000080">delete</FONT></B> dptr;
                }
                <B><FONT color="#000080">else</FONT></B>
                {
                    idat.DebugTrace(<FONT color="#800000">" &gt;&gt;&gt;NULL returned from idat.ClassDSCR()-&gt;CompilingWhat()"</FONT>);
                    <I><FONT color="#008080">// error not compiling class</FONT></I>
                    idat.ShowError(Errors::NO_CLASS_EXISTS);
                }
            }
            <B><FONT color="#000080">else</FONT></B>
            {
                <I><FONT color="#008080">// error method name expected</FONT></I>
                <I><FONT color="#008080">// trying to name a word with a number error</FONT></I>
                idat.ShowError(Errors::IS_NUMBER);
            }
        }
        <B><FONT color="#000080">else</FONT></B>
        {
            <I><FONT color="#008080">// error word exists</FONT></I>
            <I><FONT color="#008080">// word already exists error</FONT></I>
            idat.ShowError(Errors::WORD_EXISTS, awrd);
        }
    }
    <B><FONT color="#000080">else</FONT></B>
    {
        <I><FONT color="#008080">// buffer end reached</FONT></I>
        idat.ShowError(Errors::BUFFER_END);
    }
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_EnclosedWords(InterpreterData & idat)
{
    string awrd;
    awrd.reserve(<FONT color="#800000">120</FONT>);
    Parser * par = idat.IParser();
    <B><FONT color="#000080">char</FONT></B> * wrd;
    
    <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
    {
        <I><FONT color="#008080">// the word variable is only interpreted "to compile a class'</FONT></I>
        <I><FONT color="#008080">// then the name it compiles is a new forth word</FONT></I>
        idat.ShowError(Errors::ILLEGALDEFINING);
        <B><FONT color="#000080">return</FONT></B>;
    }
    
    <B><FONT color="#000080">if</FONT></B>((wrd = par-&gt;NextWord()) != NULL)
    {
        awrd = wrd;
        <B><FONT color="#000080">if</FONT></B>(idat.IDict()-&gt;Exists(awrd) == -<FONT color="#800000">1</FONT>)  <I><FONT color="#008080">// word does not exist</FONT></I>
        {
            <B><FONT color="#000080">if</FONT></B>(!par-&gt;AllDigits(wrd))  <I><FONT color="#008080">// word is not a number</FONT></I>
            {
                ClassDescription * cd = idat.ClassDSCR()-&gt;CompilingWhat(); 
                <B><FONT color="#000080">if</FONT></B>(cd != NULL)
                {
                    <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> nn = idat.PopD();
                    ClassData * dptr = <B><FONT color="#000080">new</FONT></B> ClassData(awrd, <FONT color="#800000">2</FONT>, cd, nn, NULL);
                    <B><FONT color="#000080">if</FONT></B>(cd-&gt;AddData(*dptr) == false)
                    {
                        <I><FONT color="#008080">// error data exists with name</FONT></I>
                         idat.ShowError(Errors::MEMBER_EXISTS);
                    }
                    <B><FONT color="#000080">delete</FONT></B> dptr;
                }
                <B><FONT color="#000080">else</FONT></B>
                {
                    <I><FONT color="#008080">// error not compiling class</FONT></I>
                    idat.ShowError(Errors::NO_CLASS_EXISTS);
                }
            }
            <B><FONT color="#000080">else</FONT></B>
            {
                <I><FONT color="#008080">// error method name expected</FONT></I>
                <I><FONT color="#008080">// trying to name a word with a number error</FONT></I>
                idat.ShowError(Errors::IS_NUMBER);
            }
        }
        <B><FONT color="#000080">else</FONT></B>
        {
            <I><FONT color="#008080">// error word exists</FONT></I>
            <I><FONT color="#008080">// word already exists error</FONT></I>
            idat.ShowError(Errors::WORD_EXISTS, awrd);
        }
    }
    <B><FONT color="#000080">else</FONT></B>
    {
        <I><FONT color="#008080">// buffer end reached</FONT></I>
        idat.ShowError(Errors::BUFFER_END);
    }
}


<B><FONT color="#000080">void</FONT></B> Primitives::L_EnclosedDWord(InterpreterData & idat)
{
    string awrd;
    awrd.reserve(<FONT color="#800000">120</FONT>);
    Parser * par = idat.IParser();
    <B><FONT color="#000080">char</FONT></B> * wrd;
    ClassDescription * cd;
    
    <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
    {
        <I><FONT color="#008080">// the word variable is only interpreted "to compile a class'</FONT></I>
        <I><FONT color="#008080">// then the name it compiles is a new forth word</FONT></I>
        idat.ShowError(Errors::ILLEGALDEFINING);
        <B><FONT color="#000080">return</FONT></B>;
    }
    
    <B><FONT color="#000080">if</FONT></B>((wrd = par-&gt;NextWord()) != NULL)
    {
        awrd = wrd;
        <B><FONT color="#000080">if</FONT></B>(idat.IDict()-&gt;Exists(awrd) == -<FONT color="#800000">1</FONT>)  <I><FONT color="#008080">// word does not exist</FONT></I>
        {
            <B><FONT color="#000080">if</FONT></B>(!par-&gt;AllDigits(wrd))  <I><FONT color="#008080">// word is not a number</FONT></I>
            {

                idat.DebugTrace(<FONT color="#800000">" &gt;&gt;&gt;Getting idat.ClassDSCR()-&gt;CompilingWhat() in [dword]"</FONT>);
                cd = idat.ClassDSCR()-&gt;CompilingWhat(); 
                <B><FONT color="#000080">if</FONT></B>(cd != NULL)
                {
                    ClassData * dptr = <B><FONT color="#000080">new</FONT></B> ClassData(awrd, <FONT color="#800000">4</FONT>, cd, <FONT color="#800000">1</FONT>, NULL);
                    <B><FONT color="#000080">if</FONT></B>(cd-&gt;AddData(*dptr) == false)
                    {
                        <I><FONT color="#008080">// error data exists with name</FONT></I>
                         idat.ShowError(Errors::MEMBER_EXISTS);
                    }
                }
                <B><FONT color="#000080">else</FONT></B>
                {
                    idat.DebugTrace(<FONT color="#800000">" &gt;&gt;&gt;NULL from idat.ClassDSCR()-&gt;CompilingWhat() in [dword]"</FONT>);
                    <I><FONT color="#008080">// error not compiling class</FONT></I>
                    idat.ShowError(Errors::NO_CLASS_EXISTS);
                }
            }
            <B><FONT color="#000080">else</FONT></B>
            {
                <I><FONT color="#008080">// error method name expected</FONT></I>
                <I><FONT color="#008080">// trying to name a word with a number error</FONT></I>
                idat.ShowError(Errors::IS_NUMBER);
            }
        }
        <B><FONT color="#000080">else</FONT></B>
        {
            <I><FONT color="#008080">// error word exists</FONT></I>
            <I><FONT color="#008080">// word already exists error</FONT></I>
            idat.ShowError(Errors::WORD_EXISTS, awrd);
        }
    }
    <B><FONT color="#000080">else</FONT></B>
    {
        <I><FONT color="#008080">// buffer end reached</FONT></I>
        idat.ShowError(Errors::BUFFER_END);
    }
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_EnclosedDWords(InterpreterData & idat)
{
    string awrd;
    awrd.reserve(<FONT color="#800000">120</FONT>);
    Parser * par = idat.IParser();
    <B><FONT color="#000080">char</FONT></B> * wrd;
    
    <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
    {
        <I><FONT color="#008080">// the word variable is only interpreted "to compile a class'</FONT></I>
        <I><FONT color="#008080">// then the name it compiles is a new forth word</FONT></I>
        idat.ShowError(Errors::ILLEGALDEFINING);
        <B><FONT color="#000080">return</FONT></B>;
    }
    
    <B><FONT color="#000080">if</FONT></B>((wrd = par-&gt;NextWord()) != NULL)
    {
        awrd = wrd;
        <B><FONT color="#000080">if</FONT></B>(idat.IDict()-&gt;Exists(awrd) == -<FONT color="#800000">1</FONT>)  <I><FONT color="#008080">// word does not exist</FONT></I>
        {
            <B><FONT color="#000080">if</FONT></B>(!par-&gt;AllDigits(wrd))  <I><FONT color="#008080">// word is not a number</FONT></I>
            {
                ClassDescription * cd = idat.ClassDSCR()-&gt;CompilingWhat(); 
                <B><FONT color="#000080">if</FONT></B>(cd != NULL)
                {
                    <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> nn = idat.PopD();
                    ClassData * dptr = <B><FONT color="#000080">new</FONT></B> ClassData(awrd, <FONT color="#800000">4</FONT>, cd, nn, NULL);
                    <B><FONT color="#000080">if</FONT></B>(cd-&gt;AddData(*dptr) == false)
                    {
                        <I><FONT color="#008080">// error data exists with name</FONT></I>
                         idat.ShowError(Errors::MEMBER_EXISTS);
                    }
                    <B><FONT color="#000080">delete</FONT></B> dptr;
                }
                <B><FONT color="#000080">else</FONT></B>
                {
                    <I><FONT color="#008080">// error not compiling class</FONT></I>
                    idat.ShowError(Errors::NO_CLASS_EXISTS);
                }
            }
            <B><FONT color="#000080">else</FONT></B>
            {
                <I><FONT color="#008080">// error method name expected</FONT></I>
                <I><FONT color="#008080">// trying to name a word with a number error</FONT></I>
                idat.ShowError(Errors::IS_NUMBER);
            }
        }
        <B><FONT color="#000080">else</FONT></B>
        {
            <I><FONT color="#008080">// error word exists</FONT></I>
            <I><FONT color="#008080">// word already exists error</FONT></I>
            idat.ShowError(Errors::WORD_EXISTS, awrd);
        }
    }
    <B><FONT color="#000080">else</FONT></B>
    {
        <I><FONT color="#008080">// buffer end reached</FONT></I>
        idat.ShowError(Errors::BUFFER_END);
    }
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_EnclosedPointer(InterpreterData & idat)
{
    string awrd;
    awrd.reserve(<FONT color="#800000">120</FONT>);
    Parser * par = idat.IParser();
    <B><FONT color="#000080">char</FONT></B> * wrd;
    
    <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
    {
        <I><FONT color="#008080">// the word variable is only interpreted "to compile a class'</FONT></I>
        <I><FONT color="#008080">// then the name it compiles is a new forth word</FONT></I>
        idat.ShowError(Errors::ILLEGALDEFINING);
        <B><FONT color="#000080">return</FONT></B>;
    }
    
    <B><FONT color="#000080">if</FONT></B>((wrd = par-&gt;NextWord()) != NULL)
    {
        awrd = wrd;
        <B><FONT color="#000080">if</FONT></B>(idat.IDict()-&gt;Exists(awrd) == -<FONT color="#800000">1</FONT>)  <I><FONT color="#008080">// word does not exist</FONT></I>
        {
            <B><FONT color="#000080">if</FONT></B>(!par-&gt;AllDigits(wrd))  <I><FONT color="#008080">// word is not a number</FONT></I>
            {
                ClassDescription * cd = idat.ClassDSCR()-&gt;CompilingWhat(); 
                <B><FONT color="#000080">if</FONT></B>(cd != NULL)
                {
                    ClassData * dptr = <B><FONT color="#000080">new</FONT></B> ClassData(awrd, <B><FONT color="#000080">sizeof</FONT></B>(<B><FONT color="#000080">long</FONT></B> *), cd, <FONT color="#800000">1</FONT>, NULL);
                    <B><FONT color="#000080">if</FONT></B>(cd-&gt;AddData(*dptr) == false)
                    {
                        <I><FONT color="#008080">// error data exists with name</FONT></I>
                         idat.ShowError(Errors::MEMBER_EXISTS);
                    }
                    <B><FONT color="#000080">delete</FONT></B> dptr;
                }
                <B><FONT color="#000080">else</FONT></B>
                {
                    <I><FONT color="#008080">// error not compiling class</FONT></I>
                    idat.ShowError(Errors::NO_CLASS_EXISTS);
                }
            }
            <B><FONT color="#000080">else</FONT></B>
            {
                <I><FONT color="#008080">// error method name expected</FONT></I>
                <I><FONT color="#008080">// trying to name a word with a number error</FONT></I>
                idat.ShowError(Errors::IS_NUMBER);
            }
        }
        <B><FONT color="#000080">else</FONT></B>
        {
            <I><FONT color="#008080">// error word exists</FONT></I>
            <I><FONT color="#008080">// word already exists error</FONT></I>
            idat.ShowError(Errors::WORD_EXISTS, awrd);
        }
    }
    <B><FONT color="#000080">else</FONT></B>
    {
        <I><FONT color="#008080">// buffer end reached</FONT></I>
        idat.ShowError(Errors::BUFFER_END);
    }
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_EnclosedPointers(InterpreterData & idat)
{
    string awrd;
    awrd.reserve(<FONT color="#800000">120</FONT>);
    Parser * par = idat.IParser();
    <B><FONT color="#000080">char</FONT></B> * wrd;
    
    <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
    {
        <I><FONT color="#008080">// the word variable is only interpreted "to compile a class'</FONT></I>
        <I><FONT color="#008080">// then the name it compiles is a new forth word</FONT></I>
        idat.ShowError(Errors::ILLEGALDEFINING);
        <B><FONT color="#000080">return</FONT></B>;
    }
    
    <B><FONT color="#000080">if</FONT></B>((wrd = par-&gt;NextWord()) != NULL)
    {
        awrd = wrd;
        <B><FONT color="#000080">if</FONT></B>(idat.IDict()-&gt;Exists(awrd) == -<FONT color="#800000">1</FONT>)  <I><FONT color="#008080">// word does not exist</FONT></I>
        {
            <B><FONT color="#000080">if</FONT></B>(!par-&gt;AllDigits(wrd))  <I><FONT color="#008080">// word is not a number</FONT></I>
            {
                ClassDescription * cd = idat.ClassDSCR()-&gt;CompilingWhat(); 
                <B><FONT color="#000080">if</FONT></B>(cd != NULL)
                {
                    <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> nn = idat.PopD();
                    ClassData * dptr = <B><FONT color="#000080">new</FONT></B> ClassData(awrd, <B><FONT color="#000080">sizeof</FONT></B>(<B><FONT color="#000080">long</FONT></B> *), cd, nn, NULL);
                    <B><FONT color="#000080">if</FONT></B>(cd-&gt;AddData(*dptr) == false)
                    {
                        <I><FONT color="#008080">// error data exists with name</FONT></I>
                         idat.ShowError(Errors::MEMBER_EXISTS);
                    }
                    <B><FONT color="#000080">delete</FONT></B> dptr;
                }
                <B><FONT color="#000080">else</FONT></B>
                {
                    <I><FONT color="#008080">// error not compiling class</FONT></I>
                    idat.ShowError(Errors::NO_CLASS_EXISTS);
                }
            }
            <B><FONT color="#000080">else</FONT></B>
            {
                <I><FONT color="#008080">// error method name expected</FONT></I>
                <I><FONT color="#008080">// trying to name a word with a number error</FONT></I>
                idat.ShowError(Errors::IS_NUMBER);
            }
        }
        <B><FONT color="#000080">else</FONT></B>
        {
            <I><FONT color="#008080">// error word exists</FONT></I>
            <I><FONT color="#008080">// word already exists error</FONT></I>
            idat.ShowError(Errors::WORD_EXISTS, awrd);
        }
    }
    <B><FONT color="#000080">else</FONT></B>
    {
        <I><FONT color="#008080">// buffer end reached</FONT></I>
        idat.ShowError(Errors::BUFFER_END);
    }
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_EnclosedArrays(InterpreterData & idat)
{
    string awrd;
    awrd.reserve(<FONT color="#800000">120</FONT>);
    Parser * par = idat.IParser();
    <B><FONT color="#000080">char</FONT></B> * wrd;
    
    <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
    {
        <I><FONT color="#008080">// the word variable is only interpreted "to compile a class'</FONT></I>
        <I><FONT color="#008080">// then the name it compiles is a new forth word</FONT></I>
        idat.ShowError(Errors::ILLEGALDEFINING);
        <B><FONT color="#000080">return</FONT></B>;
    }
    
    <B><FONT color="#000080">if</FONT></B>((wrd = par-&gt;NextWord()) != NULL)
    {
        awrd = wrd;
        <B><FONT color="#000080">if</FONT></B>(idat.IDict()-&gt;Exists(awrd) == -<FONT color="#800000">1</FONT>)  <I><FONT color="#008080">// word does not exist</FONT></I>
        {
            <B><FONT color="#000080">if</FONT></B>(!par-&gt;AllDigits(wrd))  <I><FONT color="#008080">// word is not a number</FONT></I>
            {
                ClassDescription * cd = idat.ClassDSCR()-&gt;CompilingWhat(); 
                <B><FONT color="#000080">if</FONT></B>(cd != NULL)
                {
                    <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> nn = idat.PopD();
                    <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> si = idat.PopD();
                    ClassData * dptr = <B><FONT color="#000080">new</FONT></B> ClassData(awrd, si, cd, nn, NULL);
                    <B><FONT color="#000080">if</FONT></B>(cd-&gt;AddData(*dptr) == false)
                    {
                        <I><FONT color="#008080">// error data exists with name</FONT></I>
                         idat.ShowError(Errors::MEMBER_EXISTS);
                    }
                    <B><FONT color="#000080">delete</FONT></B> dptr;
                }
                <B><FONT color="#000080">else</FONT></B>
                {
                    <I><FONT color="#008080">// error not compiling class</FONT></I>
                    idat.ShowError(Errors::NO_CLASS_EXISTS);
                }
            }
            <B><FONT color="#000080">else</FONT></B>
            {
                <I><FONT color="#008080">// error method name expected</FONT></I>
                <I><FONT color="#008080">// trying to name a word with a number error</FONT></I>
                idat.ShowError(Errors::IS_NUMBER);
            }
        }
        <B><FONT color="#000080">else</FONT></B>
        {
            <I><FONT color="#008080">// error word exists</FONT></I>
            <I><FONT color="#008080">// word already exists error</FONT></I>
            idat.ShowError(Errors::WORD_EXISTS, awrd);
        }
    }
    <B><FONT color="#000080">else</FONT></B>
    {
        <I><FONT color="#008080">// buffer end reached</FONT></I>
        idat.ShowError(Errors::BUFFER_END);
    }
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_EnclosedClass(InterpreterData & idat)
{
    string awrd;
    awrd.reserve(<FONT color="#800000">120</FONT>);
    Parser * par = idat.IParser();
    <B><FONT color="#000080">char</FONT></B> * wrd;
    <B><FONT color="#000080">char</FONT></B> * cln;
    string acln;
    ClassDescription * datc = NULL;
    ClassDescription * cd = NULL;
    
    <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
    {
        <I><FONT color="#008080">// the word variable is only interpreted "to compile a class'</FONT></I>
        <I><FONT color="#008080">// then the name it compiles is a new forth word</FONT></I>
        idat.ShowError(Errors::ILLEGALDEFINING);
        <B><FONT color="#000080">return</FONT></B>;
    }

    <B><FONT color="#000080">if</FONT></B>((cln = par-&gt;NextWord()) != NULL)
    {
        acln = cln;
        
        <B><FONT color="#000080">if</FONT></B>((datc = idat.ClassDSCR()-&gt;Find(acln)) == NULL)
        {
           idat.DebugTrace(<FONT color="#800000">"Found class type in [class]"</FONT>);
           <I><FONT color="#008080">// error no such class type</FONT></I>
           idat.ShowError(Errors::NO_CLASS_EXISTS, acln);
           <B><FONT color="#000080">return</FONT></B>;
        }
        <B><FONT color="#000080">else</FONT></B>
        {
           cd = idat.ClassDSCR()-&gt;CompilingWhat(); 
           <B><FONT color="#000080">if</FONT></B>(cd == datc)
           {
              <I><FONT color="#008080">// error no such class type</FONT></I>
              idat.ShowError(Errors::ILLEGALDEFINING);
              <B><FONT color="#000080">return</FONT></B>;
           }
           idat.DebugTrace(<FONT color="#800000">"Found compiling class type in [class]"</FONT>);
        }
    }
    <B><FONT color="#000080">else</FONT></B>
    {
       <I><FONT color="#008080">// buffer end reached</FONT></I>
        idat.ShowError(Errors::BUFFER_END);
        <B><FONT color="#000080">return</FONT></B>;
    }

    <B><FONT color="#000080">if</FONT></B>((wrd = par-&gt;NextWord()) != NULL)
    {
        awrd = wrd;
        <B><FONT color="#000080">if</FONT></B>(idat.IDict()-&gt;Exists(awrd) == -<FONT color="#800000">1</FONT>)  <I><FONT color="#008080">// word does not exist</FONT></I>
        {
            <B><FONT color="#000080">if</FONT></B>(!par-&gt;AllDigits(wrd))  <I><FONT color="#008080">// word is not a number</FONT></I>
            {
                <B><FONT color="#000080">if</FONT></B>(cd != NULL)
                {
                    ClassData * dptr = <B><FONT color="#000080">new</FONT></B> ClassData(awrd, datc-&gt;Size(), cd, <FONT color="#800000">1</FONT>, datc);
                    dptr-&gt;SetFlags(ClassData::ClassType);
                    <B><FONT color="#000080">if</FONT></B>(cd-&gt;AddData(*dptr) == false)
                    {
                        <I><FONT color="#008080">// error data exists with name</FONT></I>
                         idat.ShowError(Errors::MEMBER_EXISTS);
                    }
                    <B><FONT color="#000080">char</FONT></B> drdr[<FONT color="#800000">120</FONT>];
                    sprintf(drdr, <FONT color="#800000">"added [class] %s in %s [%lx] of %s [%lx]"</FONT>, awrd.c_str(), cd-&gt;Name().c_str(), cd, datc-&gt;Name().c_str(), datc);
                    idat.DebugTrace(drdr);
                    <B><FONT color="#000080">delete</FONT></B> dptr;
                    dptr = cd-&gt;DataDesc(awrd);
                    <B><FONT color="#000080">if</FONT></B>(dptr != NULL)
                    {
                       <B><FONT color="#000080">if</FONT></B>(dptr-&gt;IsClass())
                       {
                          sprintf(drdr, <FONT color="#800000">"found [class] %s [%lx]"</FONT>, dptr-&gt;Name().c_str(), dptr);
                       }
                       <B><FONT color="#000080">else</FONT></B>
                       {
                          sprintf(drdr, <FONT color="#800000">"OBECT NOT CLASS %s [%lx]"</FONT>, dptr-&gt;Name().c_str(), dptr);
                       }
                    }
                    <B><FONT color="#000080">else</FONT></B>
                    {
                       sprintf(drdr, <FONT color="#800000">"NO object from  cd-&gt;DataDesc(awrd)"</FONT>);
                    }
                    idat.DebugTrace(drdr);
                }
                <B><FONT color="#000080">else</FONT></B>
                {
                    <I><FONT color="#008080">// error not compiling class</FONT></I>
                    idat.ShowError(Errors::NO_CLASS_EXISTS);
                }
            }
            <B><FONT color="#000080">else</FONT></B>
            {
                <I><FONT color="#008080">// error method name expected</FONT></I>
                <I><FONT color="#008080">// trying to name a word with a number error</FONT></I>
                idat.ShowError(Errors::IS_NUMBER);
            }
        }
        <B><FONT color="#000080">else</FONT></B>
        {
            <I><FONT color="#008080">// error word exists</FONT></I>
            <I><FONT color="#008080">// word already exists error</FONT></I>
            idat.ShowError(Errors::WORD_EXISTS, awrd);
        }
    }
    <B><FONT color="#000080">else</FONT></B>
    {
        <I><FONT color="#008080">// buffer end reached</FONT></I>
        idat.ShowError(Errors::BUFFER_END);
    }
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_EnclosedClasses(InterpreterData & idat)
{
    string awrd;
    awrd.reserve(<FONT color="#800000">120</FONT>);
    Parser * par = idat.IParser();
    <B><FONT color="#000080">char</FONT></B> * wrd;
    <B><FONT color="#000080">char</FONT></B> * cln;
    string acln;
    ClassDescription * datc = NULL;
    ClassDescription * cd = NULL;
    
    <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
    {
        <I><FONT color="#008080">// the word variable is only interpreted "to compile a class'</FONT></I>
        <I><FONT color="#008080">// then the name it compiles is a new forth word</FONT></I>
        idat.ShowError(Errors::ILLEGALDEFINING);
        <B><FONT color="#000080">return</FONT></B>;
    }

    <B><FONT color="#000080">if</FONT></B>((cln = par-&gt;NextWord()) != NULL)
    {
        acln = cln;
        
        <B><FONT color="#000080">if</FONT></B>((datc = idat.ClassDSCR()-&gt;Find(acln)) == NULL)
        {
           idat.DebugTrace(<FONT color="#800000">"Found class type in [class]"</FONT>);
           <I><FONT color="#008080">// error no such class type</FONT></I>
           idat.ShowError(Errors::NO_CLASS_EXISTS, acln);
           <B><FONT color="#000080">return</FONT></B>;
        }
        <B><FONT color="#000080">else</FONT></B>
        {
           cd = idat.ClassDSCR()-&gt;CompilingWhat(); 
           <B><FONT color="#000080">if</FONT></B>(cd == datc)
           {
              <I><FONT color="#008080">// error no such class type</FONT></I>
              idat.ShowError(Errors::ILLEGALDEFINING);
              <B><FONT color="#000080">return</FONT></B>;
           }
           idat.DebugTrace(<FONT color="#800000">"Found compiling class type in [class]"</FONT>);
        }
    }
    <B><FONT color="#000080">else</FONT></B>
    {
       <I><FONT color="#008080">// buffer end reached</FONT></I>
        idat.ShowError(Errors::BUFFER_END);
        <B><FONT color="#000080">return</FONT></B>;
    }

    <B><FONT color="#000080">if</FONT></B>((wrd = par-&gt;NextWord()) != NULL)
    {
        awrd = wrd;
        <B><FONT color="#000080">if</FONT></B>(idat.IDict()-&gt;Exists(awrd) == -<FONT color="#800000">1</FONT>)  <I><FONT color="#008080">// word does not exist</FONT></I>
        {
            <B><FONT color="#000080">if</FONT></B>(!par-&gt;AllDigits(wrd))  <I><FONT color="#008080">// word is not a number</FONT></I>
            {
                <B><FONT color="#000080">if</FONT></B>(cd != NULL)
                {
                    <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> nn = idat.PopD();
                    ClassData * dptr = <B><FONT color="#000080">new</FONT></B> ClassData(awrd, datc-&gt;Size(), cd, nn, datc);
                    dptr-&gt;SetFlags(ClassData::ClassType);
                    <B><FONT color="#000080">if</FONT></B>(cd-&gt;AddData(*dptr) == false)
                    {
                        <I><FONT color="#008080">// error data exists with name</FONT></I>
                         idat.ShowError(Errors::MEMBER_EXISTS);
                    }
                    <B><FONT color="#000080">char</FONT></B> drdr[<FONT color="#800000">120</FONT>];
                    sprintf(drdr, <FONT color="#800000">"added [class] %s in %s [%lx] of %s [%lx]"</FONT>, awrd.c_str(), cd-&gt;Name().c_str(), cd, datc-&gt;Name().c_str(), datc);
                    idat.DebugTrace(drdr);
                    <B><FONT color="#000080">delete</FONT></B> dptr;
                    dptr = cd-&gt;DataDesc(awrd);
                    <B><FONT color="#000080">if</FONT></B>(dptr != NULL)
                    {
                       <B><FONT color="#000080">if</FONT></B>(dptr-&gt;IsClass())
                       {
                          sprintf(drdr, <FONT color="#800000">"found [class] %s [%lx]"</FONT>, dptr-&gt;Name().c_str(), dptr);
                       }
                       <B><FONT color="#000080">else</FONT></B>
                       {
                          sprintf(drdr, <FONT color="#800000">"OBECT NOT CLASS %s [%lx]"</FONT>, dptr-&gt;Name().c_str(), dptr);
                       }
                    }
                    <B><FONT color="#000080">else</FONT></B>
                    {
                       sprintf(drdr, <FONT color="#800000">"NO object from  cd-&gt;DataDesc(awrd)"</FONT>);
                    }
                    idat.DebugTrace(drdr);
                }
                <B><FONT color="#000080">else</FONT></B>
                {
                    <I><FONT color="#008080">// error not compiling class</FONT></I>
                    idat.ShowError(Errors::NO_CLASS_EXISTS);
                }
            }
            <B><FONT color="#000080">else</FONT></B>
            {
                <I><FONT color="#008080">// error method name expected</FONT></I>
                <I><FONT color="#008080">// trying to name a word with a number error</FONT></I>
                idat.ShowError(Errors::IS_NUMBER);
            }
        }
        <B><FONT color="#000080">else</FONT></B>
        {
            <I><FONT color="#008080">// error word exists</FONT></I>
            <I><FONT color="#008080">// word already exists error</FONT></I>
            idat.ShowError(Errors::WORD_EXISTS, awrd);
        }
    }
    <B><FONT color="#000080">else</FONT></B>
    {
        <I><FONT color="#008080">// buffer end reached</FONT></I>
        idat.ShowError(Errors::BUFFER_END);
    }
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_MethodSemicolon(InterpreterData & idat)
{
    <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
    {
        ClassDescription * cd = idat.ClassDSCR()-&gt;CompilingWhat(); 
        <B><FONT color="#000080">if</FONT></B>(cd-&gt;IsMethodCompiling() == true)
        {
            ClassMethod * nm = <B><FONT color="#000080">new</FONT></B> ClassMethod(*(idat.Building()), cd);
            <B><FONT color="#000080">delete</FONT></B> (idat.Building());
<I><FONT color="#008080">//            nm-&gt;AddClassDecription(cd);</FONT></I>
            cd-&gt;AddMethod(*nm, false);
            <B><FONT color="#000080">delete</FONT></B> nm;
            cd-&gt;SetMethodCompile(false);
            idat.EndCompile();
        }
        <B><FONT color="#000080">else</FONT></B>
        {
            <I><FONT color="#008080">// Show Error 1 Syntax error</FONT></I>
            idat.ShowError(Errors::NOT_COMPILING_METHOD);
        }
    }
    <B><FONT color="#000080">else</FONT></B>
    {
        <I><FONT color="#008080">// Show Error 1 Syntax error</FONT></I>
        idat.ShowError(Errors::SYNTAX_ERROR);
    }
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_MethodColon(InterpreterData & idat)
{
    string awrd;
    awrd.reserve(<FONT color="#800000">120</FONT>);
    Parser * par = idat.IParser();
    <B><FONT color="#000080">char</FONT></B> * wrd;
    
    <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
    {
        <I><FONT color="#008080">// the word variable is only interpreted "to compile a class'</FONT></I>
        <I><FONT color="#008080">// then the name it compiles is a new forth word</FONT></I>
        idat.ShowError(Errors::ILLEGALDEFINING);
        <B><FONT color="#000080">return</FONT></B>;
    }
    
    <B><FONT color="#000080">if</FONT></B>((wrd = par-&gt;NextWord()) != NULL)
    {
        awrd = wrd;
<I><FONT color="#008080">//        if(idat.IDict()-&gt;Exists(awrd) == -1)  // word does not exist</FONT></I>
<I><FONT color="#008080">//        {</FONT></I>
            <B><FONT color="#000080">if</FONT></B>(!par-&gt;AllDigits(wrd))  <I><FONT color="#008080">// word is not a number</FONT></I>
            {
                ClassDescription * cd = idat.ClassDSCR()-&gt;CompilingWhat(); 
                <B><FONT color="#000080">if</FONT></B>(cd != NULL)
                {
                    <B><FONT color="#000080">if</FONT></B>(cd-&gt;IsMethodCompiling() == false)
                    {
                        idat.DebugTrace(<FONT color="#800000">"Starting method"</FONT>);
                        cd-&gt;SetMethodCompile(true);
                        idat.BuildWithName(awrd);
                        idat.Compile();
                    }
                    <B><FONT color="#000080">else</FONT></B>
                    {
                        <I><FONT color="#008080">// error alredy building method</FONT></I>
                        idat.ShowError(Errors::COMPILING_METHOD);
                    }
                }
                <B><FONT color="#000080">else</FONT></B>
                {
                    <I><FONT color="#008080">// error not compiling class</FONT></I>
                    idat.ShowError(Errors::NO_CLASS_EXISTS);
                }
            }
            <B><FONT color="#000080">else</FONT></B>
            {
                <I><FONT color="#008080">// error method name expected</FONT></I>
                <I><FONT color="#008080">// trying to name a word with a number error</FONT></I>
                idat.ShowError(Errors::IS_NUMBER);
            }
<I><FONT color="#008080">//        }</FONT></I>
<I><FONT color="#008080">//        else</FONT></I>
<I><FONT color="#008080">//        {</FONT></I>
            <I><FONT color="#008080">// error word exists</FONT></I>
            <I><FONT color="#008080">// word already exists error</FONT></I>
<I><FONT color="#008080">//            idat.ShowError(Errors::WORD_EXISTS);</FONT></I>
<I><FONT color="#008080">//        }</FONT></I>
    }
    <B><FONT color="#000080">else</FONT></B>
    {
        <I><FONT color="#008080">// buffer end reached</FONT></I>
        idat.ShowError(Errors::BUFFER_END);
    }
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_This(InterpreterData & idat)
{
    ClassDescription * aa = NULL;  
    aa = (ClassDescription *) idat.PopD();
    <B><FONT color="#000080">char</FONT></B> * bb = aa-&gt;ThisFront();
    idat.PushD(((<B><FONT color="#000080">long</FONT></B>)bb));
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_DashRightGreater(InterpreterData & idat)
{
    string awrd, bwrd;
    awrd.reserve(<FONT color="#800000">120</FONT>);
    Parser * par = idat.IParser();
    <B><FONT color="#000080">char</FONT></B> * wrd;

  <B><FONT color="#000080">char</FONT></B> * cc = NULL;;
  ClassDescription * aa = NULL;;
  Element *anel = NULL;


  <B><FONT color="#000080">if</FONT></B>((wrd = par-&gt;NextWord()) != NULL)
   {
       awrd = wrd;
       aa = idat.ClassDSCR()-&gt;Find(awrd);
       <B><FONT color="#000080">if</FONT></B>(aa == NULL)
       {
          <I><FONT color="#008080">// Show Error 1 Syntax error</FONT></I>
         idat.ShowError(Errors::SYNTAX_ERROR);
         <B><FONT color="#000080">return</FONT></B>;
       }
  }
  
  <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
  {
    <B><FONT color="#000080">if</FONT></B>((wrd = par-&gt;NextWord()) != NULL)
    {
         awrd = wrd;
         ClassMethod * pcm = aa-&gt;MethodDesc(awrd);
         ClassData * pcd = aa-&gt;DataDesc(awrd);

         <B><FONT color="#000080">char</FONT></B> test1[<FONT color="#800000">200</FONT>];
         sprintf(test1, <FONT color="#800000">" class description in '-&gt;' = %lx, method = %lx, data = %lx"</FONT>, (<B><FONT color="#000080">void</FONT></B> *)aa,
             (<B><FONT color="#000080">void</FONT></B> *)pcm, (<B><FONT color="#000080">void</FONT></B> *)pcd);
         idat.DebugTrace(test1); 

         <B><FONT color="#000080">if</FONT></B>(pcm != NULL)
         {  
             <B><FONT color="#000080">if</FONT></B>(pcm-&gt;FlagsMatch(ClassMethod::Private) == <FONT color="#800000">0</FONT> && pcm-&gt;FlagsMatch(ClassMethod::Protected) == <FONT color="#800000">0</FONT>)
             {
                idat.BuildAddElement(pcm);
             }
             <B><FONT color="#000080">else</FONT></B>
             {
                idat.ShowError(Errors::PRIVATE_METHOD);
             }
         }
         <B><FONT color="#000080">else</FONT></B>
         {
            <B><FONT color="#000080">if</FONT></B>(pcd != NULL)
            {         
               <B><FONT color="#000080">if</FONT></B>(pcd-&gt;FlagsMatch(ClassData::Private) == <FONT color="#800000">0</FONT> && pcm-&gt;FlagsMatch(ClassData::Protected) == <FONT color="#800000">0</FONT>)
               {
                  idat.BuildAddElement(pcd);
               }
               <B><FONT color="#000080">else</FONT></B>
               {
                  idat.ShowError(Errors::PRIVATE_MEMBER);
               }
            }
            <B><FONT color="#000080">else</FONT></B>
            {              
                <I><FONT color="#008080">// no class member error</FONT></I>
                idat.ShowError(Errors::NO_MEMBER_FOUND);
            }
         }
    }
    <B><FONT color="#000080">else</FONT></B>
    {
       idat.ShowError(Errors::BUFFER_END);
    }
  }
  <B><FONT color="#000080">else</FONT></B>
  {
    <B><FONT color="#000080">if</FONT></B>((wrd = par-&gt;NextWord()) != NULL)
    {
         awrd = wrd;
         cc = (<B><FONT color="#000080">char</FONT></B> *) idat.PopD(); 
 
         ClassMethod * pcm = aa-&gt;MethodDesc(awrd);
         ClassData * pcd = aa-&gt;DataDesc(awrd);

         <B><FONT color="#000080">char</FONT></B> test1[<FONT color="#800000">200</FONT>];
         sprintf(test1, <FONT color="#800000">" class description in '-&gt;' = %lx, method = %lx, data = %lx"</FONT>, (<B><FONT color="#000080">void</FONT></B> *)aa,
             (<B><FONT color="#000080">void</FONT></B> *)pcm, (<B><FONT color="#000080">void</FONT></B> *)pcd);
         idat.DebugTrace(test1); 

         <B><FONT color="#000080">if</FONT></B>(pcm != NULL)
         {       
            idat.PushD((<B><FONT color="#000080">long</FONT></B>) cc);
            pcm-&gt;Execute(<FONT color="#800000">0</FONT>, idat); 
         } 
         <B><FONT color="#000080">else</FONT></B>
         {
            <B><FONT color="#000080">if</FONT></B>(pcd != NULL)
            {  
               idat.PushD((<B><FONT color="#000080">long</FONT></B>) cc);
               pcd-&gt;Resolve(idat);
            }
            <B><FONT color="#000080">else</FONT></B>
            {
               <I><FONT color="#008080">// no class member error</FONT></I>
                idat.ShowError(Errors::NO_MEMBER_FOUND);
            }
         }
    }
  }
}


<B><FONT color="#000080">void</FONT></B> Primitives::L_DashDot(InterpreterData & idat)
{
  string awrd;
  awrd.reserve(<FONT color="#800000">120</FONT>);
  Parser * par = idat.IParser();
  <B><FONT color="#000080">char</FONT></B> * wrd;

  <B><FONT color="#000080">char</FONT></B> * cc = NULL;;
  ClassDescription * aa = NULL;;
  Element *anel = NULL;
  
  <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
  {
    <B><FONT color="#000080">if</FONT></B>((wrd = par-&gt;NextWord()) != NULL)
    {
         awrd = wrd;
         aa = (ClassDescription *)idat.PopD(); 
         ClassMethod * pcm = aa-&gt;MethodDesc(awrd);
         ClassData * pcd = aa-&gt;DataDesc(awrd);

         <B><FONT color="#000080">char</FONT></B> test1[<FONT color="#800000">200</FONT>];
         sprintf(test1, <FONT color="#800000">" class description in L_DashDot = %lx, method = %lx, data = %lx"</FONT>, (<B><FONT color="#000080">void</FONT></B> *)aa,
             (<B><FONT color="#000080">void</FONT></B> *)pcm, (<B><FONT color="#000080">void</FONT></B> *)pcd);
         idat.DebugTrace(test1); 

         <B><FONT color="#000080">if</FONT></B>(pcm != NULL)
         {  
             <B><FONT color="#000080">if</FONT></B>(pcm-&gt;FlagsMatch(ClassMethod::Private) == <FONT color="#800000">0</FONT> && pcm-&gt;FlagsMatch(ClassMethod::Protected) == <FONT color="#800000">0</FONT>)
             {
                idat.BuildAddElement(pcm);
             }
             <B><FONT color="#000080">else</FONT></B>
             {
                idat.ShowError(Errors::PRIVATE_METHOD);
             }
         }
         <B><FONT color="#000080">else</FONT></B>
         {
            <B><FONT color="#000080">if</FONT></B>(pcd != NULL)
            {         
               <B><FONT color="#000080">if</FONT></B>(pcd-&gt;FlagsMatch(ClassData::Private) == <FONT color="#800000">0</FONT> && pcm-&gt;FlagsMatch(ClassData::Protected) == <FONT color="#800000">0</FONT>)
               {
                  idat.BuildAddElement(pcd);
               }
               <B><FONT color="#000080">else</FONT></B>
               {
                  idat.ShowError(Errors::PRIVATE_MEMBER);
               }
            }
            <B><FONT color="#000080">else</FONT></B>
            {              
                <I><FONT color="#008080">// no class member error</FONT></I>
                idat.ShowError(Errors::NO_MEMBER_FOUND);
            }
         }
    }
    <B><FONT color="#000080">else</FONT></B>
    {
       idat.ShowError(Errors::BUFFER_END);
    }
  }
  <B><FONT color="#000080">else</FONT></B>
  {
    <B><FONT color="#000080">if</FONT></B>((wrd = par-&gt;NextWord()) != NULL)
    {
         awrd = wrd;
         cc = (<B><FONT color="#000080">char</FONT></B> *) idat.PopD(); 
         aa = (ClassDescription *)idat.PopD(); 
         ClassMethod * pcm = aa-&gt;MethodDesc(awrd);
         ClassData * pcd = aa-&gt;DataDesc(awrd);

         <B><FONT color="#000080">char</FONT></B> test1[<FONT color="#800000">200</FONT>];
         sprintf(test1, <FONT color="#800000">" class description in L_DashDot = %lx, method = %lx, data = %lx"</FONT>, (<B><FONT color="#000080">void</FONT></B> *)aa,
             (<B><FONT color="#000080">void</FONT></B> *)pcm, (<B><FONT color="#000080">void</FONT></B> *)pcd);
         idat.DebugTrace(test1); 

         <B><FONT color="#000080">if</FONT></B>(pcm != NULL)
         {       
            idat.PushD((<B><FONT color="#000080">long</FONT></B>) cc);
            pcm-&gt;Execute(<FONT color="#800000">0</FONT>, idat); 
         } 
         <B><FONT color="#000080">else</FONT></B>
         {
            <B><FONT color="#000080">if</FONT></B>(pcd != NULL)
            {  
               idat.PushD((<B><FONT color="#000080">long</FONT></B>) cc);
               pcd-&gt;Resolve(idat);
            }
            <B><FONT color="#000080">else</FONT></B>
            {
               <I><FONT color="#008080">// no class member error</FONT></I>
                idat.ShowError(Errors::NO_MEMBER_FOUND);
            }
         }
    }
  } 
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_ExecuteConstructor(InterpreterData & idat)
{
       <B><FONT color="#000080">long</FONT></B> Aobj = idat.PopD();   <I><FONT color="#008080">// 'obj</FONT></I>
       ClassDescription * cd = (ClassDescription *) idat.PopD();     <I><FONT color="#008080">// 'cd</FONT></I>
       cd-&gt;CallConstructor((<B><FONT color="#000080">char</FONT></B> *)Aobj);
       idat.PushD(((<B><FONT color="#000080">long</FONT></B>)cd));
       idat.PushD(Aobj);
}

<I><FONT color="#008080">// Function name    : Primitives::L_DeleteClass</FONT></I>
<I><FONT color="#008080">// Description      : ( void * ---  )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_DeleteClass(InterpreterData & idat)
{
    <B><FONT color="#000080">void</FONT></B> *zz = ((<B><FONT color="#000080">void</FONT></B> *) idat.PopD());
    
    <B><FONT color="#000080">int</FONT></B> mt = (idat.MManager()).Typeof(zz); 
    <B><FONT color="#000080">if</FONT></B>(mt != -<FONT color="#800000">1</FONT>)
    {
        <B><FONT color="#000080">if</FONT></B>(mt == MemInstDat::m_Class)
        {
            <B><FONT color="#000080">int</FONT></B> mh = (idat.MManager()).Hintof(zz); 
            ClassDescription * cd = (ClassDescription *) mh;
            <B><FONT color="#000080">if</FONT></B>(cd != NULL)
            {
                idat.PushD((<B><FONT color="#000080">long</FONT></B>)zz);
                cd-&gt;CallDestructor();
            }
        }
        (idat.MManager()).DeleteMem(zz, MemInstDat::m_Class);
    }
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_NewClass(InterpreterData & idat)
{
  string awrd;
  awrd.reserve(<FONT color="#800000">120</FONT>);
  Parser * par = idat.IParser();
  <B><FONT color="#000080">char</FONT></B> * wrd;  

 idat.DebugTrace(<FONT color="#800000">"In 'new'  L_NewClass"</FONT>); 

 <B><FONT color="#000080">if</FONT></B>((wrd = par-&gt;NextWord()) != NULL)
 {
    awrd = wrd;
    ClassDescription * cd = NULL; 
    <B><FONT color="#000080">if</FONT></B>((cd = idat.ClassDSCR()-&gt;Find(awrd)) != NULL)
    {
       <B><FONT color="#000080">void</FONT></B> * vp = idat.MManager().AllocateType(MemInstDat::m_Class, cd-&gt;Size());
       cd-&gt;CallConstructor((<B><FONT color="#000080">char</FONT></B> *)vp);
       idat.PushD((<B><FONT color="#000080">long</FONT></B>)vp);
    }
    <B><FONT color="#000080">else</FONT></B>
    {
       idat.ShowError(Errors::NO_CLASS_EXISTS);
    }
 }
 <B><FONT color="#000080">else</FONT></B>
 {
      <I><FONT color="#008080">// buffer end reached</FONT></I>
      idat.ShowError(Errors::BUFFER_END);   
 }
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_MakeClassCompileTest(InterpreterData & idat)
{
    <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
    {
       <B><FONT color="#000080">long</FONT></B> Aobj = idat.PopD();   <I><FONT color="#008080">// 'obj</FONT></I>
       <B><FONT color="#000080">long</FONT></B> cd = idat.PopD();     <I><FONT color="#008080">// 'cd</FONT></I>
       idat.BuildAddElement(Aobj);        <I><FONT color="#008080">// put 'obj in new element</FONT></I>
       idat.PushD(cd);                    <I><FONT color="#008080">// push cd for '-:' use</FONT></I>
    }
}

<I><FONT color="#008080">// makes a named instance of a class</FONT></I>
<I><FONT color="#008080">// The class name when executed will put it's class descripter and class object on the stack</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_MakeClass(InterpreterData & idat)
{
  string awrd;
  awrd.reserve(<FONT color="#800000">120</FONT>);
  Parser * par = idat.IParser();
  <B><FONT color="#000080">char</FONT></B> * wrd;

  <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
  {
      idat.DebugTrace(<FONT color="#800000">"Still compiling word type??"</FONT>); 
      idat.ShowError(Errors::ILLEGALDEFINING);
      <B><FONT color="#000080">return</FONT></B>;
  }

 idat.DebugTrace(<FONT color="#800000">"In L_MakeClass"</FONT>); 

 <B><FONT color="#000080">if</FONT></B>((wrd = par-&gt;NextWord()) != NULL)
 {
    awrd = wrd;
    <B><FONT color="#000080">if</FONT></B>(idat.IDict()-&gt;Exists(awrd) == -<FONT color="#800000">1</FONT>)  <I><FONT color="#008080">// word does not exist</FONT></I>
    {
         <B><FONT color="#000080">if</FONT></B>(!par-&gt;AllDigits(wrd))  <I><FONT color="#008080">// word is not a number</FONT></I>
         {
           <B><FONT color="#000080">long</FONT></B> aa = idat.PopD(); 
           ClassDescription * cd = (ClassDescription *) aa;
           <B><FONT color="#000080">char</FONT></B> test1[<FONT color="#800000">200</FONT>];
           sprintf(test1, <FONT color="#800000">"cd = %lx in L_MakeClass"</FONT>, (<B><FONT color="#000080">void</FONT></B> *)cd);
           idat.DebugTrace(test1); 

           <B><FONT color="#000080">if</FONT></B>(cd-&gt;Compiling() == false)
           {
              idat.BuildWithName(awrd);
              idat.BuildAddElement(aa);            <I><FONT color="#008080">// put long in new element</FONT></I>
              idat.DebugTrace(<FONT color="#800000">"class descriptor added"</FONT>); 
              <B><FONT color="#000080">void</FONT></B> * vp = idat.MManager().AllocateType(MemInstDat::m_Class, cd-&gt;Size());
              idat.BuildAddElement((<B><FONT color="#000080">long</FONT></B>)vp);
              sprintf(test1, <FONT color="#800000">"%s instance created at %lx"</FONT>, cd-&gt;Name().c_str(), (<B><FONT color="#000080">char</FONT></B> *)vp);
              idat.DebugTrace(test1);
              cd-&gt;CallConstructor((<B><FONT color="#000080">char</FONT></B> *)vp);

<I><FONT color="#008080">//              Element *cpel = new Element(L_ExecuteConstructor);</FONT></I>
<I><FONT color="#008080">//              idat.BuildAddElement((*cpel));</FONT></I>
<I><FONT color="#008080">//              idat.DebugTrace("Added class constructor call ");</FONT></I>
<I><FONT color="#008080">//              delete cpel;  </FONT></I>
              Element *pel = <B><FONT color="#000080">new</FONT></B> Element(L_MakeClassCompileTest);
              idat.BuildAddElement((*pel));
              idat.Building()-&gt;SetFlags(idat.ExecuteCompile);  <I><FONT color="#008080">// set new named instance so immediate</FONT></I>
              idat.BuildFinishWord();
              <B><FONT color="#000080">delete</FONT></B> pel;
           }
           <B><FONT color="#000080">else</FONT></B>
           {
              idat.DebugTrace(<FONT color="#800000">"Still compiling class type??"</FONT>); 
              idat.ShowError(Errors::ILLEGALDEFINING);
           }
         }
         <B><FONT color="#000080">else</FONT></B>
         {
            <I><FONT color="#008080">// trying to name a word with a number error</FONT></I>
            idat.ShowError(Errors::IS_NUMBER);
         }
    }
    <B><FONT color="#000080">else</FONT></B>
     {
        <I><FONT color="#008080">// word already exists error</FONT></I>
        idat.ShowError(Errors::WORD_EXISTS, awrd);
     }
 } 
 <B><FONT color="#000080">else</FONT></B>
 {
      <I><FONT color="#008080">// buffer end reached</FONT></I>
      idat.ShowError(Errors::BUFFER_END);
 }
}

<I><FONT color="#008080">// Function name    : Primitives::L_class</FONT></I>
<I><FONT color="#008080">// Description      : starts a class</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_class(InterpreterData & idat)
{
  string awrd;
  awrd.reserve(<FONT color="#800000">120</FONT>);
  Parser * par = idat.IParser();
  <B><FONT color="#000080">char</FONT></B> * wrd;

  <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
  {
     <I><FONT color="#008080">// the word variable is only interpreted "to compile a class'</FONT></I>
     <I><FONT color="#008080">// then the name it compiles is a new forth word</FONT></I>
      idat.ShowError(Errors::ILLEGALDEFINING);
      <B><FONT color="#000080">return</FONT></B>;
  }

 <B><FONT color="#000080">if</FONT></B>((wrd = par-&gt;NextWord()) != NULL)
 {
    awrd = wrd;
    <B><FONT color="#000080">if</FONT></B>(idat.IDict()-&gt;Exists(awrd) == -<FONT color="#800000">1</FONT>)  <I><FONT color="#008080">// word does not exist</FONT></I>
    {
         <B><FONT color="#000080">if</FONT></B>(!par-&gt;AllDigits(wrd))  <I><FONT color="#008080">// word is not a number</FONT></I>
         {
               ClassDescription * cd = NULL; 
               <B><FONT color="#000080">if</FONT></B>(idat.ClassDSCR()-&gt;Find(awrd, cd) == false)
               {
                  cd = <B><FONT color="#000080">new</FONT></B> ClassDescription(awrd, &idat);
                  idat.ClassDSCR()-&gt;AddDescription((*cd));
                  <B><FONT color="#000080">delete</FONT></B> cd;
                  
                  cd = idat.ClassDSCR()-&gt;CompilingWhat();
                  <B><FONT color="#000080">if</FONT></B>(cd == NULL)
                  {
                     idat.DebugTrace(<FONT color="#800000">"&gt;&gt;&gt;false returned from iidat.ClassDSCR()-&gt;CompilingWhat() in class:"</FONT>);
                  }
                  <B><FONT color="#000080">else</FONT></B>
                  {
                    idat.DebugTrace(<FONT color="#800000">"&gt;&gt;&gt;Non-NULL returned from idat.ClassDSCR()-&gt;CompilingWhat() in class:"</FONT>);
<I><FONT color="#008080">//                  ClassMethod * mp = new ClassMethod();</FONT></I>
<I><FONT color="#008080">//                  mp-&gt;SetFlags(idat.Private);</FONT></I>
                    idat.BuildWithName(awrd);
                    idat.BuildAddElement((<B><FONT color="#000080">long</FONT></B>)cd);
                    Element *pel = <B><FONT color="#000080">new</FONT></B> Element(L_MakeClass);
                    idat.BuildAddElement((*pel));
                    idat.Building()-&gt;SetFlags(idat.ExecuteCompile);  <I><FONT color="#008080">// set new class type so immediate</FONT></I>
                    idat.BuildFinishWord();
                    <B><FONT color="#000080">delete</FONT></B> pel;
                  }
                }
               <B><FONT color="#000080">else</FONT></B>
               {
                <I><FONT color="#008080">// class already exists error</FONT></I>
                   idat.ShowError(Errors::CLASS_EXISTS);
               }
         }
         <B><FONT color="#000080">else</FONT></B>
         {
            <I><FONT color="#008080">// trying to name a word with a number error</FONT></I>
            idat.ShowError(Errors::IS_NUMBER);
         }
    }
    <B><FONT color="#000080">else</FONT></B>
     {
        <I><FONT color="#008080">// word already exists error</FONT></I>
        idat.ShowError(Errors::WORD_EXISTS, awrd);
     }
 } 
 <B><FONT color="#000080">else</FONT></B>
 {
      <I><FONT color="#008080">// buffer end reached</FONT></I>
      idat.ShowError(Errors::BUFFER_END);
 }
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_endclass(InterpreterData & idat)
{
  ClassDescription * cd = idat.ClassDSCR()-&gt;CompilingWhat(); 
  <B><FONT color="#000080">if</FONT></B>(cd != NULL)
  {
    idat.ClassDSCR()-&gt;Compiled();
  }
  <B><FONT color="#000080">else</FONT></B>
  {
      <I><FONT color="#008080">// buffer end reached</FONT></I>
      idat.ShowError(Errors::NO_CLASS_EXISTS);
  }
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_privatecolon(InterpreterData & idat)
{
  ClassDescription * cd = idat.ClassDSCR()-&gt;CompilingWhat(); 
  <B><FONT color="#000080">if</FONT></B>(cd != NULL)
  {
    cd-&gt;SetPrivateMode(true);
  }
  <B><FONT color="#000080">else</FONT></B>
  {
      <I><FONT color="#008080">// buffer end reached</FONT></I>
      idat.ShowError(Errors::NO_CLASS_EXISTS);
  }
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_publiccolon(InterpreterData & idat)
{
  ClassDescription * cd = idat.ClassDSCR()-&gt;CompilingWhat(); 
  <B><FONT color="#000080">if</FONT></B>(cd != NULL)
  {
    cd-&gt;SetPrivateMode(false);
  }
  <B><FONT color="#000080">else</FONT></B>
  {
      <I><FONT color="#008080">// buffer end reached</FONT></I>
      idat.ShowError(Errors::NO_CLASS_EXISTS);
  }
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_protectedcolon(InterpreterData & idat)
{
  ClassDescription * cd = idat.ClassDSCR()-&gt;CompilingWhat(); 
  <B><FONT color="#000080">if</FONT></B>(cd != NULL)
  {
    cd-&gt;SetPrivateMode(false);
  }
  <B><FONT color="#000080">else</FONT></B>
  {
      <I><FONT color="#008080">// buffer end reached</FONT></I>
      idat.ShowError(Errors::NO_CLASS_EXISTS);
  }
}

<I><FONT color="#008080">// := class inheritance</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_ColonEqual(InterpreterData & idat)
{
    string awrd;
    awrd.reserve(<FONT color="#800000">120</FONT>);
    Parser * par = idat.IParser();
    <B><FONT color="#000080">char</FONT></B> * wrd;
    
    <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
    {
        <I><FONT color="#008080">// the word := is only interpreted "to compile a class'</FONT></I>
        idat.ShowError(Errors::ILLEGALDEFINING);
        <B><FONT color="#000080">return</FONT></B>;
    }
    
    <B><FONT color="#000080">if</FONT></B>((wrd = par-&gt;NextWord()) != NULL)
    {
        awrd = wrd;
        <B><FONT color="#000080">if</FONT></B>(idat.IDict()-&gt;Exists(awrd) != -<FONT color="#800000">1</FONT>)  <I><FONT color="#008080">// word does exist</FONT></I>
        {
           ClassDescription * cd = NULL;
           <B><FONT color="#000080">if</FONT></B>((cd = idat.ClassDSCR()-&gt;CompilingWhat()) != NULL)
           {
               <B><FONT color="#000080">if</FONT></B>(cd-&gt;IsPrivateMode())
               {
                   cd-&gt;Inherit(awrd, ClassDescription::CompilePrivate);
               }
               <B><FONT color="#000080">else</FONT></B>
               {
                   <B><FONT color="#000080">if</FONT></B>(cd-&gt;IsProtectedMode())
                   {
                       cd-&gt;Inherit(awrd, ClassDescription::CompileProtected); 
                   }
                   <B><FONT color="#000080">else</FONT></B>
                   {
                       cd-&gt;Inherit(awrd, ClassDescription::CompilePublic); 
                   }
               }
           }
           <B><FONT color="#000080">else</FONT></B>
           {
              idat.ShowError(Errors::NO_CLASS_EXISTS);
           }
        }
        <B><FONT color="#000080">else</FONT></B>
        {
            idat.ShowError(Errors::NO_CLASS_EXISTS);
        }
    }
    <B><FONT color="#000080">else</FONT></B>
    {
        <I><FONT color="#008080">// buffer end reached</FONT></I>
        idat.ShowError(Errors::BUFFER_END);
    }
}


<B><FONT color="#000080">void</FONT></B> Primitives::L_DecompileClass(InterpreterData & idat)
{
  string awrd;
  awrd.reserve(<FONT color="#800000">120</FONT>);
  Parser * par = idat.IParser();
  <B><FONT color="#000080">char</FONT></B> * wrd;

  ClassDescription * cd = NULL; 
  
    <B><FONT color="#000080">if</FONT></B>((wrd = par-&gt;NextWord()) != NULL)
    {
      awrd = wrd;
      <B><FONT color="#000080">if</FONT></B>((cd = idat.ClassDSCR()-&gt;Find(awrd)))
      {
         string txt;
         txt.reserve(<FONT color="#800000">4000</FONT>);
         cd-&gt;Decompile(txt, idat);
         idat.Out() += txt;
         idat.WriteOut();
         idat.LineOut();
      }
    }
    <B><FONT color="#000080">else</FONT></B>
    {
      idat.ShowError(Errors::BUFFER_END);
    }
}

<I><FONT color="#008080">// end class words</FONT></I>

<I><FONT color="#008080">// Function name    : Primitives::L_bracketcharbracket</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_bracketcharbracket(InterpreterData & idat)
{
  string awrd;
  awrd.reserve(<FONT color="#800000">120</FONT>);
  Parser * par = idat.IParser();
  <B><FONT color="#000080">char</FONT></B> * wrd;

  <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
  { 
     <B><FONT color="#000080">if</FONT></B>((wrd = par-&gt;NextWord()) != NULL)
     {
          <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> nn = (<B><FONT color="#000080">long</FONT></B>) wrd[<FONT color="#800000">0</FONT>];
          idat.BuildAddElement(nn);  
     } 
     <B><FONT color="#000080">else</FONT></B>
     {
          <I><FONT color="#008080">// buffer end reached</FONT></I>
          idat.ShowError(Errors::BUFFER_END);
     }
  }
  <B><FONT color="#000080">else</FONT></B>
  {      
      idat.ShowError(Errors::ONLY_COMPILED);
  }
}

<I><FONT color="#008080">// Function name    : Primitives::L_bracketcharbracket</FONT></I>
<I><FONT color="#008080">// Description      : starts a class</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_char(InterpreterData & idat)
{
    string awrd;
    awrd.reserve(<FONT color="#800000">120</FONT>);
    Parser * par = idat.IParser();
    <B><FONT color="#000080">char</FONT></B> * wrd;
    
    <B><FONT color="#000080">if</FONT></B>((wrd = par-&gt;NextWord()) != NULL)
    {
        awrd = wrd;
        <B><FONT color="#000080">if</FONT></B>(!par-&gt;AllDigits(wrd))  <I><FONT color="#008080">// word is not a number</FONT></I>
        {
            <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> nn = (<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>) wrd[<FONT color="#800000">0</FONT>];
            idat.PushD(nn);
            idat.DebugTrace(wrd);
        }
        <B><FONT color="#000080">else</FONT></B>
        {
            <I><FONT color="#008080">// trying to name a word with a number error</FONT></I>
            idat.ShowError(Errors::IS_NUMBER);
        }
    } 
    <B><FONT color="#000080">else</FONT></B>
    {
        <I><FONT color="#008080">// buffer end reached</FONT></I>
        idat.ShowError(Errors::BUFFER_END);
    }
}

<I><FONT color="#008080">// Function name    : Primitives::L_store</FONT></I>
<I><FONT color="#008080">// Description      : ( &long n -- ) </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_store(InterpreterData & idat)
{
   <B><FONT color="#000080">long</FONT></B> *paa = (<B><FONT color="#000080">long</FONT></B> *) idat.PopD();
   <B><FONT color="#000080">long</FONT></B> aa = idat.PopD();
   *paa = aa;
}

<I><FONT color="#008080">// Function name    : Primitives::L_twostore</FONT></I>
<I><FONT color="#008080">// Description      : ( &long n -- ) </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_twostore(InterpreterData & idat)
{
   <B><FONT color="#000080">long</FONT></B> *paa = (<B><FONT color="#000080">long</FONT></B> *) idat.PopD();
   <B><FONT color="#000080">long</FONT></B> x2 = idat.PopD();
   <B><FONT color="#000080">long</FONT></B> x1 = idat.PopD();
   *paa = x2;
   *(paa +<FONT color="#800000">1</FONT>) = x1;
}


<I><FONT color="#008080">// Function name    : Primitives::L_twofetch</FONT></I>
<I><FONT color="#008080">// Description      : ( &long n -- ) </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_twofetch(InterpreterData & idat)
{
   <B><FONT color="#000080">long</FONT></B> *paa = (<B><FONT color="#000080">long</FONT></B> *) idat.PopD();
   <B><FONT color="#000080">long</FONT></B> x2 = *paa;
   <B><FONT color="#000080">long</FONT></B> x1 = *(paa+<FONT color="#800000">1</FONT>);
   idat.PushD(x1);
   idat.PushD(x2);
}


<I><FONT color="#008080">// Function name    : Primitives::L_plusstore</FONT></I>
<I><FONT color="#008080">// Description      : ( &long n -- )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_plusstore(InterpreterData & idat)
{
   <B><FONT color="#000080">long</FONT></B> *paa = (<B><FONT color="#000080">long</FONT></B> *) idat.PopD();
   <B><FONT color="#000080">long</FONT></B> aa = idat.PopD();
   *paa += aa;
}


<I><FONT color="#008080">// Function name    : Primitives::L_fetch</FONT></I>
<I><FONT color="#008080">// Description      : ( &long -- n )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_fetch(InterpreterData & idat)
{
   <B><FONT color="#000080">long</FONT></B> *paa = (<B><FONT color="#000080">long</FONT></B> *) idat.PopD();
   <B><FONT color="#000080">long</FONT></B> aa = *paa;
   idat.PushD(aa);
}


<I><FONT color="#008080">// Function name    : Primitives::L_oneplus</FONT></I>
<I><FONT color="#008080">// Description      : ( n -- n+1 )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_oneplus(InterpreterData & idat)
{
   <B><FONT color="#000080">long</FONT></B> aa = idat.PopD();
   aa++;
   idat.PushD(aa);
}


<I><FONT color="#008080">// Function name    : Primitives::L_oneminus</FONT></I>
<I><FONT color="#008080">// Description      : ( n -- n-1 )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_oneminus(InterpreterData & idat)
{
   <B><FONT color="#000080">long</FONT></B> aa = idat.PopD();
   aa--;
   idat.PushD(aa);
}

<I><FONT color="#008080">// Function name    : Primitives::L_twoplus</FONT></I>
<I><FONT color="#008080">// Description      : ( n -- n+2 )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_twoplus(InterpreterData & idat)
{
   <B><FONT color="#000080">long</FONT></B> aa = idat.PopD();
   aa += <FONT color="#800000">2</FONT>;
   idat.PushD(aa);
}

<I><FONT color="#008080">// Function name    : Primitives::L_twominus</FONT></I>
<I><FONT color="#008080">// Description      : ( n -- n-2 )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_twominus(InterpreterData & idat)
{
   <B><FONT color="#000080">long</FONT></B> aa = idat.PopD();
   aa -= <FONT color="#800000">2</FONT>;
   idat.PushD(aa);
}

<I><FONT color="#008080">// Function name    : Primitives::L_twotimes</FONT></I>
<I><FONT color="#008080">// Description      : ( n -- 2*n )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_twotimes(InterpreterData & idat)
{
   <B><FONT color="#000080">long</FONT></B> aa = idat.PopD();
   aa = aa + aa;
   idat.PushD(aa);
}

<I><FONT color="#008080">// Function name    : Primitives::L_twoslash</FONT></I>
<I><FONT color="#008080">// Description      : ( n -- n/2 )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_twoslash(InterpreterData & idat)
{
   <B><FONT color="#000080">long</FONT></B> aa = idat.PopD();
   aa = (aa &gt;&gt; <FONT color="#800000">1</FONT>);
   idat.PushD(aa);
}

<I><FONT color="#008080">// Function name    : Primitives::L_abs</FONT></I>
<I><FONT color="#008080">// Description      : ( n -- abs(n) )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_abs(InterpreterData & idat)
{
   <B><FONT color="#000080">long</FONT></B> aa = labs(idat.PopD());
   idat.PushD(aa);
}

<I><FONT color="#008080">// Function name    : Primitives::L_and</FONT></I>
<I><FONT color="#008080">// Description      : ( a b -- a & b )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_and(InterpreterData & idat)
{
   <B><FONT color="#000080">long</FONT></B> aa = idat.PopD();
   <B><FONT color="#000080">long</FONT></B> bb = idat.PopD();
   <B><FONT color="#000080">long</FONT></B> cc = (aa & bb);
   idat.PushD(cc);
}

<I><FONT color="#008080">// Function name    : Primitives::L_or</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_or(InterpreterData & idat)
{
   <B><FONT color="#000080">long</FONT></B> aa = idat.PopD();
   <B><FONT color="#000080">long</FONT></B> bb = idat.PopD();  
   <B><FONT color="#000080">long</FONT></B> cc = (aa | bb);
   idat.PushD(cc);
}

<I><FONT color="#008080">// Function name    : Primitives::L_xor</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_xor(InterpreterData & idat)
{
   <B><FONT color="#000080">long</FONT></B> aa = idat.PopD();
   <B><FONT color="#000080">long</FONT></B> bb = idat.PopD();
   <B><FONT color="#000080">long</FONT></B> cc = (aa ^ bb);
   idat.PushD(cc);
}

<I><FONT color="#008080">// Function name    : Primitives::L_not</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_not(InterpreterData & idat)
{
   <B><FONT color="#000080">long</FONT></B> aa = ~idat.PopD();
   idat.PushD(aa);
}

<I><FONT color="#008080">// Function name    : Primitives::L_rshift</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_rshift(InterpreterData & idat)
{
   <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> sa = idat.PopD();
   <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> aa = idat.PopD();
   idat.PushD((aa &gt;&gt; sa));
}

<I><FONT color="#008080">// Function name    : Primitives::L_lshift</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_lshift(InterpreterData & idat)
{
   <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> sa = idat.PopD();
   <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> aa = idat.PopD();
   idat.PushD((aa &lt;&lt; sa));
}

<I><FONT color="#008080">// Function name    : Primitives::L_invert</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_invert(InterpreterData & idat)
{
   <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> aa = idat.PopD();
<I><FONT color="#008080">// unsigned long bb = aa ^ ULONG_MAX;</FONT></I>
   <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> bb = ~aa;
   idat.PushD(bb);
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_source(InterpreterData & idat)
{
    <B><FONT color="#000080">char</FONT></B> * pp = idat.IParser()-&gt;Lastline();
    
    <B><FONT color="#000080">if</FONT></B>(pp != NULL)
    {
        <B><FONT color="#000080">char</FONT></B> drdr[<FONT color="#800000">120</FONT>];
        sprintf(drdr, <FONT color="#800000">"Source Line %s, (source)"</FONT>, pp);
        idat.DebugTrace(drdr);
        idat.PushD(((<B><FONT color="#000080">long</FONT></B>)pp));
        idat.PushD(((<B><FONT color="#000080">long</FONT></B>)strlen(pp)));   
    }
    <B><FONT color="#000080">else</FONT></B>
    {
        idat.DebugTrace(<FONT color="#800000">"Source Line NULL in source"</FONT>);
        idat.PushD(0l);
        idat.PushD(0l);   
    }
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_state(InterpreterData & idat)
{
  <B><FONT color="#000080">long</FONT></B> l = (<B><FONT color="#000080">long</FONT></B>) idat.State();
  idat.PushD(l);
}

<I><FONT color="#008080">// Function name    : Primitives::L_max</FONT></I>
<I><FONT color="#008080">// Description      : ( a b -- max(a,b) )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_max(InterpreterData & idat)
{
   <B><FONT color="#000080">long</FONT></B> aa = idat.PopD();
   <B><FONT color="#000080">long</FONT></B> bb = idat.PopD();
   <B><FONT color="#000080">if</FONT></B> (aa &gt; bb)
   {
     idat.PushD(aa);
   }
   <B><FONT color="#000080">else</FONT></B>
   {
     idat.PushD(bb);
   }
}

<I><FONT color="#008080">// Function name    : Primitives::L_min</FONT></I>
<I><FONT color="#008080">// Description      : ( a b --- min(a,b) )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_min(InterpreterData & idat)
{
   <B><FONT color="#000080">long</FONT></B> aa = idat.PopD();
   <B><FONT color="#000080">long</FONT></B> bb = idat.PopD();
   <B><FONT color="#000080">if</FONT></B> (aa &gt; bb)
   {
     idat.PushD(bb);
   }
   <B><FONT color="#000080">else</FONT></B>
   {
     idat.PushD(aa);
   }
}

<I><FONT color="#008080">// Function name    : Primitives::L_lessthan</FONT></I>
<I><FONT color="#008080">// Description      : ( b a -- b &lt; a )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_lessthan(InterpreterData & idat)
{
   <B><FONT color="#000080">long</FONT></B> aa = idat.PopD();
   <B><FONT color="#000080">long</FONT></B> bb = idat.PopD();
   <B><FONT color="#000080">if</FONT></B> (aa &gt; bb)
   {
     idat.PushD(-1l);
   }
   <B><FONT color="#000080">else</FONT></B>
   {
     idat.PushD((<B><FONT color="#000080">long</FONT></B>)false);
   }
}

<I><FONT color="#008080">// Function name    : Primitives::L_lessthan</FONT></I>
<I><FONT color="#008080">// Description      : ( b a -- b &lt; a )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_ulessthan(InterpreterData & idat)
{
   <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> aa = idat.PopD();
   <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> bb = idat.PopD();
   <B><FONT color="#000080">if</FONT></B> (aa &gt; bb)
   {
     idat.PushD(-1l);
   }
   <B><FONT color="#000080">else</FONT></B>
   {
     idat.PushD((<B><FONT color="#000080">long</FONT></B>)false);
   }
}

<I><FONT color="#008080">// Function name    : Primitives::L_greaterthan</FONT></I>
<I><FONT color="#008080">// Description      : ( b a -- b &gt; a )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_greaterthan(InterpreterData & idat)
{
   <B><FONT color="#000080">long</FONT></B> aa = idat.PopD();
   <B><FONT color="#000080">long</FONT></B> bb = idat.PopD();
   <B><FONT color="#000080">if</FONT></B> (aa &lt; bb)
   {
     idat.PushD(-1l);
   }
   <B><FONT color="#000080">else</FONT></B>
   {
     idat.PushD((<B><FONT color="#000080">long</FONT></B>)false);
   }
}


<I><FONT color="#008080">// Function name    : Primitives::L_greaterthanequal</FONT></I>
<I><FONT color="#008080">// Description      : ( b a -- b &gt;= a ) </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_greaterthanequal(InterpreterData & idat)
{
   <B><FONT color="#000080">long</FONT></B> aa = idat.PopD();
   <B><FONT color="#000080">long</FONT></B> bb = idat.PopD();
   <B><FONT color="#000080">if</FONT></B> (aa &lt;= bb)
   {
     idat.PushD(-1l);
   }
   <B><FONT color="#000080">else</FONT></B>
   {
     idat.PushD((<B><FONT color="#000080">long</FONT></B>)false);
   }
}


<I><FONT color="#008080">// Function name    : Primitives::L_lessthanequal</FONT></I>
<I><FONT color="#008080">// Description      : ( b a --- b &lt;= a )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_lessthanequal(InterpreterData & idat)
{
   <B><FONT color="#000080">long</FONT></B> aa = idat.PopD();
   <B><FONT color="#000080">long</FONT></B> bb = idat.PopD();
   <B><FONT color="#000080">if</FONT></B> (aa &gt;= bb)
   {
     idat.PushD(-1l);
   }
   <B><FONT color="#000080">else</FONT></B>
   {
     idat.PushD((<B><FONT color="#000080">long</FONT></B>)false);
   }
}


<I><FONT color="#008080">// Function name    : Primitives::L_notequal</FONT></I>
<I><FONT color="#008080">// Description      : ( b a -- b != a )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_notequal(InterpreterData & idat)
{
   <B><FONT color="#000080">long</FONT></B> aa = idat.PopD();
   <B><FONT color="#000080">long</FONT></B> bb = idat.PopD();
   <B><FONT color="#000080">if</FONT></B> (aa != bb)
   {
     idat.PushD(-1l);
   }
   <B><FONT color="#000080">else</FONT></B>
   {
     idat.PushD((<B><FONT color="#000080">long</FONT></B>)false);
   }
}


<I><FONT color="#008080">// Function name    : Primitives::L_equal</FONT></I>
<I><FONT color="#008080">// Description      : ( b a -- b == a )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_equal(InterpreterData & idat)
{
   <B><FONT color="#000080">long</FONT></B> aa = idat.PopD();
   <B><FONT color="#000080">long</FONT></B> bb = idat.PopD();
   <B><FONT color="#000080">if</FONT></B> (aa == bb)
   {
     idat.PushD(-1l);
   }
   <B><FONT color="#000080">else</FONT></B>
   {
     idat.PushD((<B><FONT color="#000080">long</FONT></B>)false);
   }
}

<I><FONT color="#008080">// Function name    : Primitives::L_zeroequal</FONT></I>
<I><FONT color="#008080">// Description      : ( a -- a == 0 )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_zeroequal(InterpreterData & idat)
{
   <B><FONT color="#000080">long</FONT></B> aa = idat.PopD();

   <B><FONT color="#000080">if</FONT></B> (aa == <FONT color="#800000">0</FONT>)
   {
     idat.PushD(-1l);
   }
   <B><FONT color="#000080">else</FONT></B>
   {
     idat.PushD((<B><FONT color="#000080">long</FONT></B>)false);
   }
}


<I><FONT color="#008080">// Function name    : Primitives::L_zeroless</FONT></I>
<I><FONT color="#008080">// Description      : ( a -- a &lt; 0 )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_zeroless(InterpreterData & idat)
{
   <B><FONT color="#000080">long</FONT></B> aa = idat.PopD();

   <B><FONT color="#000080">if</FONT></B> (aa &lt; <FONT color="#800000">0</FONT>)
   {
     idat.PushD(-1l);
   }
   <B><FONT color="#000080">else</FONT></B>
   {
     idat.PushD((<B><FONT color="#000080">long</FONT></B>)false);
   }
}


<I><FONT color="#008080">// Function name    : Primitives::L_zeronot</FONT></I>
<I><FONT color="#008080">// Description      : a -- a != 0 )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_zeronot(InterpreterData & idat)
{
   <B><FONT color="#000080">long</FONT></B> aa = idat.PopD();

   <B><FONT color="#000080">if</FONT></B> (aa != <FONT color="#800000">0</FONT>)
   {
     idat.PushD(-1l);
   }
   <B><FONT color="#000080">else</FONT></B>
   {
     idat.PushD((<B><FONT color="#000080">long</FONT></B>)false);
   }
}


<I><FONT color="#008080">// Function name    : Primitives::L_zerogreater</FONT></I>
<I><FONT color="#008080">// Description      : ( a --- a &gt; 0 )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_zerogreater(InterpreterData & idat)
{
   <B><FONT color="#000080">long</FONT></B> aa = idat.PopD();

   <B><FONT color="#000080">if</FONT></B> (aa &gt; <FONT color="#800000">0</FONT>)
   {
     idat.PushD(true);
   }
   <B><FONT color="#000080">else</FONT></B>
   {
     idat.PushD((<B><FONT color="#000080">long</FONT></B>)false);
   }
}


<I><FONT color="#008080">// Function name    : Primitives::L_negate</FONT></I>
<I><FONT color="#008080">// Description      : ( n --- -n )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_negate(InterpreterData & idat)
{
   <B><FONT color="#000080">long</FONT></B> aa = -idat.PopD();

   idat.PushD(aa);
}



<I><FONT color="#008080">// Function name    : Primitives::L_stringcopy</FONT></I>
<I><FONT color="#008080">// Description      : ( &STLstringt &STLstrings -- &STLstringt )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_stringcopy(InterpreterData & idat)
{
   string *ss = (string *) ((<B><FONT color="#000080">void</FONT></B> *) idat.PopD());
   string *tt = (string *) ((<B><FONT color="#000080">void</FONT></B> *) idat.PopD());
   (*tt) = (*ss);

   idat.PushD((<B><FONT color="#000080">long</FONT></B>) tt);
}

<I><FONT color="#008080">// Function name    : Primitives::L_stringplus</FONT></I>
<I><FONT color="#008080">// Description      : ( &STLstr1 &STLstr2 -- &STLstr1 )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_stringplus(InterpreterData & idat)
{
   string *ss = (string *) ((<B><FONT color="#000080">void</FONT></B> *) idat.PopD());
   string *tt = (string *) ((<B><FONT color="#000080">void</FONT></B> *) idat.PopD());
   (*tt) += (*ss);

   idat.PushD((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>) tt);
}


<I><FONT color="#008080">// Function name    : Primitives::L_stringequal</FONT></I>
<I><FONT color="#008080">// Description      : ( &STLstr1 &STLstr2 --- flag )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_stringequal(InterpreterData & idat)
{
   string *ss = (string *) ((<B><FONT color="#000080">void</FONT></B> *) idat.PopD());
   string *tt = (string *) ((<B><FONT color="#000080">void</FONT></B> *) idat.PopD());

   <B><FONT color="#000080">if</FONT></B> (*ss == *tt)
   {
     idat.PushD(true);
   }
   <B><FONT color="#000080">else</FONT></B>
   {
     idat.PushD((<B><FONT color="#000080">long</FONT></B>)false);
   }
}


<I><FONT color="#008080">// Function name    : Primitives::L_substring</FONT></I>
<I><FONT color="#008080">// Description      : ( &STLstr1 &STLstr2 start length --- &STLstr1)</FONT></I>
<I><FONT color="#008080">//                    puts the substring starting at start of length into str2</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_substring(InterpreterData & idat)
{
   <B><FONT color="#000080">long</FONT></B> length = idat.PopD();
   <B><FONT color="#000080">long</FONT></B> start = idat.PopD();
   string *tt = (string *) ((<B><FONT color="#000080">void</FONT></B> *) idat.PopD());
   string *zz = (string *) ((<B><FONT color="#000080">void</FONT></B> *) idat.PopD());
   *zz = (*tt).substr(start, length);
   idat.PushD((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>) zz);
}

<I><FONT color="#008080">// Function name    : Primitives::L_stringvariable</FONT></I>
<I><FONT color="#008080">// Description      : Defines a STL string </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_stringvariable(InterpreterData & idat)
{
  string awrd;
  Parser * par = idat.IParser();
  <B><FONT color="#000080">char</FONT></B> * wrd;

  <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
  {
     <I><FONT color="#008080">// this word is only interpreted "to compile a variable'</FONT></I>
     <I><FONT color="#008080">// then the name it compiles is a new forth word</FONT></I>
      idat.ShowError(Errors::ILLEGALDEFINING);
      <B><FONT color="#000080">return</FONT></B>;
  }

 <B><FONT color="#000080">if</FONT></B>((wrd = par-&gt;NextWord()) != NULL)
 {
    awrd = wrd;
    <B><FONT color="#000080">if</FONT></B>(idat.IDict()-&gt;Exists(awrd) == -<FONT color="#800000">1</FONT>)  <I><FONT color="#008080">// word does not exist</FONT></I>
    {
         <B><FONT color="#000080">if</FONT></B>(!par-&gt;AllDigits(wrd))         <I><FONT color="#008080">// word is not a number</FONT></I>
         {
           idat.BuildWithName(awrd);
           
<I><FONT color="#008080">//           string *tt = (string *) ((void *) idat.PopD()); </FONT></I>
           string *tt = reinterpret_cast&lt;string *&gt;(idat.PopD());
           <B><FONT color="#000080">if</FONT></B>(tt == NULL)
           {
             idat.ShowError(Errors::BAD_POINTER); 
           }
           string *ss = <B><FONT color="#000080">new</FONT></B> string();
           ss-&gt;reserve(<FONT color="#800000">200</FONT>);
           *ss = *tt;
           idat.BuildAddElement(ss);
           idat.BuildFinishWord();
         }
         <B><FONT color="#000080">else</FONT></B>
         {
            <I><FONT color="#008080">// trying to name a word with a number error</FONT></I>
            idat.ShowError(Errors::IS_NUMBER);
         }
    }
    <B><FONT color="#000080">else</FONT></B>
     {
        <I><FONT color="#008080">// word already exists error</FONT></I>
        idat.ShowError(Errors::WORD_EXISTS, awrd);
     }
 } 
 <B><FONT color="#000080">else</FONT></B>
 {
      <I><FONT color="#008080">// buffer end reached</FONT></I>
      idat.ShowError(Errors::BUFFER_END);
 }
}

<I><FONT color="#008080">// Function name    : Primitives::L_stringtocstr</FONT></I>
<I><FONT color="#008080">// Description      : ( &STLstring &char -- )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_stringtocstr(InterpreterData & idat)
{
   <B><FONT color="#000080">char</FONT></B> *zz = (<B><FONT color="#000080">char</FONT></B> *) ((<B><FONT color="#000080">void</FONT></B> *) idat.PopD());
   string *tt = (string *) ((<B><FONT color="#000080">void</FONT></B> *) idat.PopD());
   string ss = *tt;
   strcpy(zz, ss.c_str());
   zz[ss.size()] = <FONT color="#800000">0</FONT>;
}


<I><FONT color="#008080">// Function name    : Primitives::cstrtostring</FONT></I>
<I><FONT color="#008080">// Description      : ( &char &STLstring -- )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_cstrtostring(InterpreterData & idat)
{
   string *tt = (string *) ((<B><FONT color="#000080">void</FONT></B> *) idat.PopD());
   <B><FONT color="#000080">char</FONT></B> *zz = (<B><FONT color="#000080">char</FONT></B> *) ((<B><FONT color="#000080">void</FONT></B> *) idat.PopD());
   (*tt) = zz;
}

<I><FONT color="#008080">// Function name    : Primitives::cstrtostring</FONT></I>
<I><FONT color="#008080">// Description      : ( &char &STLstring -- )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_chararraylen(InterpreterData & idat)
{
   <B><FONT color="#000080">char</FONT></B> *zz = (<B><FONT color="#000080">char</FONT></B> *) ((<B><FONT color="#000080">void</FONT></B> *) idat.PopD());
   <B><FONT color="#000080">long</FONT></B> len = 0l;
   try
   {
     len = strlen(zz);
   }
   <B><FONT color="#000080">catch</FONT></B>(...)
   {

   }
   idat.PushD(len);
}


<B><FONT color="#000080">void</FONT></B> Primitives::L_chararray(InterpreterData & idat)
{
  string awrd;
  Parser * par = idat.IParser();
  <B><FONT color="#000080">char</FONT></B> * wrd;

  <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
  {
     <I><FONT color="#008080">// the word variable is only interpreted "to compile a variable'</FONT></I>
     <I><FONT color="#008080">// then the name it compiles is a new forth word</FONT></I>
      idat.ShowError(Errors::ILLEGALDEFINING);
      <B><FONT color="#000080">return</FONT></B>;
  }

 <B><FONT color="#000080">if</FONT></B>((wrd = par-&gt;NextWord()) != NULL)
 {
    awrd = wrd;
    <B><FONT color="#000080">if</FONT></B>(idat.IDict()-&gt;Exists(awrd) == -<FONT color="#800000">1</FONT>)  <I><FONT color="#008080">// word does not exist</FONT></I>
    {
         <B><FONT color="#000080">if</FONT></B>(!par-&gt;AllDigits(wrd))         <I><FONT color="#008080">// word is not a number</FONT></I>
         {
           idat.BuildWithName(awrd);
           
           <B><FONT color="#000080">long</FONT></B> aa = idat.PopD();      <I><FONT color="#008080">// get size</FONT></I>
           <B><FONT color="#000080">void</FONT></B> *cc = idat.MManager().AllocateType(MemInstDat::m_CharArray, (aa+<FONT color="#800000">1</FONT>));
           <B><FONT color="#000080">char</FONT></B> *nc = (<B><FONT color="#000080">char</FONT></B> *) cc; 
           memset(nc, <FONT color="#800000">0</FONT>, aa+<FONT color="#800000">1</FONT>);
           idat.BuildAddElement((<B><FONT color="#000080">long</FONT></B>) cc);   <I><FONT color="#008080">// put pointer as long into new element</FONT></I>
           idat.BuildFinishWord();
         }
         <B><FONT color="#000080">else</FONT></B>
         {
            <I><FONT color="#008080">// trying to name a word with a number error</FONT></I>
             idat.ShowError(Errors::IS_NUMBER);
         }
    }
    <B><FONT color="#000080">else</FONT></B>
     {
        <I><FONT color="#008080">// word already exists error</FONT></I>
        idat.ShowError(Errors::WORD_EXISTS, awrd);
     }
 } 
 <B><FONT color="#000080">else</FONT></B>
 {
      <I><FONT color="#008080">// buffer end reached</FONT></I>
     idat.ShowError(Errors::BUFFER_END);
 }
}

<I><FONT color="#008080">// Function name    : Primitives::L_deletechararray</FONT></I>
<I><FONT color="#008080">// Description      : ( &char[] --- flag )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_deletechararray(InterpreterData & idat)
{
   <B><FONT color="#000080">void</FONT></B> *zz = ((<B><FONT color="#000080">void</FONT></B> *) idat.PopD());
   <B><FONT color="#000080">long</FONT></B> rv = (idat.MManager()).DeleteMem(zz, MemInstDat::m_CharArray);
   idat.PushD(rv);
}

<I><FONT color="#008080">// Function name    : Primitives::L_cstore</FONT></I>
<I><FONT color="#008080">// Description      : ( addr c -- )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_cstore(InterpreterData & idat)
{
   <B><FONT color="#000080">char</FONT></B> *buf = (<B><FONT color="#000080">char</FONT></B> *) ((<B><FONT color="#000080">void</FONT></B> *) idat.PopD());
   <B><FONT color="#000080">char</FONT></B> cc = (<B><FONT color="#000080">char</FONT></B>) (idat.PopD());
   *buf = cc;
}

<I><FONT color="#008080">// Function name    : Primitives::L_cfetch</FONT></I>
<I><FONT color="#008080">// Description      : ( addr -- c )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_cfetch(InterpreterData & idat)
{
   <B><FONT color="#000080">char</FONT></B> *buf = (<B><FONT color="#000080">char</FONT></B> *) ((<B><FONT color="#000080">void</FONT></B> *) idat.PopD());
   <B><FONT color="#000080">char</FONT></B> cc = *buf;
   idat.PushD((<B><FONT color="#000080">long</FONT></B>) cc);
}

<I><FONT color="#008080">// Function name    : Primitives::L_cstore</FONT></I>
<I><FONT color="#008080">// Description      : ( addr c -- )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_wstore(InterpreterData & idat)
{
   WORD *buf = (WORD *) ((<B><FONT color="#000080">void</FONT></B> *) idat.PopD());
   WORD cc = (WORD) (idat.PopD());
   *buf = cc;
}

<I><FONT color="#008080">// Function name    : Primitives::L_cfetch</FONT></I>
<I><FONT color="#008080">// Description      : ( addr -- c )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_wfetch(InterpreterData & idat)
{
   WORD *buf = (WORD *) ((<B><FONT color="#000080">void</FONT></B> *) idat.PopD());
   WORD cc = *buf;
   idat.PushD((<B><FONT color="#000080">long</FONT></B>) cc);
}

<I><FONT color="#008080">// Function name    : Primitives::L_greaterin</FONT></I>
<I><FONT color="#008080">// Description      : (  -- adr )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_greaterin(InterpreterData & idat)
{

  idat.PushD(idat.pIN());
}

<I><FONT color="#008080">// Function name    : Primitives::L_type</FONT></I>
<I><FONT color="#008080">// Description      : ( addr len -- )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_type(InterpreterData & idat)
{
   <B><FONT color="#000080">long</FONT></B> aa = ( idat.PopD());
   aa = __min(aa, <FONT color="#800000">8000</FONT>);
   <B><FONT color="#000080">char</FONT></B> *buf = (<B><FONT color="#000080">char</FONT></B> *) ((<B><FONT color="#000080">void</FONT></B> *) idat.PopD());
   <B><FONT color="#000080">char</FONT></B> *cc = <B><FONT color="#000080">new</FONT></B> <B><FONT color="#000080">char</FONT></B>[aa+<FONT color="#800000">1</FONT>];
   strncpy(cc,buf,aa);
   cc[aa] = <FONT color="#800000">0</FONT>;
   string co = cc;
   idat.Out() += co.c_str();
   idat.WriteOut();
   <B><FONT color="#000080">delete</FONT></B> cc;
}

<I><FONT color="#008080">// Function name    : Primitives::L_count</FONT></I>
<I><FONT color="#008080">// Description      : ( addr -- addr count )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_count(InterpreterData & idat)
{
   <B><FONT color="#000080">char</FONT></B> *buf = NULL;
   <B><FONT color="#000080">char</FONT></B> *buf2 = NULL;;
   <B><FONT color="#000080">long</FONT></B> len = <FONT color="#800000">0</FONT>;

   buf = (<B><FONT color="#000080">char</FONT></B> *) idat.PopD();

   <B><FONT color="#000080">if</FONT></B>(buf != NULL)
   {  
      buf2 = buf + <B><FONT color="#000080">sizeof</FONT></B>(<B><FONT color="#000080">long</FONT></B>);
      len = *((<B><FONT color="#000080">long</FONT></B> *)buf);
   }

   len = __min(len, 64000l);
   idat.PushD((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>) buf2);
   idat.PushD(len);
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_find(InterpreterData & idat)
{
    string anam;
    anam.reserve(<FONT color="#800000">120</FONT>);
    Parser * par = idat.IParser();
    <B><FONT color="#000080">char</FONT></B> * cntnam = NULL;
    <B><FONT color="#000080">char</FONT></B> * wrd = NULL;
    <B><FONT color="#000080">char</FONT></B> * nam;
    Word * ww = NULL;

    cntnam = (<B><FONT color="#000080">char</FONT></B> * ) idat.PopD();
    
    <B><FONT color="#000080">if</FONT></B>(cntnam != NULL)
    {
      nam = (cntnam + <B><FONT color="#000080">sizeof</FONT></B>(<B><FONT color="#000080">long</FONT></B>));

      <B><FONT color="#000080">if</FONT></B>((ww = idat.IDict()-&gt;Address(nam)) != NULL)
      {
         idat.PushD((<B><FONT color="#000080">long</FONT></B>)ww);
         <B><FONT color="#000080">if</FONT></B>(ww-&gt;FlagsMatch(idat.ExecuteCompile))
         {
           idat.PushD(<FONT color="#800000">1</FONT>);
         }
         <B><FONT color="#000080">else</FONT></B>
         {
           idat.PushD(-<FONT color="#800000">1</FONT>);
         }
      }
      <B><FONT color="#000080">else</FONT></B>
      {
         idat.PushD((<B><FONT color="#000080">long</FONT></B>)cntnam);
         idat.PushD(0l);
      }  
    }
}


<I><FONT color="#008080">// Function name    : Primitives::L_traceon</FONT></I>
<I><FONT color="#008080">// Description      : turn on tracing</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_traceon(InterpreterData & idat)
{
  idat.TraceOn(); 
  string ts = <FONT color="#800000">" \n----------TRACE-TURNED_ON----------\n "</FONT>;
  idat.TraceOut(ts);
}

<I><FONT color="#008080">// Function name    : Primitives::L_traceoff</FONT></I>
<I><FONT color="#008080">// Description      : turn off tracing</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_traceoff(InterpreterData & idat)
{
  string ts = <FONT color="#800000">" \n----------DONE_TRACE----------\n "</FONT>;
  idat.TraceOut(ts);  
  idat.TraceOff();
}

<I><FONT color="#008080">// Function name    : Primitives::L_addtrace</FONT></I>
<I><FONT color="#008080">// Description      : add string to tracing output</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_addtrace(InterpreterData & idat)
{
  <B><FONT color="#000080">if</FONT></B>(idat.Tracing())
  {
    string *ss = (string *) ((<B><FONT color="#000080">void</FONT></B> *) idat.PopD());
    string ts = <FONT color="#800000">" &gt;&gt;&gt;  "</FONT>;
    ts += (*ss);
    idat.TraceOut(ts);  
  }
}


<I><FONT color="#008080">// Function name    : Primitives::L_stackdepth</FONT></I>
<I><FONT color="#008080">// Description      : ( --- data-stack-depth)</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_stackdepth(InterpreterData & idat)
{
  idat.PushD((<B><FONT color="#000080">long</FONT></B>)idat.SizeD());
}

<I><FONT color="#008080">// need char strcpy, strncopy</FONT></I>
<I><FONT color="#008080">// memcpy, memset</FONT></I>


<I><FONT color="#008080">// Function name    : Primitives::L_strcpy</FONT></I>
<I><FONT color="#008080">// Description      : ( &c_str1 &c_str2 -- )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_strcpy(InterpreterData & idat)
{
   <B><FONT color="#000080">char</FONT></B> *str2 = (<B><FONT color="#000080">char</FONT></B> *) ((<B><FONT color="#000080">void</FONT></B> *) idat.PopD());
   <B><FONT color="#000080">char</FONT></B> *str1 = (<B><FONT color="#000080">char</FONT></B> *) ((<B><FONT color="#000080">void</FONT></B> *) idat.PopD());
   strcpy(str1, str2);
}

<I><FONT color="#008080">// Function name    : Primitives::L_strncpy</FONT></I>
<I><FONT color="#008080">// Description      : ( &c_str1 &c_str2 n -- )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_strncpy(InterpreterData & idat)
{
   <B><FONT color="#000080">long</FONT></B> nn = idat.PopD();
   <B><FONT color="#000080">char</FONT></B> *str2 = (<B><FONT color="#000080">char</FONT></B> *) ((<B><FONT color="#000080">void</FONT></B> *) idat.PopD());
   <B><FONT color="#000080">char</FONT></B> *str1 = (<B><FONT color="#000080">char</FONT></B> *) ((<B><FONT color="#000080">void</FONT></B> *) idat.PopD());
   strncpy(str1, str2, nn);
}

<I><FONT color="#008080">// Function name    : Primitives::L_strncpy</FONT></I>
<I><FONT color="#008080">// Description      : ( &c_str1 &c_str2 n -- )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_memcpy(InterpreterData & idat)
{
  L_strncpy(idat);
}

<I><FONT color="#008080">// Function name    : Primitives::L_memset</FONT></I>
<I><FONT color="#008080">// Description      : ( &c_str1 char nn -- )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_memset(InterpreterData & idat)
{
  <B><FONT color="#000080">long</FONT></B> nn = idat.PopD();
  <B><FONT color="#000080">long</FONT></B> cc = idat.PopD();
  <B><FONT color="#000080">char</FONT></B> *buf = (<B><FONT color="#000080">char</FONT></B> *) ((<B><FONT color="#000080">void</FONT></B> *) idat.PopD());
  memset(buf,cc,nn);
}

<I><FONT color="#008080">// structure name</FONT></I>
<I><FONT color="#008080">//     n char name</FONT></I>
<I><FONT color="#008080">//     n array-of char name</FONT></I>
<I><FONT color="#008080">//</FONT></I>
<I><FONT color="#008080">// end-structure</FONT></I>

<B><FONT color="#000080">void</FONT></B> Primitives::L_createinstance(InterpreterData & idat)
{
  <B><FONT color="#000080">long</FONT></B> aa = idat.PopD();
  <B><FONT color="#000080">void</FONT></B> *cc = idat.MManager().AllocateType(MemInstDat::m_CharArray, (aa+<FONT color="#800000">1</FONT>));
  <B><FONT color="#000080">char</FONT></B> *nc = (<B><FONT color="#000080">char</FONT></B> *) cc; 
  memset(nc, <FONT color="#800000">0</FONT>, aa+<FONT color="#800000">1</FONT>);
  idat.PushD((<B><FONT color="#000080">long</FONT></B> )cc);
}

<I><FONT color="#008080">// structures</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_structure(InterpreterData & idat)
{
  string awrd;
  Parser * par = idat.IParser();
  <B><FONT color="#000080">char</FONT></B> * wrd;

  <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
  {
     <I><FONT color="#008080">// the word structure is only interpreted "to create a structure type'</FONT></I>
     <I><FONT color="#008080">// it compiles is a new forth word</FONT></I>
      idat.ShowError(Errors::ILLEGALDEFINING);
      <B><FONT color="#000080">return</FONT></B>;
  }

 <B><FONT color="#000080">if</FONT></B>((wrd = par-&gt;NextWord()) != NULL)
 {
    awrd = wrd;
    <B><FONT color="#000080">if</FONT></B>(idat.IDict()-&gt;Exists(awrd) == -<FONT color="#800000">1</FONT>)  <I><FONT color="#008080">// word does not exist</FONT></I>
    {
         <B><FONT color="#000080">if</FONT></B>(!par-&gt;AllDigits(wrd))  <I><FONT color="#008080">// word is not a number</FONT></I>
         {
           idat.BuildWithName(awrd);
<I><FONT color="#008080">//           long nn = idat.PopD();</FONT></I>
           idat.BuildAddElement((<B><FONT color="#000080">long</FONT></B>) <FONT color="#800000">0</FONT>);   <I><FONT color="#008080">// space for final size</FONT></I>
           idat.BuildFinishWord();
           Word * ww = idat.IDict()-&gt;Address(awrd);
           idat.PushAD((<B><FONT color="#000080">long</FONT></B>)ww);  <I><FONT color="#008080">// use auillary stack for new word's address</FONT></I>
         }
         <B><FONT color="#000080">else</FONT></B>
         {
            <I><FONT color="#008080">// trying to name a word with a number error</FONT></I>
            idat.ShowError(Errors::IS_NUMBER);
         }
    }
    <B><FONT color="#000080">else</FONT></B>
     {
        <I><FONT color="#008080">// word already exists error</FONT></I>
        idat.ShowError(Errors::WORD_EXISTS, awrd);
     }
 } 
 <B><FONT color="#000080">else</FONT></B>
 {
      <I><FONT color="#008080">// buffer end reached</FONT></I>
     idat.ShowError(Errors::BUFFER_END);
 }
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_Nchar(InterpreterData & idat)
{
  string awrd;
  Parser * par = idat.IParser();
  <B><FONT color="#000080">char</FONT></B> * wrd;

  <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
  {
     <I><FONT color="#008080">// the word structure is only interpreted "to create a structure type'</FONT></I>
     <I><FONT color="#008080">// it compiles is a new forth word</FONT></I>
      idat.ShowError(Errors::ILLEGALDEFINING);
      <B><FONT color="#000080">return</FONT></B>;
  }

 <B><FONT color="#000080">if</FONT></B>((wrd = par-&gt;NextWord()) != NULL)
 {
    awrd = wrd;
    <B><FONT color="#000080">if</FONT></B>(idat.IDict()-&gt;Exists(awrd) == -<FONT color="#800000">1</FONT>)  <I><FONT color="#008080">// word does not exist</FONT></I>
    {
         <B><FONT color="#000080">if</FONT></B>(!par-&gt;AllDigits(wrd))  <I><FONT color="#008080">// word is not a number</FONT></I>
         {
           <I><FONT color="#008080">// start offset word</FONT></I>
           idat.BuildWithName(awrd);
           <I><FONT color="#008080">// get stucture word address</FONT></I>
           Word * ww = ((Word *) idat.PopAD()); <I><FONT color="#008080">// get structure word from aux stack</FONT></I>
           <I><FONT color="#008080">// get current offset into structure</FONT></I>
           <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> bb;
           ww-&gt;LiteralValue(<FONT color="#800000">0</FONT>, &bb);
           <I><FONT color="#008080">// get length of this char[]</FONT></I>
           <B><FONT color="#000080">int</FONT></B> ns = idat.PopD();
           <I><FONT color="#008080">// add length to offset word</FONT></I>
           idat.BuildAddElement((<B><FONT color="#000080">long</FONT></B>) bb);   <I><FONT color="#008080">// space for offset</FONT></I>
           <I><FONT color="#008080">// get address of word '+'</FONT></I>
           string act = <FONT color="#800000">"+"</FONT>;
           Word * add = idat.IDict()-&gt;Address(act);
           <I><FONT color="#008080">// add call to '+'</FONT></I>
           idat.BuildAddElement(add);
           <I><FONT color="#008080">// finish offset word</FONT></I>
           idat.BuildFinishWord();
           <I><FONT color="#008080">// set new size of structure to char[] + old size</FONT></I>
           bb += ns;
           ww-&gt;SetLiteralValue(<FONT color="#800000">0</FONT>, &bb);
           <I><FONT color="#008080">// put back structure word address</FONT></I>
           idat.PushAD((<B><FONT color="#000080">long</FONT></B>)ww);         
         }
         <B><FONT color="#000080">else</FONT></B>
         {
             <I><FONT color="#008080">// trying to name a word with a number error</FONT></I>
             idat.ShowError(Errors::IS_NUMBER);
         }
    }
    <B><FONT color="#000080">else</FONT></B>
     {
        <I><FONT color="#008080">// word already exists error</FONT></I>
        idat.ShowError(Errors::WORD_EXISTS, awrd);
     }
 } 
 <B><FONT color="#000080">else</FONT></B>
 {
      <I><FONT color="#008080">// buffer end reached</FONT></I>
     idat.ShowError(Errors::BUFFER_END);
 }
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_Nshort(InterpreterData & idat)
{
  string awrd;
  Parser * par = idat.IParser();
  <B><FONT color="#000080">char</FONT></B> * wrd;

  <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
  {
     <I><FONT color="#008080">// the word structure is only interpreted "to create a structure type'</FONT></I>
     <I><FONT color="#008080">// it compiles is a new forth word</FONT></I>
      idat.ShowError(Errors::ILLEGALDEFINING);
      <B><FONT color="#000080">return</FONT></B>;
  }

 <B><FONT color="#000080">if</FONT></B>((wrd = par-&gt;NextWord()) != NULL)
 {
    awrd = wrd;
    <B><FONT color="#000080">if</FONT></B>(idat.IDict()-&gt;Exists(awrd) == -<FONT color="#800000">1</FONT>)  <I><FONT color="#008080">// word does not exist</FONT></I>
    {
         <B><FONT color="#000080">if</FONT></B>(!par-&gt;AllDigits(wrd))  <I><FONT color="#008080">// word is not a number</FONT></I>
         {
           <I><FONT color="#008080">// start offset word</FONT></I>
           idat.BuildWithName(awrd);
           <I><FONT color="#008080">// get stucture word address</FONT></I>
           Word * ww = ((Word *) idat.PopAD()); <I><FONT color="#008080">// get structure word from aux stack</FONT></I>
           <I><FONT color="#008080">// get current offset into structure</FONT></I>
           <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> bb;
           ww-&gt;LiteralValue(<FONT color="#800000">0</FONT>, &bb);
           <I><FONT color="#008080">// get length of this short</FONT></I>
           <B><FONT color="#000080">int</FONT></B> ns = <B><FONT color="#000080">sizeof</FONT></B>(<B><FONT color="#000080">short</FONT></B>);
           <I><FONT color="#008080">// add size to new offset word</FONT></I>
           idat.BuildAddElement((<B><FONT color="#000080">long</FONT></B>) bb);   
           <I><FONT color="#008080">// get address of word '+'</FONT></I>
           string act = <FONT color="#800000">"+"</FONT>;
           Word * add = idat.IDict()-&gt;Address(act);
           <I><FONT color="#008080">// add call to '+'</FONT></I>
           idat.BuildAddElement(add);
           <I><FONT color="#008080">// finish offset word</FONT></I>
           idat.BuildFinishWord();
           <I><FONT color="#008080">// set new size of structure to char[] + old size</FONT></I>
           bb += ns;
           ww-&gt;SetLiteralValue(<FONT color="#800000">0</FONT>, &bb);
           <I><FONT color="#008080">// put back structure word address</FONT></I>
           idat.PushAD((<B><FONT color="#000080">long</FONT></B>)ww);         
         }
         <B><FONT color="#000080">else</FONT></B>
         {
             <I><FONT color="#008080">// trying to name a word with a number error</FONT></I>
             idat.ShowError(Errors::IS_NUMBER);
         }
    }
    <B><FONT color="#000080">else</FONT></B>
     {
        <I><FONT color="#008080">// word already exists error</FONT></I>
        idat.ShowError(Errors::WORD_EXISTS, awrd);
     }
 } 
 <B><FONT color="#000080">else</FONT></B>
 {
      <I><FONT color="#008080">// buffer end reached</FONT></I>
     idat.ShowError(Errors::BUFFER_END);
 }
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_Nlong(InterpreterData & idat)
{
  string awrd;
  Parser * par = idat.IParser();
  <B><FONT color="#000080">char</FONT></B> * wrd;

  <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
  {
     <I><FONT color="#008080">// the word structure is only interpreted "to create a structure type'</FONT></I>
     <I><FONT color="#008080">// it compiles is a new forth word</FONT></I>
      idat.ShowError(Errors::ILLEGALDEFINING);
      <B><FONT color="#000080">return</FONT></B>;
  }

 <B><FONT color="#000080">if</FONT></B>((wrd = par-&gt;NextWord()) != NULL)
 {
    awrd = wrd;
    <B><FONT color="#000080">if</FONT></B>(idat.IDict()-&gt;Exists(awrd) == -<FONT color="#800000">1</FONT>)  <I><FONT color="#008080">// word does not exist</FONT></I>
    {
         <B><FONT color="#000080">if</FONT></B>(!par-&gt;AllDigits(wrd))  <I><FONT color="#008080">// word is not a number</FONT></I>
         {
           <I><FONT color="#008080">// start offset word</FONT></I>
           idat.BuildWithName(awrd);
           <I><FONT color="#008080">// get stucture word address</FONT></I>
           Word * ww = ((Word *) idat.PopAD()); <I><FONT color="#008080">// get structure word from aux stack</FONT></I>
           <I><FONT color="#008080">// get current offset into structure</FONT></I>
           <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> bb;
           ww-&gt;LiteralValue(<FONT color="#800000">0</FONT>, &bb);
           <I><FONT color="#008080">// get length of this long</FONT></I>
           <B><FONT color="#000080">int</FONT></B> ns = <B><FONT color="#000080">sizeof</FONT></B>(<B><FONT color="#000080">long</FONT></B>);
           <I><FONT color="#008080">// add size to new offset word</FONT></I>
           idat.BuildAddElement((<B><FONT color="#000080">long</FONT></B>) bb);   
           <I><FONT color="#008080">// get address of word '+'</FONT></I>
           string act = <FONT color="#800000">"+"</FONT>;
           Word * add = idat.IDict()-&gt;Address(act);
           <I><FONT color="#008080">// add call to '+'</FONT></I>
           idat.BuildAddElement(add);
           <I><FONT color="#008080">// finish offset word</FONT></I>
           idat.BuildFinishWord();
           <I><FONT color="#008080">// set new size of structure to sizeof(long) + old size</FONT></I>
           bb += ns;
           ww-&gt;SetLiteralValue(<FONT color="#800000">0</FONT>, &bb);
           <I><FONT color="#008080">// put back structure word address</FONT></I>
           idat.PushAD((<B><FONT color="#000080">long</FONT></B>)ww);         
         }
         <B><FONT color="#000080">else</FONT></B>
         {
             <I><FONT color="#008080">// trying to name a word with a number error</FONT></I>
             idat.ShowError(Errors::IS_NUMBER);
         }
    }
    <B><FONT color="#000080">else</FONT></B>
     {
        <I><FONT color="#008080">// word already exists error</FONT></I>
        idat.ShowError(Errors::WORD_EXISTS, awrd);
     }
 } 
 <B><FONT color="#000080">else</FONT></B>
 {
      <I><FONT color="#008080">// buffer end reached</FONT></I>
     idat.ShowError(Errors::BUFFER_END);
 }
}

<I><FONT color="#008080">// Function name    : Primitives::L_Narraylong</FONT></I>
<I><FONT color="#008080">// Description      : creates an indexed structure array offset word</FONT></I>
<I><FONT color="#008080">//                    ( number-longs --- )</FONT></I>
<I><FONT color="#008080">//                    new word's stack diagram:</FONT></I>
<I><FONT color="#008080">//                    ( &struct index --- offset )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_Narraylong(InterpreterData & idat)
{
  string awrd;
  Parser * par = idat.IParser();
  <B><FONT color="#000080">char</FONT></B> * wrd;

  <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
  {
     <I><FONT color="#008080">// the word structure is only interpreted "to create a structure type'</FONT></I>
     <I><FONT color="#008080">// it compiles is a new forth word</FONT></I>
      idat.ShowError(Errors::ILLEGALDEFINING);
      <B><FONT color="#000080">return</FONT></B>;
  }

 <B><FONT color="#000080">if</FONT></B>((wrd = par-&gt;NextWord()) != NULL)
 {
    awrd = wrd;
    <B><FONT color="#000080">if</FONT></B>(idat.IDict()-&gt;Exists(awrd) == -<FONT color="#800000">1</FONT>)  <I><FONT color="#008080">// word does not exist</FONT></I>
    {
         <B><FONT color="#000080">if</FONT></B>(!par-&gt;AllDigits(wrd))  <I><FONT color="#008080">// word is not a number</FONT></I>
         {
           string act;
           <I><FONT color="#008080">// start offset word</FONT></I>
           idat.BuildWithName(awrd);
           <I><FONT color="#008080">// get stucture word address</FONT></I>
           Word * ww = ((Word *) idat.PopAD());   <I><FONT color="#008080">// get structure word from aux stack</FONT></I>
           <I><FONT color="#008080">// get current offset into structure</FONT></I>
           <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> bb;
           ww-&gt;LiteralValue(<FONT color="#800000">0</FONT>, &bb);
           <I><FONT color="#008080">// get number of longs in the array</FONT></I>
           <B><FONT color="#000080">int</FONT></B> nl = idat.PopD();
           <I><FONT color="#008080">// get length of array</FONT></I>
           <B><FONT color="#000080">int</FONT></B> ns = <B><FONT color="#000080">sizeof</FONT></B>(<B><FONT color="#000080">long</FONT></B>) * nl;                   
           idat.BuildAddElement((<B><FONT color="#000080">long</FONT></B>) <B><FONT color="#000080">sizeof</FONT></B>(<B><FONT color="#000080">long</FONT></B>));    <I><FONT color="#008080">// will push size</FONT></I>
           act = <FONT color="#800000">"*"</FONT>;
           Word * mul = idat.IDict()-&gt;Address(act);      
           <I><FONT color="#008080">// add call to '*'</FONT></I>
           idat.BuildAddElement(mul);                    <I><FONT color="#008080">// will call *</FONT></I>
           <I><FONT color="#008080">// add starting offset to new offset word</FONT></I>
           idat.BuildAddElement((<B><FONT color="#000080">long</FONT></B>) bb);              <I><FONT color="#008080">// will push offset</FONT></I>
           <I><FONT color="#008080">// get address of word '+'                    </FONT></I>
           act = <FONT color="#800000">"+"</FONT>;
           Word * add = idat.IDict()-&gt;Address(act);
           <I><FONT color="#008080">// add call to '+'</FONT></I>
           idat.BuildAddElement(add);                    <I><FONT color="#008080">// will call +</FONT></I>
           <I><FONT color="#008080">// add 2nd call to '+'</FONT></I>
           idat.BuildAddElement(add);                    <I><FONT color="#008080">// will call +</FONT></I>
           <I><FONT color="#008080">// finish offset word</FONT></I>
           idat.BuildFinishWord();
           <I><FONT color="#008080">// set new size of structure to sizeof(long) + old size</FONT></I>
           bb += ns;
           ww-&gt;SetLiteralValue(<FONT color="#800000">0</FONT>, &bb);
           <I><FONT color="#008080">// put back structure word address</FONT></I>
           idat.PushAD((<B><FONT color="#000080">long</FONT></B>)ww);         
         }
         <B><FONT color="#000080">else</FONT></B>
         {
             <I><FONT color="#008080">// trying to name a word with a number error</FONT></I>
             idat.ShowError(Errors::IS_NUMBER);
         }
    }
    <B><FONT color="#000080">else</FONT></B>
     {
        <I><FONT color="#008080">// word already exists error</FONT></I>
        idat.ShowError(Errors::WORD_EXISTS, awrd);
     }
 } 
 <B><FONT color="#000080">else</FONT></B>
 {
      <I><FONT color="#008080">// buffer end reached</FONT></I>
     idat.ShowError(Errors::BUFFER_END);
 }
}


<I><FONT color="#008080">// Function name    : Primitives::L_Narrayshort</FONT></I>
<I><FONT color="#008080">// Description      : creates an indexed structure array offset word</FONT></I>
<I><FONT color="#008080">//                    ( number-shorts --- )</FONT></I>
<I><FONT color="#008080">//                    new word's stack diagram:</FONT></I>
<I><FONT color="#008080">//                    ( &struct index --- offset )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_Narrayshort(InterpreterData & idat)
{
  string awrd;
  Parser * par = idat.IParser();
  <B><FONT color="#000080">char</FONT></B> * wrd;

  <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
  {
     <I><FONT color="#008080">// the word structure is only interpreted "to create a structure type'</FONT></I>
     <I><FONT color="#008080">// it compiles is a new forth word</FONT></I>
      idat.ShowError(Errors::ILLEGALDEFINING);
      <B><FONT color="#000080">return</FONT></B>;
  }

 <B><FONT color="#000080">if</FONT></B>((wrd = par-&gt;NextWord()) != NULL)
 {
    awrd = wrd;
    <B><FONT color="#000080">if</FONT></B>(idat.IDict()-&gt;Exists(awrd) == -<FONT color="#800000">1</FONT>)  <I><FONT color="#008080">// word does not exist</FONT></I>
    {
         <B><FONT color="#000080">if</FONT></B>(!par-&gt;AllDigits(wrd))  <I><FONT color="#008080">// word is not a number</FONT></I>
         {
           string act;
           <I><FONT color="#008080">// start offset word</FONT></I>
           idat.BuildWithName(awrd);
           <I><FONT color="#008080">// get stucture word address</FONT></I>
           Word * ww = ((Word *) idat.PopAD());   <I><FONT color="#008080">// get structure word from aux stack</FONT></I>
           <I><FONT color="#008080">// get current offset into structure</FONT></I>
           <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> bb;
           ww-&gt;LiteralValue(<FONT color="#800000">0</FONT>, &bb);
           <I><FONT color="#008080">// get number of longs in the array</FONT></I>
           <B><FONT color="#000080">int</FONT></B> nl = idat.PopD();
           <I><FONT color="#008080">// get length of array</FONT></I>
           <B><FONT color="#000080">int</FONT></B> ns = <B><FONT color="#000080">sizeof</FONT></B>(<B><FONT color="#000080">short</FONT></B>) * nl;
           idat.BuildAddElement((<B><FONT color="#000080">long</FONT></B>) <B><FONT color="#000080">sizeof</FONT></B>(<B><FONT color="#000080">short</FONT></B>));
           act = <FONT color="#800000">"*"</FONT>;
           Word * mul = idat.IDict()-&gt;Address(act);
           <I><FONT color="#008080">// add call to '*'</FONT></I>
           idat.BuildAddElement(mul);
           <I><FONT color="#008080">// add starting offset to new offset word</FONT></I>
           idat.BuildAddElement((<B><FONT color="#000080">long</FONT></B>) bb);
           <I><FONT color="#008080">// get address of word '+'</FONT></I>
           act = <FONT color="#800000">"+"</FONT>;
           Word * add = idat.IDict()-&gt;Address(act);
           <I><FONT color="#008080">// add call to '+'</FONT></I>
           idat.BuildAddElement(add);
           <I><FONT color="#008080">// add 2nd call to '+'</FONT></I>
           idat.BuildAddElement(add);                    <I><FONT color="#008080">// will call +</FONT></I>
           <I><FONT color="#008080">// finish offset word</FONT></I>
           idat.BuildFinishWord();
           <I><FONT color="#008080">// set new size of structure to sizeof(long) + old size</FONT></I>
           bb += ns;
           ww-&gt;SetLiteralValue(<FONT color="#800000">0</FONT>, &bb);
           <I><FONT color="#008080">// put back structure word address</FONT></I>
           idat.PushAD((<B><FONT color="#000080">long</FONT></B>)ww);         
         }
         <B><FONT color="#000080">else</FONT></B>
         {
             <I><FONT color="#008080">// trying to name a word with a number error</FONT></I>
             idat.ShowError(Errors::IS_NUMBER);
         }
    }
    <B><FONT color="#000080">else</FONT></B>
     {
        <I><FONT color="#008080">// word already exists error</FONT></I>
        idat.ShowError(Errors::WORD_EXISTS, awrd);
     }
 } 
 <B><FONT color="#000080">else</FONT></B>
 {
      <I><FONT color="#008080">// buffer end reached</FONT></I>
     idat.ShowError(Errors::BUFFER_END);
 }
}


<I><FONT color="#008080">// Function name    : Primitives::L_Narrayobjects</FONT></I>
<I><FONT color="#008080">// Description      : creates an indexed structure array offset word</FONT></I>
<I><FONT color="#008080">//                    ( number-objs obj-size -- )</FONT></I>
<I><FONT color="#008080">//                    new word's stack diagram:</FONT></I>
<I><FONT color="#008080">//                    ( &struct index --- offset )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_Narrayobjects(InterpreterData & idat)
{
  string awrd;
  Parser * par = idat.IParser();
  <B><FONT color="#000080">char</FONT></B> * wrd;

  <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
  {
     <I><FONT color="#008080">// the word structure is only interpreted "to create a structure type'</FONT></I>
     <I><FONT color="#008080">// it compiles is a new forth word</FONT></I>
      idat.ShowError(Errors::ILLEGALDEFINING);
      <B><FONT color="#000080">return</FONT></B>;
  }

 <B><FONT color="#000080">if</FONT></B>((wrd = par-&gt;NextWord()) != NULL)
 {
    awrd = wrd;
    <B><FONT color="#000080">if</FONT></B>(idat.IDict()-&gt;Exists(awrd) == -<FONT color="#800000">1</FONT>)  <I><FONT color="#008080">// word does not exist</FONT></I>
    {
         <B><FONT color="#000080">if</FONT></B>(!par-&gt;AllDigits(wrd))  <I><FONT color="#008080">// word is not a number</FONT></I>
         {
           string act;
           <I><FONT color="#008080">// start offset word</FONT></I>
           idat.BuildWithName(awrd);
           <I><FONT color="#008080">// get stucture word address</FONT></I>
           Word * ww = ((Word *) idat.PopAD());   <I><FONT color="#008080">// get structure word from aux stack</FONT></I>
           <I><FONT color="#008080">// get current offset into structure</FONT></I>
           <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> bb;
           ww-&gt;LiteralValue(<FONT color="#800000">0</FONT>, &bb);
           <I><FONT color="#008080">// get size of one char[]</FONT></I>
           <B><FONT color="#000080">int</FONT></B> sa = idat.PopD();
           <I><FONT color="#008080">// get number of char[] in the array[][]</FONT></I>
           <B><FONT color="#000080">int</FONT></B> nl = idat.PopD();
           <I><FONT color="#008080">// get length of array</FONT></I>
           <B><FONT color="#000080">int</FONT></B> ns = sa * nl;
           <I><FONT color="#008080">// set size of one char[]</FONT></I>
           idat.BuildAddElement((<B><FONT color="#000080">long</FONT></B>) sa);
           act = <FONT color="#800000">"*"</FONT>;
           Word * mul = idat.IDict()-&gt;Address(act);
           <I><FONT color="#008080">// add call to '*'</FONT></I>
           idat.BuildAddElement(mul);
           <I><FONT color="#008080">// add starting offset to new offset word</FONT></I>
           idat.BuildAddElement((<B><FONT color="#000080">long</FONT></B>) bb);
           <I><FONT color="#008080">// get address of word '+'</FONT></I>
           act = <FONT color="#800000">"+"</FONT>;
           Word * add = idat.IDict()-&gt;Address(act);
           <I><FONT color="#008080">// add call to '+'</FONT></I>
           idat.BuildAddElement(add);
           <I><FONT color="#008080">// add 2nd call to '+'</FONT></I>
           idat.BuildAddElement(add);                    <I><FONT color="#008080">// will call +</FONT></I>
           <I><FONT color="#008080">// finish offset word</FONT></I>
           idat.BuildFinishWord();
           <I><FONT color="#008080">// set new size of structure to sizeof(long) + old size</FONT></I>
           bb += ns;
           ww-&gt;SetLiteralValue(<FONT color="#800000">0</FONT>, &bb);
           <I><FONT color="#008080">// put back structure word address</FONT></I>
           idat.PushAD((<B><FONT color="#000080">long</FONT></B>)ww);         
         }
         <B><FONT color="#000080">else</FONT></B>
         {
             <I><FONT color="#008080">// trying to name a word with a number error</FONT></I>
             idat.ShowError(Errors::IS_NUMBER);
         }
    }
    <B><FONT color="#000080">else</FONT></B>
     {
        <I><FONT color="#008080">// word already exists error</FONT></I>
        idat.ShowError(Errors::WORD_EXISTS, awrd);
     }
 } 
 <B><FONT color="#000080">else</FONT></B>
 {
      <I><FONT color="#008080">// buffer end reached</FONT></I>
     idat.ShowError(Errors::BUFFER_END);
 }
}

<I><FONT color="#008080">// Function name    : Primitives::L_endstructure</FONT></I>
<I><FONT color="#008080">// Description      : cleans up after building structure</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_endstructure(InterpreterData & idat)
{
  Word * ww = ((Word *) idat.PopAD());   <I><FONT color="#008080">// get structure word from aux stack</FONT></I>
  <I><FONT color="#008080">// done</FONT></I>
}

<I><FONT color="#008080">// Function name    : Primitives::L_runiinloop</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_runiinloop(InterpreterData & idat)
{
      <B><FONT color="#000080">int</FONT></B> doindex = (<B><FONT color="#000080">int</FONT></B> ) idat.PopD();        <I><FONT color="#008080">// index of 'do' on stack </FONT></I>
      RSData ar = idat.GetRsv(<FONT color="#800000">0</FONT>);              <I><FONT color="#008080">// get return stack entry (it called me)</FONT></I>
      Word *calling = ar.Code();               <I><FONT color="#008080">// get the address of the word that called</FONT></I>
              
      <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> ind = <FONT color="#800000">1001</FONT> ;
      calling-&gt;LiteralValue((doindex - <FONT color="#800000">1</FONT>), &ind);
      idat.PushD(ind);
}

<I><FONT color="#008080">// Function name    : Primitives::L_iinloop</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_iinloop(InterpreterData & idat)
{
    <B><FONT color="#000080">if</FONT></B>(idat.CompilingNI())                       <I><FONT color="#008080">// compiling ?</FONT></I>
    {                                     
          <B><FONT color="#000080">int</FONT></B> ido = idat.FindNthLabeledAD(<FONT color="#800000">"rundo"</FONT>, <FONT color="#800000">"?rundo"</FONT>, <FONT color="#800000">1</FONT>);
          
          <B><FONT color="#000080">if</FONT></B>(ido &gt;= <FONT color="#800000">3</FONT>)  <I><FONT color="#008080">// do uses 4 positions </FONT></I>
          {
             Word *fi = idat.IDict()-&gt;Address(<FONT color="#800000">"runi"</FONT>);       <I><FONT color="#008080">// set to address of word i</FONT></I>
             assert(fi != NULL);
             idat.BuildAddElement((<B><FONT color="#000080">long</FONT></B>)ido);
             idat.BuildAddElement(fi);
          }
          <B><FONT color="#000080">else</FONT></B>   <I><FONT color="#008080">// 'do' not found ??</FONT></I>
          {
             idat.ShowError(Errors::NO_DO); 
          }
    }
    <B><FONT color="#000080">else</FONT></B>   <I><FONT color="#008080">// not compiling</FONT></I>
    {
      <B><FONT color="#000080">int</FONT></B> doindex = (<B><FONT color="#000080">int</FONT></B> ) idat.PopD();        <I><FONT color="#008080">// index of 'do' on stack </FONT></I>
      RSData ar = idat.GetRsv(<FONT color="#800000">0</FONT>);              <I><FONT color="#008080">// get return stack entry (it called me)</FONT></I>
      Word *calling = ar.Code();               <I><FONT color="#008080">// get the address of the word that called</FONT></I>
              
      <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> ind = <FONT color="#800000">1001</FONT> ;
      calling-&gt;LiteralValue((doindex - <FONT color="#800000">1</FONT>), &ind);
      idat.PushD(ind);
    }
}

<I><FONT color="#008080">// Function name    : Primitives::L_runjinloop</FONT></I>
<I><FONT color="#008080">// Description      : ( -- j )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_runjinloop(InterpreterData & idat)
{
      <B><FONT color="#000080">int</FONT></B> doindex = (<B><FONT color="#000080">int</FONT></B> ) idat.PopD();               <I><FONT color="#008080">// index of 'do' on stack </FONT></I>
      RSData ar = idat.GetRsv(<FONT color="#800000">0</FONT>);              <I><FONT color="#008080">// get return stack entry (it called me)</FONT></I>
      Word *calling = ar.Code();               <I><FONT color="#008080">// get the address of the word that called</FONT></I>
              
      <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> ind = <FONT color="#800000">1001</FONT>;
      calling-&gt;LiteralValue((doindex - <FONT color="#800000">1</FONT>), &ind);
      idat.PushD(ind);
}

<I><FONT color="#008080">// Function name    : Primitives::L_jinloop</FONT></I>
<I><FONT color="#008080">// Description      : ( -- j )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_jinloop(InterpreterData & idat)
{
    <B><FONT color="#000080">if</FONT></B>(idat.Compiling())                       <I><FONT color="#008080">// compiling ?</FONT></I>
    {   
          <B><FONT color="#000080">int</FONT></B> ido = idat.FindNthLabeledAD(<FONT color="#800000">"rundo"</FONT>, <FONT color="#800000">"?rundo"</FONT>, <FONT color="#800000">2</FONT>);
          
          <B><FONT color="#000080">if</FONT></B>(ido &gt;= <FONT color="#800000">3</FONT>)  <I><FONT color="#008080">// do uses 4 positions </FONT></I>
          {
             Word *fj = idat.IDict()-&gt;Address(<FONT color="#800000">"runj"</FONT>);    <I><FONT color="#008080">// set to address of word j</FONT></I>
             assert(fj != NULL);
             idat.BuildAddElement((<B><FONT color="#000080">long</FONT></B>)ido);
             idat.BuildAddElement(fj);
          }
          <B><FONT color="#000080">else</FONT></B>   <I><FONT color="#008080">// 'do' not found ??</FONT></I>
          {
             idat.ShowError(Errors::NO_DO); 
          }
    }
    <B><FONT color="#000080">else</FONT></B>   <I><FONT color="#008080">// not compiling</FONT></I>
    {
      <B><FONT color="#000080">int</FONT></B> doindex = (<B><FONT color="#000080">int</FONT></B> ) idat.PopD();               <I><FONT color="#008080">// index of 'do' on stack </FONT></I>
      RSData ar = idat.GetRsv(<FONT color="#800000">0</FONT>);              <I><FONT color="#008080">// get return stack entry (it called me)</FONT></I>
      Word *calling = ar.Code();               <I><FONT color="#008080">// get the address of the word that called</FONT></I>
              
      <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> ind = <FONT color="#800000">1001</FONT>;
      calling-&gt;LiteralValue((doindex - <FONT color="#800000">1</FONT>), &ind);
      idat.PushD(ind);
    }
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_runleave(InterpreterData & idat)
{
      <B><FONT color="#000080">int</FONT></B> doindex = (<B><FONT color="#000080">int</FONT></B> ) idat.PopD();        <I><FONT color="#008080">// index of 'do' on stack </FONT></I>
      RSData ar = idat.GetRsv(<FONT color="#800000">0</FONT>);              <I><FONT color="#008080">// get return stack entry (it called me)</FONT></I>
      Word *calling = ar.Code();               <I><FONT color="#008080">// get the address of the word that called</FONT></I>
              
      <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> loopind = <FONT color="#800000">1001</FONT>;
      calling-&gt;LiteralValue((doindex - <FONT color="#800000">3</FONT>), &loopind);  <I><FONT color="#008080">// get location in word of 'loop'</FONT></I>
      <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> lim = <FONT color="#800000">1001</FONT> ;
      calling-&gt;LiteralValue((doindex - <FONT color="#800000">2</FONT>), &lim); 
      calling-&gt;SetLiteralValue((doindex - <FONT color="#800000">1</FONT>), &lim);   <I><FONT color="#008080">// set loop index to limit</FONT></I>

      <B><FONT color="#000080">if</FONT></B>(calling-&gt;SameWord(loopind, <FONT color="#800000">"loop"</FONT>, idat))
      {
          ar.SetIndex((loopind  - <FONT color="#800000">2</FONT>));   <I><FONT color="#008080">// loop</FONT></I>
      }
      <B><FONT color="#000080">else</FONT></B>
      {
          ar.SetIndex((loopind  - <FONT color="#800000">2</FONT>));  <I><FONT color="#008080">// +loop</FONT></I>
      }                     
      idat.SetRsv(ar, <FONT color="#800000">0</FONT>);   
}

<I><FONT color="#008080">// Function name    : Primitives::L_leave</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_leave(InterpreterData & idat)
{
    <B><FONT color="#000080">if</FONT></B>(idat.Compiling())                       <I><FONT color="#008080">// compiling ?</FONT></I>
    {   
          <B><FONT color="#000080">int</FONT></B> ido = idat.FindNthLabeledAD(<FONT color="#800000">"?rundo"</FONT>, <FONT color="#800000">"rundo"</FONT>, <FONT color="#800000">1</FONT>);

          <B><FONT color="#000080">if</FONT></B>(ido &gt;= <FONT color="#800000">3</FONT>)  <I><FONT color="#008080">// do uses 4 positions </FONT></I>
          {
             Word *fle = idat.IDict()-&gt;Address(<FONT color="#800000">"runleave"</FONT>);     <I><FONT color="#008080">// set to address of word leave</FONT></I>
             assert(fle != NULL);
             idat.BuildAddElement((<B><FONT color="#000080">long</FONT></B>)ido);
             idat.BuildAddElement(fle);
          }
          <B><FONT color="#000080">else</FONT></B>   <I><FONT color="#008080">// 'do' not found ??</FONT></I>
          {
             idat.ShowError(Errors::NO_DO); 
          }
    }
    <B><FONT color="#000080">else</FONT></B>   <I><FONT color="#008080">// not compiling</FONT></I>
    {
      <B><FONT color="#000080">int</FONT></B> doindex = (<B><FONT color="#000080">int</FONT></B> ) idat.PopD();        <I><FONT color="#008080">// index of 'do' on stack </FONT></I>
      RSData ar = idat.GetRsv(<FONT color="#800000">0</FONT>);              <I><FONT color="#008080">// get return stack entry (it called me)</FONT></I>
      Word *calling = ar.Code();               <I><FONT color="#008080">// get the address of the word that called</FONT></I>
              
      <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> loopind = <FONT color="#800000">1001</FONT>;
      calling-&gt;LiteralValue((doindex - <FONT color="#800000">3</FONT>), &loopind);  <I><FONT color="#008080">// get location in word of 'loop'</FONT></I>
      <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> lim = <FONT color="#800000">1001</FONT> ;
      calling-&gt;LiteralValue((doindex - <FONT color="#800000">2</FONT>), &lim); 
      calling-&gt;SetLiteralValue((doindex - <FONT color="#800000">1</FONT>), &lim);   <I><FONT color="#008080">// set loop index to limit</FONT></I>

      <B><FONT color="#000080">if</FONT></B>(calling-&gt;SameWord(loopind, <FONT color="#800000">"loop"</FONT>, idat))
      {
          ar.SetIndex((loopind  - <FONT color="#800000">2</FONT>));   <I><FONT color="#008080">// loop</FONT></I>
      }
      <B><FONT color="#000080">else</FONT></B>
      {
          ar.SetIndex((loopind  - <FONT color="#800000">2</FONT>));  <I><FONT color="#008080">// +loop</FONT></I>
      }                     
      idat.SetRsv(ar, <FONT color="#800000">0</FONT>);        
    }
}

<I><FONT color="#008080">// Function name    : Primitives::L_unloop</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_rununloop(InterpreterData & idat)
{
     <B><FONT color="#000080">int</FONT></B> doindex = (<B><FONT color="#000080">int</FONT></B> ) idat.PopD();        <I><FONT color="#008080">// index of 'do' on stack </FONT></I>
      RSData ar = idat.GetRsv(<FONT color="#800000">0</FONT>);              <I><FONT color="#008080">// get return stack entry (it called me)</FONT></I>
      Word *calling = ar.Code();               <I><FONT color="#008080">// get the address of the word that called</FONT></I>
              
      <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> key1 = <FONT color="#800000">1234567</FONT>;
      calling-&gt;SetLiteralValue((doindex - <FONT color="#800000">2</FONT>), &key1); 
      calling-&gt;SetLiteralValue((doindex - <FONT color="#800000">1</FONT>), &key1);   <I><FONT color="#008080">// set loop index to not in use    </FONT></I>
}

<I><FONT color="#008080">// Function name    : Primitives::L_unloop</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_unloop(InterpreterData & idat)
{
    <B><FONT color="#000080">if</FONT></B>(idat.Compiling())                       <I><FONT color="#008080">// compiling ?</FONT></I>
    {   

          <B><FONT color="#000080">int</FONT></B> iunloop = idat.ExtractNthLabeledAD(<FONT color="#800000">"rununloop"</FONT>, <FONT color="#800000">1</FONT>);
          <B><FONT color="#000080">if</FONT></B>(iunloop &lt; <FONT color="#800000">0</FONT>)
          {
             iunloop = <FONT color="#800000">1</FONT>;
          }
          <B><FONT color="#000080">int</FONT></B> ido = idat.FindNthLabeledAD(<FONT color="#800000">"?rundo"</FONT>, <FONT color="#800000">"rundo"</FONT>, iunloop);

          <B><FONT color="#000080">if</FONT></B>(ido &gt;= <FONT color="#800000">3</FONT>)  <I><FONT color="#008080">// do uses 4 positions </FONT></I>
          {
             Word *funl = idat.IDict()-&gt;Address(<FONT color="#800000">"rununloop"</FONT>);     <I><FONT color="#008080">// set to address of word unloop</FONT></I>
             assert(funl != NULL);
             idat.BuildAddElement((<B><FONT color="#000080">long</FONT></B>)ido);
             idat.BuildAddElement(funl);
             idat.PushLabeledAD(<FONT color="#800000">"rununloop"</FONT>, (iunloop + <FONT color="#800000">1</FONT>));
          }
          <B><FONT color="#000080">else</FONT></B>   <I><FONT color="#008080">// 'do' not found ??</FONT></I>
          {
             idat.ShowError(Errors::NO_DO); 
          }
    }
    <B><FONT color="#000080">else</FONT></B>   <I><FONT color="#008080">// not compiling</FONT></I>
    {
      <B><FONT color="#000080">int</FONT></B> doindex = (<B><FONT color="#000080">int</FONT></B> ) idat.PopD();        <I><FONT color="#008080">// index of 'do' on stack </FONT></I>
      RSData ar = idat.GetRsv(<FONT color="#800000">0</FONT>);              <I><FONT color="#008080">// get return stack entry (it called me)</FONT></I>
      Word *calling = ar.Code();               <I><FONT color="#008080">// get the address of the word that called</FONT></I>
              
      <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> key1 = <FONT color="#800000">1234567</FONT>;
      calling-&gt;SetLiteralValue((doindex - <FONT color="#800000">2</FONT>), &key1); 
      calling-&gt;SetLiteralValue((doindex - <FONT color="#800000">1</FONT>), &key1);   <I><FONT color="#008080">// set loop index to not in use    </FONT></I>
    }
}

<I><FONT color="#008080">// Function name    : Primitives::L_tic</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_tic(InterpreterData & idat)
{
  string awrd;
  Parser * par = idat.IParser();
  <B><FONT color="#000080">char</FONT></B> * wrd;
  Word * ww;

     <B><FONT color="#000080">if</FONT></B>((wrd = par-&gt;NextWord()) != NULL)
     {
         awrd = wrd;
         <B><FONT color="#000080">if</FONT></B>((ww = idat.IDict()-&gt;Address(awrd)) != NULL)  <I><FONT color="#008080">// word does exist</FONT></I>
         {
              idat.PushD((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>)ww); 
         }
         <B><FONT color="#000080">else</FONT></B>
         {
              idat.ShowError(Errors::NO_SUCH_WORD);
         }
     }
     <B><FONT color="#000080">else</FONT></B>
     {
         <I><FONT color="#008080">// buffer end reached</FONT></I>
        idat.ShowError(Errors::BUFFER_END);
     }
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_pound(InterpreterData & idat)
{
   <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> base = *idat.Base();
   <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> uu = idat.PopD();
   <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> q = <FONT color="#800000">0</FONT>;
   <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> m;

   <B><FONT color="#000080">if</FONT></B>(idat.NbufInUse()== true)
   {   
      q = uu / base;
      m = uu % base;
      <B><FONT color="#000080">char</FONT></B> * buf = idat.Nbuffer();
      <B><FONT color="#000080">int</FONT></B> bufpos = *idat.NbufferPos();

      <B><FONT color="#000080">if</FONT></B>(m &lt; 10l)
      {
         buf[bufpos] = (<B><FONT color="#000080">char</FONT></B>)((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>)<FONT color="#800000">'0'</FONT> + m);
      }
      <B><FONT color="#000080">else</FONT></B>
      {
         buf[bufpos] = (<B><FONT color="#000080">char</FONT></B>)(((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>)<FONT color="#800000">'A'</FONT>) + m - <FONT color="#800000">10</FONT>);
      }
      bufpos++;
     *(idat.NbufferPos()) = bufpos;
      idat.DebugTrace(buf);

      <B><FONT color="#000080">if</FONT></B>(m != <FONT color="#800000">0</FONT> || q != <FONT color="#800000">0</FONT>)
      {
        idat.PushD(q);
      }
   }
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_pounds(InterpreterData & idat)
{
    <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> base = *idat.Base();
    <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> uu = uu = idat.PopD();
    <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> q = 0l;
    <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> m;
    
    <B><FONT color="#000080">if</FONT></B> (uu == 0l)
    {
      uu = idat.PopD();
    }
    
    <B><FONT color="#000080">if</FONT></B>(idat.NbufInUse() == true)
    {
        <B><FONT color="#000080">char</FONT></B> * buf = idat.Nbuffer();
        <B><FONT color="#000080">int</FONT></B> bufpos = *(idat.NbufferPos());    
        
        <B><FONT color="#000080">while</FONT></B>(uu != <FONT color="#800000">0</FONT> && bufpos &lt; <FONT color="#800000">118</FONT>)
        {
            q = uu / base;
            m = uu % base;
            uu = q;
            <B><FONT color="#000080">if</FONT></B>(m &lt; 10l)
            {
                buf[bufpos] = (<B><FONT color="#000080">char</FONT></B>)((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>)<FONT color="#800000">'0'</FONT> + m);
            }
            <B><FONT color="#000080">else</FONT></B>
            {
                buf[bufpos] = (<B><FONT color="#000080">char</FONT></B>)(((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>)<FONT color="#800000">'A'</FONT>) + m - <FONT color="#800000">10</FONT>);
            }
            idat.DebugTrace(buf);
            bufpos++;
        }
       *(idat.NbufferPos()) = bufpos;
    }
    
    idat.PushD(q);
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_lesspound(InterpreterData & idat)
{
   <B><FONT color="#000080">if</FONT></B>(idat.NbufInUse()== false)
   {
      idat.NbufferOn(); 
      memset(idat.Nbuffer(), <FONT color="#800000">0</FONT>, <FONT color="#800000">120</FONT>);
      *(idat.NbufferPos()) = <FONT color="#800000">0</FONT>;
   }
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_hold(InterpreterData & idat)
{
   <B><FONT color="#000080">if</FONT></B>(idat.NbufInUse()== true)
   {   
      <B><FONT color="#000080">char</FONT></B> cc = (<B><FONT color="#000080">char</FONT></B>) idat.PopD();
      <B><FONT color="#000080">char</FONT></B> * buf = idat.Nbuffer();
      <B><FONT color="#000080">int</FONT></B> bufpos = *(idat.NbufferPos());
      buf[bufpos] = cc;
      bufpos++;
      *(idat.NbufferPos()) = bufpos;
   }
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_sign(InterpreterData & idat)
{
   <B><FONT color="#000080">if</FONT></B>(idat.NbufInUse()== true)
   {   
      <B><FONT color="#000080">int</FONT></B> nn = idat.PopD();
      <B><FONT color="#000080">if</FONT></B>(nn &lt; <FONT color="#800000">0</FONT>)
      {
         <B><FONT color="#000080">char</FONT></B> * buf = idat.Nbuffer();
         <B><FONT color="#000080">int</FONT></B> bufpos = *(idat.NbufferPos());
         buf[bufpos] = <FONT color="#800000">'-'</FONT>;
         bufpos++;
         *(idat.NbufferPos()) = bufpos;
      }
   }
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_poundgreater(InterpreterData & idat)
{
   <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> uu = idat.PopD();
   <B><FONT color="#000080">if</FONT></B>(idat.NbufInUse()== true)
   {
      idat.NbufferOff(); 
      <B><FONT color="#000080">char</FONT></B> * nbuf = idat.Nbuffer();
      <B><FONT color="#000080">char</FONT></B> * nobuf = idat.NObuffer();
      <B><FONT color="#000080">int</FONT></B> bufpos = *(idat.NbufferPos());
      <B><FONT color="#000080">int</FONT></B> kk = bufpos -<FONT color="#800000">1</FONT>;

      <B><FONT color="#000080">for</FONT></B>(<B><FONT color="#000080">int</FONT></B> ii = kk;ii &gt;= <FONT color="#800000">0</FONT>;ii--)
      {
        nobuf[kk - ii] = nbuf[ii];
      }
      nobuf[bufpos] = <FONT color="#800000">0</FONT>;
      idat.DebugTrace(nbuf);
      idat.DebugTrace(nobuf);
   }
   idat.PushD((<B><FONT color="#000080">long</FONT></B>)idat.NObuffer());
   idat.PushD((<B><FONT color="#000080">long</FONT></B>)strlen(idat.NObuffer()));
}

<I><FONT color="#008080">// Function name    : Primitives::L_bracketticbracket</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_bracketticbracket(InterpreterData & idat)
{
  string awrd;
  Parser * par = idat.IParser();
  <B><FONT color="#000080">char</FONT></B> * wrd;
  Word * ww;

     <B><FONT color="#000080">if</FONT></B>((wrd = par-&gt;NextWord()) != NULL)
     {
         awrd = wrd;
         <B><FONT color="#000080">if</FONT></B>((ww = idat.IDict()-&gt;Address(awrd)) != NULL)  <I><FONT color="#008080">// word does exist</FONT></I>
         {
              <B><FONT color="#000080">if</FONT></B>(idat.Compiling())                          <I><FONT color="#008080">// compiling ?</FONT></I>
              {  
                 idat.BuildAddElement((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>)ww);
              }
              <B><FONT color="#000080">else</FONT></B>
              {
                idat.ShowError(Errors::ONLY_COMPILED);
              }
         }
         <B><FONT color="#000080">else</FONT></B>
         {
              idat.ShowError(Errors::NO_SUCH_WORD);
         }
     }
     <B><FONT color="#000080">else</FONT></B>
     {
         <I><FONT color="#008080">// buffer end reached</FONT></I>
        idat.ShowError(Errors::BUFFER_END);
     }
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_execute(InterpreterData & idat)
{
   Word * ww = ((Word *) idat.PopD());
   ww-&gt;Execute(<FONT color="#800000">0</FONT>, idat);
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_decompile(InterpreterData & idat)
{
   string txt;
   txt.reserve(<FONT color="#800000">1000</FONT>);
   Word * ww = ((Word *) idat.PopD());
   ww-&gt;Decompile(txt, idat);
   idat.Out() += txt;
   idat.WriteOut();
   idat.LineOut();
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_dot_s(InterpreterData & idat)
{
   idat.ShowDatv();
}

<I><FONT color="#008080">// Function name    : Primitives::L_case</FONT></I>
<I><FONT color="#008080">// Description      : ( val -- )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_runcase(InterpreterData & idat)
{
   idat.PopD();
}

<I><FONT color="#008080">// Function name    : Primitives::L_case</FONT></I>
<I><FONT color="#008080">// Description      : ( val -- ) </FONT></I>
<I><FONT color="#008080">// internal-runtime           : ( val - val )</FONT></I>
<I><FONT color="#008080">// internal compile-time      : AD( -- runcase-index[runcase]</FONT></I>
<I><FONT color="#008080">//                       prepares for the index of endcase so that endof will have a known </FONT></I>
<I><FONT color="#008080">//                       location to find it at run time only drops the endcase index</FONT></I>
<I><FONT color="#008080">//                       puts the index value of case on the aux data stack</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_case(InterpreterData & idat)
{
    <B><FONT color="#000080">if</FONT></B>(idat.Compiling())                   <I><FONT color="#008080">// compiling ??</FONT></I>
    {   
          Word *fcase = idat.IDict()-&gt;Address(<FONT color="#800000">"runcase"</FONT>);  <I><FONT color="#008080">// address of word 'case'</FONT></I>
          
          idat.BuildAddElement((<B><FONT color="#000080">long</FONT></B>)<FONT color="#800000">0</FONT>);    <I><FONT color="#008080">// for endcase</FONT></I>
          idat.BuildAddElement(fcase);
          <B><FONT color="#000080">long</FONT></B> ee = idat.BuildLastUsedElement();           
          idat.PushLabeledAD((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>) fcase, ee);
    }
    <B><FONT color="#000080">else</FONT></B>  <I><FONT color="#008080">// not compiling</FONT></I>
    {
       idat.PopD();
    }
}

<I><FONT color="#008080">// Function name    : Primitives::L_runof</FONT></I>
<I><FONT color="#008080">// Description      : ( val -- )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_runof(InterpreterData & idat)
{
          <B><FONT color="#000080">long</FONT></B> ind = idat.PopD();
          <B><FONT color="#000080">long</FONT></B> val = idat.PopD();
          <B><FONT color="#000080">long</FONT></B> val2 = idat.PopD();
          <B><FONT color="#000080">if</FONT></B>(val != val2) <I><FONT color="#008080">// jump to endof with valin on stack</FONT></I>
          {
             idat.PushD(val2);
             RSData ar = idat.GetRsv(<FONT color="#800000">0</FONT>);
             ar.SetIndex(ind); 
             idat.SetRsv(ar, <FONT color="#800000">0</FONT>); <I><FONT color="#008080">// will be invremented by execute apon return</FONT></I>
          }

}

<I><FONT color="#008080">// Function name    : Primitives::L_of</FONT></I>
<I><FONT color="#008080">// Description      : ( val -- )</FONT></I>
<I><FONT color="#008080">// internal-runtime           : ( valin valtst index[endof] -- valin | &lt;empty) )</FONT></I>
<I><FONT color="#008080">// internal compile-time      : AD( ---  runcase-index[runcase] runof--index[runof]</FONT></I>
<I><FONT color="#008080">//                          prepares for the index of endof puts the of index value on the aux stask</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_of(InterpreterData & idat)
{
    <B><FONT color="#000080">if</FONT></B>(idat.Compiling())                   <I><FONT color="#008080">// compiling ??</FONT></I>
    {   
          Word *fof = idat.IDict()-&gt;Address(<FONT color="#800000">"runof"</FONT>);  <I><FONT color="#008080">// address of word 'of'</FONT></I>
          
          idat.BuildAddElement((<B><FONT color="#000080">long</FONT></B>)<FONT color="#800000">0</FONT>);   <I><FONT color="#008080">// for endof</FONT></I>
          idat.BuildAddElement(fof);
          <B><FONT color="#000080">long</FONT></B> ee = idat.BuildLastUsedElement();           
          idat.PushLabeledAD((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>) fof, ee);
    }
    <B><FONT color="#000080">else</FONT></B>  <I><FONT color="#008080">// not compiling</FONT></I>
    {
          <B><FONT color="#000080">long</FONT></B> ind = idat.PopD();
          <B><FONT color="#000080">long</FONT></B> val = idat.PopD();
          <B><FONT color="#000080">long</FONT></B> val2 = idat.PopD();
          <B><FONT color="#000080">if</FONT></B>(val != val2)
          {
             idat.PushD(val2);
             RSData ar = idat.GetRsv(<FONT color="#800000">0</FONT>);
             ar.SetIndex(ind); 
             idat.SetRsv(ar, <FONT color="#800000">0</FONT>);
          }
    }
}

<I><FONT color="#008080">// Function name    : Primitives::L_endof</FONT></I>
<I><FONT color="#008080">// Description      : ( val -- )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_runendof(InterpreterData & idat)
{
         <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> ind = idat.PopD();             <I><FONT color="#008080">// index of case - 1</FONT></I>

         RSData ar = idat.GetRsv(<FONT color="#800000">0</FONT>);
         Word *calling = ar.Code();                   <I><FONT color="#008080">// get the address of the word that called              </FONT></I>
         <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> endcaseind = <FONT color="#800000">1001</FONT>;
         calling-&gt;LiteralValue(ind, &endcaseind); 
         ar.SetIndex(endcaseind); 
         idat.SetRsv(ar, <FONT color="#800000">0</FONT>);
}

<I><FONT color="#008080">// Function name    : Primitives::L_endof</FONT></I>
<I><FONT color="#008080">// Description      : ( val -- )</FONT></I>
<I><FONT color="#008080">// internal-runtime1       : ( empty case-1=index[endcase] -- )</FONT></I>
<I><FONT color="#008080">//                           at runtime the only endof should only be reached if the of was </FONT></I>
<I><FONT color="#008080">//                           passed and we jump to endcase</FONT></I>
<I><FONT color="#008080">// internal compile-time   : AD( runof--index[runof] runcase-index[runcase] --- runcase-index[runcase]</FONT></I>
<I><FONT color="#008080">//                           gets the index locations of of and case from the aux data stack</FONT></I>
<I><FONT color="#008080">//                           and adds the index (case - 1 = endcase index ! and sets the location</FONT></I>
<I><FONT color="#008080">//                           of - 1 to endof</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_endof(InterpreterData & idat)
{
    <B><FONT color="#000080">if</FONT></B>(idat.Compiling())                   <I><FONT color="#008080">// compiling ??</FONT></I>
    {   
          Word *fendof = idat.IDict()-&gt;Address(<FONT color="#800000">"runendof"</FONT>);  <I><FONT color="#008080">// address of word 'endof'</FONT></I>
          
          <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> ofindex = idat.PopLabeledAD();             <I><FONT color="#008080">// of index</FONT></I>
          <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> caseindex = idat.PeekLabeledAD();          <I><FONT color="#008080">// case index</FONT></I>
              
          idat.BuildAddElement((<B><FONT color="#000080">long</FONT></B>)caseindex - <FONT color="#800000">1</FONT>);               <I><FONT color="#008080">// for endcase</FONT></I>
          idat.BuildAddElement(fendof);                            
          <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> ee = idat.BuildLastUsedElement();          
          idat.Building()-&gt;SetLiteralValue(ofindex-<FONT color="#800000">1</FONT>, &ee);     
    }
    <B><FONT color="#000080">else</FONT></B>  <I><FONT color="#008080">// not compiling</FONT></I>
    {
         <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> ind = idat.PopD();             <I><FONT color="#008080">// index of case - 1</FONT></I>

         RSData ar = idat.GetRsv(<FONT color="#800000">0</FONT>);
         Word *calling = ar.Code();               <I><FONT color="#008080">// get the address of the word that called              </FONT></I>
         <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> endcaseind = <FONT color="#800000">1001</FONT>;
         calling-&gt;LiteralValue(ind, &endcaseind); 
         ar.SetIndex(endcaseind); 
         idat.SetRsv(ar, <FONT color="#800000">0</FONT>);
    }
}

<I><FONT color="#008080">// Function name    : Primitives::L_runendcase</FONT></I>
<I><FONT color="#008080">// Description      : ( val -- )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_runendcase(InterpreterData & idat)
{
  ;
}

<I><FONT color="#008080">// Function name    : Primitives::L_endcase</FONT></I>
<I><FONT color="#008080">// Description      : ( -- )</FONT></I>
<I><FONT color="#008080">// internal compile-time   : AD( runcase-index[runcase] --          </FONT></I>
<I><FONT color="#008080">//                    gets the index of case from the auxilary data stack and the endcase index into</FONT></I>
<I><FONT color="#008080">//                    that location so that endof can jump to if its executed at runtime       </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_endcase(InterpreterData & idat)
{
    <B><FONT color="#000080">if</FONT></B>(idat.Compiling())                   <I><FONT color="#008080">// compiling ??</FONT></I>
    {   
          Word *fendcase = idat.IDict()-&gt;Address(<FONT color="#800000">"runendcase"</FONT>);  <I><FONT color="#008080">// address of word 'endcase'</FONT></I>
          
          <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> caseindex = idat.PopLabeledAD();               <I><FONT color="#008080">// case index</FONT></I>
           
          idat.BuildAddElement(fendcase);
          <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> ee = idat.BuildLastUsedElement();          
          idat.Building()-&gt;SetLiteralValue(caseindex - <FONT color="#800000">1</FONT>, &ee);     
    }
}

<I><FONT color="#008080">// Function name    : Primitives::L_immediate</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_immediate(InterpreterData & idat)
{
  ((idat.IDict())-&gt;MostRecent())-&gt;SetFlags(idat.ExecuteCompile);
}


<I><FONT color="#008080">// Function name    : Primitives::L_tocontext</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_tocontext(InterpreterData & idat)
{
  Word * ww = idat.ExvWord();
  (idat.IDict())-&gt;MakeContext(ww-&gt;Name());
}


<I><FONT color="#008080">// Function name    : Primitives::L_forth</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_forth(InterpreterData & idat)
{
  string sf = <FONT color="#800000">"forth"</FONT>;
  (idat.IDict())-&gt;MakeContext(sf); 
}


<I><FONT color="#008080">// Function name    : Primitives::L_vocabulary</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_vocabulary(InterpreterData & idat)
{
    string awrd;
    Parser * par = idat.IParser();
    <B><FONT color="#000080">char</FONT></B> * wrd;
    
    <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
    {
        <I><FONT color="#008080">// the word vocabulary is only interpreted "to create a vocabulary'</FONT></I>
        idat.ShowError(Errors::ILLEGALDEFINING);
        <B><FONT color="#000080">return</FONT></B>;
    }
    
    <B><FONT color="#000080">if</FONT></B>((wrd = par-&gt;NextWord()) != NULL)
    {
        awrd = wrd;
        <B><FONT color="#000080">if</FONT></B>(idat.IDict()-&gt;Exists(awrd) == -<FONT color="#800000">1</FONT>)  <I><FONT color="#008080">// word does not exist</FONT></I>
        {
            <B><FONT color="#000080">if</FONT></B>(!par-&gt;AllDigits(wrd))         <I><FONT color="#008080">// word is not a number</FONT></I>
            {
                <B><FONT color="#000080">if</FONT></B>((idat.IDict())-&gt;AddVoc(awrd))
                {
                    idat.BuildWithName(awrd); 
                    Element *pel = <B><FONT color="#000080">new</FONT></B> Element(L_tocontext);
                    idat.BuildAddElement((*pel));  
                    <B><FONT color="#000080">delete</FONT></B> pel;
                    idat.BuildFinishWord();
                }
                <B><FONT color="#000080">else</FONT></B>
                {
                    idat.ShowError(Errors::WORD_EXISTS, awrd);
                }
            }
            <B><FONT color="#000080">else</FONT></B>
            {
                <I><FONT color="#008080">// trying to name a word with a number error</FONT></I>
                idat.ShowError(Errors::IS_NUMBER);
            }
        }
        <B><FONT color="#000080">else</FONT></B>
        {
            <I><FONT color="#008080">// word already exists error</FONT></I>
            idat.ShowError(Errors::WORD_EXISTS, awrd);
        }
    } 
    <B><FONT color="#000080">else</FONT></B>
    {
        <I><FONT color="#008080">// buffer end reached</FONT></I>
        idat.ShowError(Errors::BUFFER_END);
    }
}


<I><FONT color="#008080">// Function name    : Primitives::L_definitions</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_definitions(InterpreterData & idat)
{
  (idat.IDict())-&gt;ContextToCurrent();
}


<I><FONT color="#008080">// Function name    : Primitives::L_literal</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_literal(InterpreterData & idat)
{
    <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
    {
       <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> gg = idat.PopD();
       idat.BuildAddElement(gg);
    }
    <B><FONT color="#000080">else</FONT></B>
    {
       idat.ShowError(Errors::ONLY_COMPILED);
    }
}


<I><FONT color="#008080">// Function name    : Primitives::L_postpone</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_postpone(InterpreterData & idat)
{
    string awrd;
    Parser * par = idat.IParser();
    <B><FONT color="#000080">char</FONT></B> * wrd;
    
    <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
    {
        <B><FONT color="#000080">if</FONT></B>((wrd = par-&gt;NextWord()) != NULL)
        {
            awrd = wrd;
            Word *postpned = idat.IDict()-&gt;Address(awrd);
            <B><FONT color="#000080">if</FONT></B>(postpned != NULL)
            {
                idat.BuildAddElement(postpned);
            }
            <B><FONT color="#000080">else</FONT></B>
            {
                idat.ShowError(Errors::NO_SUCH_WORD, awrd);
            }
        }
        <B><FONT color="#000080">else</FONT></B>
        {
            <I><FONT color="#008080">// buffer end reached</FONT></I>
            idat.ShowError(Errors::BUFFER_END);
        }
    }
    <B><FONT color="#000080">else</FONT></B>
    {
        idat.ShowError(Errors::ONLY_COMPILED);
    }  
}


<I><FONT color="#008080">// Function name    : Primitives::L_vocquery</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_vocquery(InterpreterData & idat)
{
  Word * ww = (Word *) idat.PopD();
  string vf;
  vf.reserve(<FONT color="#800000">60</FONT>);

  <B><FONT color="#000080">bool</FONT></B> ar = (idat.IDict())-&gt;VocNameForWord(ww , vf);
  <B><FONT color="#000080">if</FONT></B>(ar == true)
  {
    idat.Out() += vf.c_str();
    idat.WriteOut(); 
  }
  <B><FONT color="#000080">else</FONT></B>
  {
    idat.Out() += <FONT color="#800000">"Word not found"</FONT>;
    idat.WriteOut(); 
  }
}


<I><FONT color="#008080">// Function name    : Primitives::L_bl</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_bl(InterpreterData & idat)
{
  idat.PushD((<B><FONT color="#000080">long</FONT></B>)<FONT color="#800000">' '</FONT>);
}

<I><FONT color="#008080">// Function name    : Primitives::L_word</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_word(InterpreterData & idat)
{
  <B><FONT color="#000080">char</FONT></B> delim = idat.PopD();
  Parser * ppar = idat.IParser();
  <B><FONT color="#000080">char</FONT></B> nch = <FONT color="#800000">0</FONT>;

  <B><FONT color="#000080">while</FONT></B>( ((nch = ppar-&gt;GetChar()) == delim)  || isspace(nch)) 
  {
    ppar-&gt;Advance();
  }

  <B><FONT color="#000080">char</FONT></B> *cs = idat.WordBuf();
  <B><FONT color="#000080">char</FONT></B> *cc = cs;
  cc += <FONT color="#800000">4</FONT>;
  *((<B><FONT color="#000080">long</FONT></B> *)cs) = <FONT color="#800000">0</FONT>;

  <B><FONT color="#000080">for</FONT></B>(<B><FONT color="#000080">long</FONT></B> ii = <FONT color="#800000">0</FONT>;ii &lt; <FONT color="#800000">300</FONT>; ii++)
  {
    nch = ppar-&gt;GetChar(); 
    <B><FONT color="#000080">if</FONT></B>(nch != delim)
    {
       cc[ii] = nch;
       cc[ii + <FONT color="#800000">1</FONT>] = <FONT color="#800000">32</FONT>;
       cc[ii + <FONT color="#800000">2</FONT>] = <FONT color="#800000">0</FONT>;
       *((<B><FONT color="#000080">long</FONT></B> *)cs) = ii + <FONT color="#800000">1</FONT>;
       ppar-&gt;Advance();
       <B><FONT color="#000080">if</FONT></B>(nch == <FONT color="#800000">0</FONT>)
       {
          <B><FONT color="#000080">break</FONT></B>;
       }
    }
    <B><FONT color="#000080">else</FONT></B>
    {
       ppar-&gt;Advance();
       <B><FONT color="#000080">break</FONT></B>;
    }
  }
  ppar-&gt;Advance();
  idat.PushD((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>)cs);
}

<I><FONT color="#008080">// Function name    : Primitives::L_create</FONT></I>
<I><FONT color="#008080">// Description      : create &lt;word&gt; ... ;create | does&gt; ... ;</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_create(InterpreterData & idat)
{
  string awrd;
  Parser * par = idat.IParser();
  <B><FONT color="#000080">char</FONT></B> * wrd;

 <B><FONT color="#000080">if</FONT></B>((wrd = par-&gt;NextWord()) != NULL)
 {
    awrd = wrd;
    <B><FONT color="#000080">long</FONT></B> lval = 0l;
    <B><FONT color="#000080">if</FONT></B>(idat.IDict()-&gt;Exists(awrd) == -<FONT color="#800000">1</FONT>)  <I><FONT color="#008080">// word does not exist</FONT></I>
    {
         <B><FONT color="#000080">if</FONT></B>(!par-&gt;AllDigits(wrd))         <I><FONT color="#008080">// word is not a number</FONT></I>
         { 
           idat.BuildWithName(awrd); 
           idat.BuildAddElement(lval);  
         }
         <B><FONT color="#000080">else</FONT></B>
         {
            <I><FONT color="#008080">// trying to name a word with a number error</FONT></I>
            idat.ShowError(Errors::IS_NUMBER);
         }
    }
    <B><FONT color="#000080">else</FONT></B>
     {
        <I><FONT color="#008080">// word already exists error</FONT></I>
        idat.ShowError(Errors::WORD_EXISTS, awrd);
     }
 } 
 <B><FONT color="#000080">else</FONT></B>
 {
      <I><FONT color="#008080">// buffer end reached</FONT></I>
      idat.ShowError(Errors::BUFFER_END);
 }
}


<I><FONT color="#008080">// Function name    : Primitives::L_endcreate</FONT></I>
<I><FONT color="#008080">// Description      : create &lt;word&gt; ... ;create | does&gt; ... ;</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_endcreate(InterpreterData & idat)
{
  Word * ww = idat.Building();
  <B><FONT color="#000080">if</FONT></B>(ww != NULL)
  {
    idat.BuildFinishWord();
  }
  <B><FONT color="#000080">else</FONT></B>
  {
    idat.ShowError(Errors::NO_CREATE);
  }
}

<I><FONT color="#008080">// Function name    : Primitives::L_allot</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_allot(InterpreterData & idat)
{
  <B><FONT color="#000080">long</FONT></B> nn = idat.PopD();
  <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> uu = (<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>) idat.MManager().AllocateType(MemInstDat::m_CharArray, nn+<FONT color="#800000">1</FONT>);
  Word * ww = idat.Building();
  <B><FONT color="#000080">if</FONT></B>(ww != NULL)
  {
     <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> ee = idat.BuildLastUsedElement();
     idat.Building()-&gt;SetLiteralValue(ee, &uu);
  }
  <B><FONT color="#000080">else</FONT></B>
  {
     idat.MManager().DeleteMem((<B><FONT color="#000080">void</FONT></B> *) uu, MemInstDat::m_CharArray);
     idat.ShowError(Errors::NO_CREATE);
  }
}


<I><FONT color="#008080">// Function name    : Primitives::L_execute_at</FONT></I>
<I><FONT color="#008080">// Description      : ( index word -- )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_execute_at(InterpreterData & idat)
{   
   Word *ww = (Word *) idat.PopD();
   <B><FONT color="#000080">int</FONT></B> ind = idat.PopD();

 <I><FONT color="#008080">//  RSData rr(ww);</FONT></I>
 <I><FONT color="#008080">//  rr.SetIndex(ind);</FONT></I>
 <I><FONT color="#008080">//  idat.PushR(rr);</FONT></I>
   ww-&gt;Execute(ind, idat);
}

<I><FONT color="#008080">// Function name    : Primitives::L_does</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_rundoes(InterpreterData & idat)
{
  Word * ww;
  <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> ee;

    ww = idat.Building();
    <B><FONT color="#000080">if</FONT></B>(ww != NULL)
    {
        RSData ar = idat.GetRsv(<FONT color="#800000">0</FONT>);
        Word *calling = ar.Code();    
        ee = idat.PopD();

       <B><FONT color="#000080">if</FONT></B>(calling != NULL)
       {
          idat.BuildAddElement(ee + <FONT color="#800000">3</FONT>);
          idat.BuildAddElement((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>)calling);
          Element *pel = <B><FONT color="#000080">new</FONT></B> Element(L_execute_at);
          idat.BuildAddElement((*pel));
          idat.BuildFinishWord();
          <B><FONT color="#000080">delete</FONT></B> pel;
          <B><FONT color="#000080">int</FONT></B> ind = calling-&gt;NextIndex();
          ar.SetIndex(ind - <FONT color="#800000">1</FONT>);
          idat.SetRsv(ar, <FONT color="#800000">0</FONT>);
       }
       <B><FONT color="#000080">else</FONT></B>
       {
          idat.ShowError(Errors::SYNTAX_ERROR);
       }
    }
    <B><FONT color="#000080">else</FONT></B>
    {
       idat.ShowError(Errors::NO_CREATE);
    }
}

<I><FONT color="#008080">// Function name    : Primitives::L_does</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_does(InterpreterData & idat)
{
  Word * ww;
  <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> ee;

  <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
  {
     ww = idat.Building();
     ee = idat.BuildLastUsedElement();
     idat.BuildAddElement(ee);
     Word *fdoes = idat.IDict()-&gt;Address(<FONT color="#800000">"rundoes&gt;"</FONT>);
     idat.BuildAddElement(fdoes);
  }
  <B><FONT color="#000080">else</FONT></B>
  {
    ww = idat.Building();
    <B><FONT color="#000080">if</FONT></B>(ww != NULL)
    {
        RSData ar = idat.GetRsv(<FONT color="#800000">0</FONT>);
        Word *calling = ar.Code();    
        ee = idat.PopD();

       <B><FONT color="#000080">if</FONT></B>(calling != NULL)
       {
          idat.BuildAddElement(ee + <FONT color="#800000">3</FONT>);
          idat.BuildAddElement((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>)calling);
          Element *pel = <B><FONT color="#000080">new</FONT></B> Element(L_execute_at);
          idat.BuildAddElement((*pel));
          idat.BuildFinishWord();
          <B><FONT color="#000080">delete</FONT></B> pel;
          <B><FONT color="#000080">int</FONT></B> ind = calling-&gt;NextIndex();
          ar.SetIndex(ind - <FONT color="#800000">1</FONT>);
          idat.SetRsv(ar, <FONT color="#800000">0</FONT>);
       }
       <B><FONT color="#000080">else</FONT></B>
       {
          idat.ShowError(Errors::SYNTAX_ERROR);
       }
    }
    <B><FONT color="#000080">else</FONT></B>
    {
       idat.ShowError(Errors::NO_CREATE);
    }
  }
}

<I><FONT color="#008080">// Function name    : Primitives::L_exit</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_runexit(InterpreterData & idat)
{
       RSData ar = idat.GetRsv(<FONT color="#800000">0</FONT>);
       Word *calling = ar.Code();   
       <B><FONT color="#000080">int</FONT></B> ind = calling-&gt;NextIndex();
       ar.SetIndex(ind - <FONT color="#800000">1</FONT>);
       idat.SetRsv(ar, <FONT color="#800000">0</FONT>);
}


<I><FONT color="#008080">// Function name    : Primitives::L_exit</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_exit(InterpreterData & idat)
{
    <B><FONT color="#000080">if</FONT></B>(idat.Compiling())
    {
       idat.ExtractNthLabeledAD(<FONT color="#800000">"rununloop"</FONT>, <FONT color="#800000">1</FONT>);       
       Word *fexit = idat.IDict()-&gt;Address(<FONT color="#800000">"runexit"</FONT>);
       idat.BuildAddElement(fexit);
    }
    <B><FONT color="#000080">else</FONT></B>
    {
       RSData ar = idat.GetRsv(<FONT color="#800000">0</FONT>);
       Word *calling = ar.Code();   
       <B><FONT color="#000080">int</FONT></B> ind = calling-&gt;NextIndex();
       ar.SetIndex(ind - <FONT color="#800000">1</FONT>);
       idat.SetRsv(ar, <FONT color="#800000">0</FONT>);
    }
}


<I><FONT color="#008080">// Function name    : Primitives::L_recurse</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_recurse(InterpreterData & idat)
{
    RSData ar = idat.GetRsv(<FONT color="#800000">0</FONT>);
    Word *calling = ar.Code();   
    calling-&gt;Execute(<FONT color="#800000">0</FONT>, idat);
}


<I><FONT color="#008080">// Function name    : Primitives::L_leftbracket</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_leftbracket(InterpreterData & idat)
{
   idat.EndCompile();
}


<I><FONT color="#008080">// Function name    : Primitives::L_rightbracket</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_rightbracket(InterpreterData & idat)
{
   idat.Compile();
}


<I><FONT color="#008080">// Function name    : Primitives::L_quit</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_quit(InterpreterData & idat)
{
   Word * fnop = idat.IDict()-&gt;Address(<FONT color="#800000">"nop"</FONT>);
   Word * ww = NULL;
   RSData ar;

   <B><FONT color="#000080">while</FONT></B>(fnop != ww)
   {
     ar = idat.PopR(); 
     ww = ar.Code();
   }
   idat.PushR(ar);
}


<I><FONT color="#008080">// Function name    : Primitives::L_release</FONT></I>
<I><FONT color="#008080">// Description      : Remove a vocabulary from the search list</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_release(InterpreterData & idat)
{
  string awrd;
  Parser * par = idat.IParser();
  <B><FONT color="#000080">char</FONT></B> * wrd;
  <B><FONT color="#000080">long</FONT></B> vv = 0L;

 <B><FONT color="#000080">if</FONT></B>((wrd = par-&gt;NextWord()) != NULL)
 {
    awrd = wrd;
    Word *fv = idat.IDict()-&gt;Address(awrd);
    <B><FONT color="#000080">if</FONT></B>(fv != NULL)
    {
       string sv = fv-&gt;Name();
       vv = idat.IDict()-&gt;RemoveVocSearch(sv);
    }
 }
 idat.PushD((<B><FONT color="#000080">long</FONT></B>)vv);
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_rpush(InterpreterData & idat)
{
  RSData ar, mr;
   mr = idat.PopR();

  <B><FONT color="#000080">void</FONT></B> * vv = (<B><FONT color="#000080">void</FONT></B> *) idat.PopD();
  <B><FONT color="#000080">if</FONT></B>(idat.MManager().IsMem(vv, MemInstDat::m_RSData))
  {
    RSData * qq = (RSData *) vv;
    idat.PushR(*qq);
    idat.MManager().DeleteMem(vv, MemInstDat::m_RSData);
  }
  <B><FONT color="#000080">else</FONT></B>
  {
    Word *fn = idat.IDict()-&gt;Address(<FONT color="#800000">"nop"</FONT>);
    ar.SetCode(fn);
    ar.SetIndex((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>) vv);
    idat.PushR(ar);
  }
  idat.PushR(mr);
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_rpop(InterpreterData & idat)
{
  RSData mr, mw;
  mr = idat.PopR();

  <B><FONT color="#000080">long</FONT></B> rr;

  RSData *par = (RSData *) idat.MManager().AllocateType(MemInstDat::m_RSData, <FONT color="#800000">0</FONT>);
  *par = idat.PopR();
  Word *fn = idat.IDict()-&gt;Address(<FONT color="#800000">"nop"</FONT>);
  Word *fr = par-&gt;Code();

  <B><FONT color="#000080">if</FONT></B>(fr == fn)
  {
    rr = par-&gt;Index();
    idat.MManager().DeleteMem((<B><FONT color="#000080">void</FONT></B> *)par, MemInstDat::m_RSData);
  }
  <B><FONT color="#000080">else</FONT></B>
  {
    rr = (<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>) par;
  }
  idat.PushD(rr);
  idat.PushR(mr);
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_rfetch(InterpreterData & idat)
{
  <B><FONT color="#000080">long</FONT></B> rr;
  RSData *par = (RSData *) idat.MManager().AllocateType(MemInstDat::m_RSData, <FONT color="#800000">0</FONT>);
  *par = idat.GetRsv(<FONT color="#800000">1</FONT>);
  Word *fn = idat.IDict()-&gt;Address(<FONT color="#800000">"nop"</FONT>);
  Word * fr = par-&gt;Code();
  <B><FONT color="#000080">if</FONT></B>(fr == fn)
  {
    rr = par-&gt;Index();
    idat.MManager().DeleteMem((<B><FONT color="#000080">void</FONT></B> *)par, MemInstDat::m_RSData);
  }
  <B><FONT color="#000080">else</FONT></B>
  {
    rr = (<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>) par;
  }
  idat.PushD(rr);
}

<I><FONT color="#008080">// Function name    : Primitives::L_nip</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_nip(InterpreterData & idat)
{
  <B><FONT color="#000080">long</FONT></B> qq = idat.PopD();
  idat.PopD();
  idat.PushD(qq);
}


<I><FONT color="#008080">// Function name    : Primitives::L_roll</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_roll(InterpreterData & idat)
{
  <B><FONT color="#000080">long</FONT></B> qq = idat.PopD();
  idat.RollDatv(qq);
}


<I><FONT color="#008080">// Function name    : Primitives::L_pick</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_pick(InterpreterData & idat)
{
  <B><FONT color="#000080">long</FONT></B> qq = idat.PopD();
  <B><FONT color="#000080">long</FONT></B> gg = idat.GetDatv(qq);
  idat.PushD(gg);
}

<I><FONT color="#008080">// Function name    : Primitives::L_twodup</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_twodup(InterpreterData & idat)
{
   <B><FONT color="#000080">long</FONT></B> qq = idat.PopD();
  <B><FONT color="#000080">long</FONT></B> rr = idat.PopD();
  idat.PushD(rr);
  idat.PushD(qq);
  idat.PushD(rr);
  idat.PushD(qq);  
}

<I><FONT color="#008080">// Function name    : Primitives::L_twoswap</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_twoswap(InterpreterData & idat)
{
  <B><FONT color="#000080">long</FONT></B> qq = idat.PopD();
  <B><FONT color="#000080">long</FONT></B> rr = idat.PopD();
  <B><FONT color="#000080">long</FONT></B> ss = idat.PopD();
  <B><FONT color="#000080">long</FONT></B> tt = idat.PopD();

  idat.PushD(rr);
  idat.PushD(qq);
  idat.PushD(tt);
  idat.PushD(ss);  
}

<I><FONT color="#008080">// Function name    : Primitives::L_twoswap</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_twoover(InterpreterData & idat)
{
  <B><FONT color="#000080">long</FONT></B> qq = idat.PopD();  <I><FONT color="#008080">// 4</FONT></I>
  <B><FONT color="#000080">long</FONT></B> rr = idat.PopD();  <I><FONT color="#008080">// 3</FONT></I>
  <B><FONT color="#000080">long</FONT></B> ss = idat.PopD();  <I><FONT color="#008080">// 2 </FONT></I>
  <B><FONT color="#000080">long</FONT></B> tt = idat.PopD();  <I><FONT color="#008080">// 1</FONT></I>

  idat.PushD(tt);
  idat.PushD(ss);
  idat.PushD(rr);
  idat.PushD(qq);  
  idat.PushD(tt);
  idat.PushD(ss);
}

<I><FONT color="#008080">// Function name    : Primitives::L_twodrop</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_twodrop(InterpreterData & idat)
{
  <B><FONT color="#000080">long</FONT></B> qq = idat.PopD();
  <B><FONT color="#000080">long</FONT></B> rr = idat.PopD();
}

<I><FONT color="#008080">// Function name    : Primitives::L_cell</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_cell(InterpreterData & idat)
{
  idat.PushD(<B><FONT color="#000080">sizeof</FONT></B>(<B><FONT color="#000080">long</FONT></B>));  
}

<I><FONT color="#008080">// Function name    : Primitives::L_cellplus</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_cellplus(InterpreterData & idat)
{
  <B><FONT color="#000080">long</FONT></B> qq = idat.PopD();
  idat.PushD((qq + <B><FONT color="#000080">sizeof</FONT></B>(<B><FONT color="#000080">long</FONT></B>))); 
}

<I><FONT color="#008080">// Function name    : Primitives::L_cellplus</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_charplus(InterpreterData & idat)
{
  <B><FONT color="#000080">long</FONT></B> qq = idat.PopD();
  idat.PushD((qq + <B><FONT color="#000080">sizeof</FONT></B>(<B><FONT color="#000080">char</FONT></B>))); 
}

<I><FONT color="#008080">// Function name    : Primitives::L_cells</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_cells(InterpreterData & idat)
{
  <B><FONT color="#000080">long</FONT></B> qq = idat.PopD();
  idat.PushD((qq * <B><FONT color="#000080">sizeof</FONT></B>(<B><FONT color="#000080">long</FONT></B>)));  
}

<I><FONT color="#008080">// Function name    : Primitives::L_chars</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_chars(InterpreterData & idat)
{
  <B><FONT color="#000080">long</FONT></B> qq = idat.PopD();
  idat.PushD((qq * <B><FONT color="#000080">sizeof</FONT></B>(<B><FONT color="#000080">char</FONT></B>)));  
}

<I><FONT color="#008080">// Function name    : Primitives::L_fill</FONT></I>
<I><FONT color="#008080">// Description      : ( addr u char -- )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_fill(InterpreterData & idat)
{
  <B><FONT color="#000080">int</FONT></B> cc = (<B><FONT color="#000080">int</FONT></B>) idat.PopD();
  <B><FONT color="#000080">long</FONT></B> uu = idat.PopD();
  <B><FONT color="#000080">char</FONT></B> * adr = (<B><FONT color="#000080">char</FONT></B> *) idat.PopD();

  memset(adr, cc, uu);
}

<I><FONT color="#008080">// Function name    : Primitives::L_move</FONT></I>
<I><FONT color="#008080">// Description      : ( addr u char -- )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_move(InterpreterData & idat)
{
  <B><FONT color="#000080">long</FONT></B> cc = idat.PopD();
  <B><FONT color="#000080">char</FONT></B>* adr1 = (<B><FONT color="#000080">char</FONT></B> *) idat.PopD();
  <B><FONT color="#000080">char</FONT></B>* adr2 = (<B><FONT color="#000080">char</FONT></B> *) idat.PopD();

  memmove(adr1, adr2, cc);
}

<I><FONT color="#008080">// Function name    : Primitives::L_true</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_true(InterpreterData & idat)
{
  idat.PushD((<B><FONT color="#000080">long</FONT></B>)true);  
}


<I><FONT color="#008080">// Function name    : Primitives::L_false</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_false(InterpreterData & idat)
{
  idat.PushD((<B><FONT color="#000080">long</FONT></B>)false);  
}

<I><FONT color="#008080">// Function name    : Primitives::L_memsize</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_memsize(InterpreterData & idat)
{
  <B><FONT color="#000080">void</FONT></B> *vv = (<B><FONT color="#000080">void</FONT></B> *) idat.PopD();
  <B><FONT color="#000080">long</FONT></B> qq = idat.MManager().MemSize(vv);
  idat.PushD(qq);
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_auxpush(InterpreterData & idat)
{
  <B><FONT color="#000080">long</FONT></B> qq = idat.PopD();
  idat.PushAD((<B><FONT color="#000080">long</FONT></B>)qq);
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_auxpop(InterpreterData & idat)
{
  <B><FONT color="#000080">long</FONT></B> qq = idat.PopAD();
  idat.PushD(qq);
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_auxswap(InterpreterData & idat)
{
  <B><FONT color="#000080">long</FONT></B> qq = idat.PopAD();
  <B><FONT color="#000080">long</FONT></B> mm = idat.PopAD();
  idat.PushAD((<B><FONT color="#000080">long</FONT></B>)qq);
  idat.PushAD((<B><FONT color="#000080">long</FONT></B>)mm);
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_auxdrop(InterpreterData & idat)
{
   <B><FONT color="#000080">long</FONT></B> aa = idat.PopAD();
}

<I><FONT color="#008080">// Function name    : Primitives::L_auxover</FONT></I>
<I><FONT color="#008080">// Description      : ( n1 n2 --- n1 n2 n1 )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_auxover(InterpreterData & idat)
{
   <B><FONT color="#000080">long</FONT></B> aa = idat.PopAD();  <I><FONT color="#008080">// n2</FONT></I>
   <B><FONT color="#000080">long</FONT></B> bb = idat.PopAD();  <I><FONT color="#008080">// n1</FONT></I>
   idat.PushAD(bb);         <I><FONT color="#008080">// n1</FONT></I>
   idat.PushAD(aa);         <I><FONT color="#008080">// n2</FONT></I>
   idat.PushAD(bb);         <I><FONT color="#008080">// n1</FONT></I>
}

<I><FONT color="#008080">// Function name    : Primitives::L_auxrot</FONT></I>
<I><FONT color="#008080">// Description      : ( n1 n2 n3 --- n2 n3 n1 )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_auxrot(InterpreterData & idat)
{
   <B><FONT color="#000080">long</FONT></B> aa = idat.PopAD();  <I><FONT color="#008080">// a</FONT></I>
   <B><FONT color="#000080">long</FONT></B> bb = idat.PopAD();  <I><FONT color="#008080">// b</FONT></I>
   <B><FONT color="#000080">long</FONT></B> cc = idat.PopAD();  <I><FONT color="#008080">// c</FONT></I>
   idat.PushAD((<B><FONT color="#000080">long</FONT></B>)bb);
   idat.PushAD((<B><FONT color="#000080">long</FONT></B>)aa);
   idat.PushAD((<B><FONT color="#000080">long</FONT></B>)cc);
}

<I><FONT color="#008080">// Function name    : Primitives::L_auxreverserot</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_auxreverserot(InterpreterData & idat)
{
   <B><FONT color="#000080">long</FONT></B> aa = idat.PopAD();  <I><FONT color="#008080">// n3</FONT></I>
   <B><FONT color="#000080">long</FONT></B> bb = idat.PopAD();  <I><FONT color="#008080">// n2</FONT></I>
   <B><FONT color="#000080">long</FONT></B> cc = idat.PopAD();  <I><FONT color="#008080">// n1</FONT></I>
   idat.PushAD((<B><FONT color="#000080">long</FONT></B>)aa);
   idat.PushAD((<B><FONT color="#000080">long</FONT></B>)cc);
   idat.PushAD((<B><FONT color="#000080">long</FONT></B>)bb);
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_auxtuck(InterpreterData & idat)
{
   <B><FONT color="#000080">long</FONT></B> aa = idat.PopAD();
   <B><FONT color="#000080">long</FONT></B> bb = idat.PopAD();

   idat.PushAD((<B><FONT color="#000080">long</FONT></B>)(aa));
   idat.PushAD((<B><FONT color="#000080">long</FONT></B>)(bb));
   idat.PushAD((<B><FONT color="#000080">long</FONT></B>)(aa));
}


<I><FONT color="#008080">// Function name    : Primitives::L_auxfetch</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_auxfetch(InterpreterData & idat)
{
  <B><FONT color="#000080">long</FONT></B> qq = idat.PopAD();
  idat.PushAD(qq);
  idat.PushD(qq);
}

<I><FONT color="#008080">// Function name    : Primitives::L_nip</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_auxnip(InterpreterData & idat)
{
  <B><FONT color="#000080">long</FONT></B> qq = idat.PopAD();
  idat.PopAD();
  idat.PushAD(qq);
}

<I><FONT color="#008080">// Function name    : Primitives::L_auxroll</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_auxroll(InterpreterData & idat)
{
  <B><FONT color="#000080">long</FONT></B> qq = idat.PopD();
  idat.RollADatv(qq);
}

<I><FONT color="#008080">// Function name    : Primitives::L_auxpick</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_auxpick(InterpreterData & idat)
{
  <B><FONT color="#000080">long</FONT></B> qq = idat.PopD();
  <B><FONT color="#000080">long</FONT></B> gg = idat.GetADatv(qq);
  idat.PushAD(gg);
}

<I><FONT color="#008080">// Function name    : Primitives::L_auxtwodup</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_auxtwodup(InterpreterData & idat)
{
  <B><FONT color="#000080">long</FONT></B> qq = idat.PopAD();
  <B><FONT color="#000080">long</FONT></B> rr = idat.PopAD();
  idat.PushAD(rr);
  idat.PushAD(qq);
  idat.PushAD(rr);
  idat.PushAD(qq);  
}


<I><FONT color="#008080">// Function name    : Primitives::L_auxtwodrop</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_auxtwodrop(InterpreterData & idat)
{
  <B><FONT color="#000080">long</FONT></B> qq = idat.PopAD();
  <B><FONT color="#000080">long</FONT></B> rr = idat.PopAD();
}


<I><FONT color="#008080">// Function name    : Primitives::L_timeanddate</FONT></I>
<I><FONT color="#008080">// Description      : ( -- +n1 +n2 +n3 +n4 +n5 +n6 )</FONT></I>
<I><FONT color="#008080">// The current time and date. +n1 is the second {0...59}, </FONT></I>
<I><FONT color="#008080">// +n2 is the minute {0...59}, +n3 is the hour {0...23}, </FONT></I>
<I><FONT color="#008080">// +n4 is the day {1...31} +n5 is the month {1...12}, </FONT></I>
<I><FONT color="#008080">// and +n6 is the year (e.g., 1991). </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_timeanddate(InterpreterData & idat)
{
   time_t ltime;
   <B><FONT color="#000080">struct</FONT></B> tm *today;
   time(&ltime);
   today = localtime(&ltime);
   idat.PushD((<B><FONT color="#000080">long</FONT></B>)today-&gt;tm_sec);
   idat.PushD((<B><FONT color="#000080">long</FONT></B>)today-&gt;tm_min);
   idat.PushD((<B><FONT color="#000080">long</FONT></B>)today-&gt;tm_hour);
   idat.PushD((<B><FONT color="#000080">long</FONT></B>)today-&gt;tm_mday);
   idat.PushD((<B><FONT color="#000080">long</FONT></B>)(today-&gt;tm_mon + <FONT color="#800000">1</FONT>));
   idat.PushD((<B><FONT color="#000080">long</FONT></B>)(today-&gt;tm_year + <FONT color="#800000">1900</FONT>));
}

<I><FONT color="#008080">// Function name    : Primitives::L_tuck</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_tuck(InterpreterData & idat)
{
   <B><FONT color="#000080">long</FONT></B> aa = idat.PopD();
   <B><FONT color="#000080">long</FONT></B> bb = idat.PopD();

   idat.PushD((<B><FONT color="#000080">long</FONT></B>)(aa));
   idat.PushD((<B><FONT color="#000080">long</FONT></B>)(bb));
   idat.PushD((<B><FONT color="#000080">long</FONT></B>)(aa));
}


<I><FONT color="#008080">// Function name    : Primitives::L_within</FONT></I>
<I><FONT color="#008080">// Description      : ( n1|u1 n2|u2 n3|u3 -- flag )</FONT></I>
<I><FONT color="#008080">// (n2|u2 &lt; n3|u3 and (n2|u2 &lt;= n1|u1 and n1|u1 &lt; n3|u3)) </FONT></I>
<I><FONT color="#008080">// or (n2|u2 &gt; n3|u3 and (n2|u2 &lt;= n1|u1 or n1|u1 &lt; n3|u3)) is true</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_within(InterpreterData & idat)
{
   <B><FONT color="#000080">long</FONT></B> n3 = idat.PopD();
   <B><FONT color="#000080">long</FONT></B> n2 = idat.PopD();
   <B><FONT color="#000080">long</FONT></B> n1 = idat.PopD();

   <B><FONT color="#000080">if</FONT></B>(n2 &lt; n3)
   {
     <B><FONT color="#000080">if</FONT></B>(n2 &lt;= n1 && n1 &lt; n3)
     {
       idat.PushD((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>)(true));
       <B><FONT color="#000080">return</FONT></B>;
     }
   }
  <B><FONT color="#000080">if</FONT></B>(n2 &gt; n3)
   {
     <B><FONT color="#000080">if</FONT></B>(n2 &lt;= n1 || n1 &lt; n3)
     {
       idat.PushD((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>)(true));
       <B><FONT color="#000080">return</FONT></B>;
     }
   }
  idat.PushD((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>)(false));
}

<I><FONT color="#008080">// floating point words</FONT></I>

<B><FONT color="#000080">void</FONT></B> Primitives::L_ftimes(InterpreterData & idat)
{
   <B><FONT color="#000080">double</FONT></B> n3 = idat.PopFD();
   <B><FONT color="#000080">double</FONT></B> n2 = idat.PopFD();
   idat.PushFD((n3 * n2));
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_fplus(InterpreterData & idat)
{
   <B><FONT color="#000080">double</FONT></B> n3 = idat.PopFD();
   <B><FONT color="#000080">double</FONT></B> n2 = idat.PopFD();
   idat.PushFD((n3 + n2));
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_fminus(InterpreterData & idat)
{
   <B><FONT color="#000080">double</FONT></B> n3 = idat.PopFD();
   <B><FONT color="#000080">double</FONT></B> n2 = idat.PopFD();
   idat.PushFD((n2 - n3));
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_fdivide(InterpreterData & idat)
{
   <B><FONT color="#000080">double</FONT></B> n3 = idat.PopFD();
   <B><FONT color="#000080">double</FONT></B> n2 = idat.PopFD();
   <B><FONT color="#000080">if</FONT></B> (n3 == <FONT color="#800000">0.0</FONT>)
   {
      idat.ShowError(Errors::DIVIDEBYZERO);
   }
   <B><FONT color="#000080">else</FONT></B>
   {
     idat.PushFD((n2 / n3));
   }
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_dtof(InterpreterData & idat)
{
   <B><FONT color="#000080">long</FONT></B> n3 = idat.PopD();
   idat.PushFD(((<B><FONT color="#000080">double</FONT></B>)n3));
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_ftod(InterpreterData & idat)
{
   <B><FONT color="#000080">double</FONT></B> aa = idat.PopFD();
   idat.PushD(((<B><FONT color="#000080">long</FONT></B>)aa));
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_fzeroless(InterpreterData & idat)
{
   <B><FONT color="#000080">double</FONT></B> n3 = idat.PopFD();
   <B><FONT color="#000080">if</FONT></B>(n3 &lt; <FONT color="#800000">0.0</FONT>)
   {
     idat.PushD(true);
   }
   <B><FONT color="#000080">else</FONT></B>  
   {
     idat.PushD((<B><FONT color="#000080">long</FONT></B>) false);
   }
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_fzeroequal(InterpreterData & idat)
{
   <B><FONT color="#000080">double</FONT></B> n3 = idat.PopFD();
   <B><FONT color="#000080">if</FONT></B>(n3 == <FONT color="#800000">0.0</FONT>)
   {
     idat.PushD(true);
   }
   <B><FONT color="#000080">else</FONT></B>  
   {
     idat.PushD((<B><FONT color="#000080">long</FONT></B>) false);
   }
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_fless(InterpreterData & idat)
{
   <B><FONT color="#000080">double</FONT></B> aa = idat.PopFD();
   <B><FONT color="#000080">double</FONT></B> bb = idat.PopFD();

   <B><FONT color="#000080">if</FONT></B>(bb &lt; aa)
   {
     idat.PushD(true);
   }
   <B><FONT color="#000080">else</FONT></B>  
   {
     idat.PushD((<B><FONT color="#000080">long</FONT></B>) false);
   }
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_flessequal(InterpreterData & idat)
{
   <B><FONT color="#000080">double</FONT></B> aa = idat.PopFD();
   <B><FONT color="#000080">double</FONT></B> bb = idat.PopFD();

   <B><FONT color="#000080">if</FONT></B>(bb &lt;= aa)
   {
     idat.PushD(true);
   }
   <B><FONT color="#000080">else</FONT></B>  
   {
     idat.PushD((<B><FONT color="#000080">long</FONT></B>) false);
   }
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_fgreater(InterpreterData & idat)
{
   <B><FONT color="#000080">double</FONT></B> aa = idat.PopFD();
   <B><FONT color="#000080">double</FONT></B> bb = idat.PopFD();

   <B><FONT color="#000080">if</FONT></B>(bb &gt; aa)
   {
     idat.PushD(true);
   }
   <B><FONT color="#000080">else</FONT></B>  
   {
     idat.PushD((<B><FONT color="#000080">long</FONT></B>) false);
   }
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_fgreaterequal(InterpreterData & idat)
{
   <B><FONT color="#000080">double</FONT></B> aa = idat.PopFD();
   <B><FONT color="#000080">double</FONT></B> bb = idat.PopFD();

   <B><FONT color="#000080">if</FONT></B>(bb &gt;= aa)
   {
     idat.PushD(true);
   }
   <B><FONT color="#000080">else</FONT></B>  
   {
     idat.PushD((<B><FONT color="#000080">long</FONT></B>) false);
   }
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_fdrop(InterpreterData & idat)
{
   idat.PopFD();
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_fdup(InterpreterData & idat)
{
   <B><FONT color="#000080">double</FONT></B> aa = idat.PopFD();
   idat.PushFD(aa);
   idat.PushFD(aa);
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_fnip(InterpreterData & idat)
{
  <B><FONT color="#000080">double</FONT></B> qq = idat.PopFD();
  idat.PopFD();
  idat.PushFD(qq);
}


<I><FONT color="#008080">// Function name    : Primitives::L_froll</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_froll(InterpreterData & idat)
{
  <B><FONT color="#000080">long</FONT></B> qq = idat.PopD();
  idat.RollFDatv(qq);
}


<I><FONT color="#008080">// Function name    : Primitives::L_fpick</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_fpick(InterpreterData & idat)
{
  <B><FONT color="#000080">long</FONT></B> qq = idat.PopD();
  <B><FONT color="#000080">long</FONT></B> gg = idat.GetFDatv(qq);
  idat.PushFD(gg);
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_fover(InterpreterData & idat)
{
   <B><FONT color="#000080">double</FONT></B> aa = idat.PopFD();  <I><FONT color="#008080">// n2</FONT></I>
   <B><FONT color="#000080">double</FONT></B> bb = idat.PopFD();  <I><FONT color="#008080">// n1</FONT></I>
   idat.PushAD(bb);         <I><FONT color="#008080">// n1</FONT></I>
   idat.PushAD(aa);         <I><FONT color="#008080">// n2</FONT></I>
   idat.PushAD(bb);         <I><FONT color="#008080">// n1</FONT></I>
}

<I><FONT color="#008080">// Function name    : Primitives::L_frot</FONT></I>
<I><FONT color="#008080">// Description      : ( f1 f2 f3 --- f2 f3 f1 )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_frot(InterpreterData & idat)
{
   <B><FONT color="#000080">double</FONT></B> aa = idat.PopFD();  <I><FONT color="#008080">// a</FONT></I>
   <B><FONT color="#000080">double</FONT></B> bb = idat.PopFD();  <I><FONT color="#008080">// b</FONT></I>
   <B><FONT color="#000080">double</FONT></B> cc = idat.PopFD();  <I><FONT color="#008080">// c</FONT></I>
   idat.PushFD(bb);
   idat.PushFD(aa);
   idat.PushFD(cc);
}

<I><FONT color="#008080">// Function name    : Primitives::L_freverserot</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_freverserot(InterpreterData & idat)
{
   <B><FONT color="#000080">double</FONT></B> aa = idat.PopFD();  <I><FONT color="#008080">// a</FONT></I>
   <B><FONT color="#000080">double</FONT></B> bb = idat.PopFD();  <I><FONT color="#008080">// b</FONT></I>
   <B><FONT color="#000080">double</FONT></B> cc = idat.PopFD();  <I><FONT color="#008080">// c</FONT></I>
   idat.PushFD(aa);
   idat.PushFD(cc);
   idat.PushFD(bb);
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_ftuck(InterpreterData & idat)
{
   <B><FONT color="#000080">double</FONT></B> aa = idat.PopFD();  <I><FONT color="#008080">// a</FONT></I>
   <B><FONT color="#000080">double</FONT></B> bb = idat.PopFD();  <I><FONT color="#008080">// b</FONT></I>

   idat.PushFD(aa);
   idat.PushFD(bb);
   idat.PushFD(aa);
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_fpower(InterpreterData & idat)
{
   <B><FONT color="#000080">double</FONT></B> n3 = idat.PopFD();
   <B><FONT color="#000080">double</FONT></B> n2 = idat.PopFD();
   idat.PushFD(pow( n2, n3));
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_fabs(InterpreterData & idat)
{
   <B><FONT color="#000080">double</FONT></B> aa = idat.PopFD();
   idat.PushFD(fabs( aa));
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_facos(InterpreterData & idat)
{
   <B><FONT color="#000080">double</FONT></B> aa = idat.PopFD();
   idat.PushFD(acos( aa));
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_fcos(InterpreterData & idat)
{
   <B><FONT color="#000080">double</FONT></B> aa = idat.PopFD();
   idat.PushFD(cos( aa));
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_fcosh(InterpreterData & idat)
{
   <B><FONT color="#000080">double</FONT></B> aa = idat.PopFD();
   idat.PushFD(cosh( aa));
}

<I><FONT color="#008080">//void Primitives::L_facosh(InterpreterData & idat)</FONT></I>
<I><FONT color="#008080">//{</FONT></I>
<I><FONT color="#008080">//   double aa = idat.PopFD();</FONT></I>
<I><FONT color="#008080">//   idat.PushFD(acosh( aa));</FONT></I>
<I><FONT color="#008080">//}</FONT></I>

<B><FONT color="#000080">void</FONT></B> Primitives::L_fasin(InterpreterData & idat)
{
   <B><FONT color="#000080">double</FONT></B> aa = idat.PopFD();
   idat.PushFD(asin( aa));
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_fsin(InterpreterData & idat)
{
   <B><FONT color="#000080">double</FONT></B> aa = idat.PopFD();
   idat.PushFD(sin( aa));
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_fsincos(InterpreterData & idat)
{
   <B><FONT color="#000080">double</FONT></B> aa = idat.PopFD();
   idat.PushFD(cos( aa));
   idat.PushFD(sin( aa));
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_fsinh(InterpreterData & idat)
{
   <B><FONT color="#000080">double</FONT></B> aa = idat.PopFD();
   idat.PushFD(sinh( aa));
}

<I><FONT color="#008080">//void Primitives::L_fasinh(InterpreterData & idat)</FONT></I>
<I><FONT color="#008080">//{</FONT></I>
<I><FONT color="#008080">//   double aa = idat.PopFD();</FONT></I>
<I><FONT color="#008080">//   idat.PushFD(asinh( aa));</FONT></I>
<I><FONT color="#008080">//}</FONT></I>

<B><FONT color="#000080">void</FONT></B> Primitives::L_fatan(InterpreterData & idat)
{
   <B><FONT color="#000080">double</FONT></B> aa = idat.PopFD();
   idat.PushFD(atan( aa));
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_ftan(InterpreterData & idat)
{
   <B><FONT color="#000080">double</FONT></B> aa = idat.PopFD();
   idat.PushFD(tan( aa));
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_ftanh(InterpreterData & idat)
{
   <B><FONT color="#000080">double</FONT></B> aa = idat.PopFD();
   idat.PushFD(tanh( aa));
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_fatan2(InterpreterData & idat)
{
   <B><FONT color="#000080">double</FONT></B> xx = idat.PopFD();
   <B><FONT color="#000080">double</FONT></B> yy = idat.PopFD();

   idat.PushFD(atan2( yy, xx));
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_fexp(InterpreterData & idat)
{
   <B><FONT color="#000080">double</FONT></B> aa = idat.PopFD();
   idat.PushFD(exp( aa));
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_fln(InterpreterData & idat)
{
   <B><FONT color="#000080">double</FONT></B> aa = idat.PopFD();
   idat.PushFD(log( aa));
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_flog(InterpreterData & idat)
{
   <B><FONT color="#000080">double</FONT></B> aa = idat.PopFD();
   idat.PushFD(log10( aa));
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_sqrt(InterpreterData & idat)
{
   <B><FONT color="#000080">double</FONT></B> aa = idat.PopFD();
   idat.PushFD(sqrt( aa));
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_fdot(InterpreterData & idat)
{
   <B><FONT color="#000080">double</FONT></B> aa = idat.PopFD();
   <B><FONT color="#000080">char</FONT></B> ss[<FONT color="#800000">35</FONT>];
   sprintf(ss,<FONT color="#800000">" %f "</FONT>,aa);
   idat.Out() += ss;
   idat.WriteOut();
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_fmin(InterpreterData & idat)
{
   <B><FONT color="#000080">double</FONT></B> xx = idat.PopFD();
   <B><FONT color="#000080">double</FONT></B> yy = idat.PopFD();

   idat.PushFD(__min( yy, xx));
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_fmax(InterpreterData & idat)
{
   <B><FONT color="#000080">double</FONT></B> xx = idat.PopFD();
   <B><FONT color="#000080">double</FONT></B> yy = idat.PopFD();

   idat.PushFD(__max( yy, xx));
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_fnegate(InterpreterData & idat)
{
   <B><FONT color="#000080">double</FONT></B> xx = idat.PopFD();
   idat.PushFD(-xx);
}

<I><FONT color="#008080">// void Primitives::L_ftofloat(InterpreterData & idat)</FONT></I>
<I><FONT color="#008080">//{</FONT></I>
<I><FONT color="#008080">//   long xx = idat.PopD();  // </FONT></I>
<I><FONT color="#008080">//  </FONT></I>
<I><FONT color="#008080">//   idat.PushFD(-xx);</FONT></I>
<I><FONT color="#008080">//}</FONT></I>


<I><FONT color="#008080">// end floating point</FONT></I>

<B><FONT color="#000080">void</FONT></B> Primitives::L_ReadEntireFile(InterpreterData & idat)
{
  string * st = ((string *) idat.PopD());
  <B><FONT color="#000080">int</FONT></B> fh;
  <B><FONT color="#000080">char</FONT></B> *buf;

  <B><FONT color="#000080">if</FONT></B>((fh = open(st-&gt;c_str(), _O_RDONLY )) &gt;= <FONT color="#800000">0</FONT>)
  {
    <B><FONT color="#000080">long</FONT></B> ll = filelength(fh);
    buf = (<B><FONT color="#000080">char</FONT></B> *) idat.MManager().AllocateType(MemInstDat::m_CharArray, (ll+<FONT color="#800000">1</FONT>));
    read(fh, buf, ll);
    close(fh);
  }
  idat.PushD((<B><FONT color="#000080">long</FONT></B>)buf);
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_evaluate(InterpreterData & idat)
{
  <B><FONT color="#000080">long</FONT></B> uu = idat.PopD();
  <B><FONT color="#000080">char</FONT></B> *cc = (<B><FONT color="#000080">char</FONT></B> *) idat.PopD();
  idat.Parse(cc);
<I><FONT color="#008080">//  idat.ResetFatal();</FONT></I>
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_include(InterpreterData & idat)
{

  string *fnam = (string *) idat.PopD();
  <B><FONT color="#000080">int</FONT></B> nf = -<FONT color="#800000">1</FONT>;

  <B><FONT color="#000080">if</FONT></B>((nf = open(fnam-&gt;c_str(), _O_RDONLY)) != -<FONT color="#800000">1</FONT>)
  {
    <B><FONT color="#000080">long</FONT></B> nn = _filelength(nf);
    <B><FONT color="#000080">char</FONT></B> * dbuf = <B><FONT color="#000080">new</FONT></B> <B><FONT color="#000080">char</FONT></B>[nn];
    memset(dbuf,<FONT color="#800000">0</FONT>,nn);
    read(nf, dbuf, nn);
    close(nf);
    idat.Parse(dbuf);
    <B><FONT color="#000080">delete</FONT></B> [] dbuf;   
  }
}


<I><FONT color="#008080">// STL Interpreter ---------------------------</FONT></I>

<B><FONT color="#000080">void</FONT></B> Primitives::L_STLVect(InterpreterData & idat)
{
  string awrd;
  Parser * par = idat.IParser();
  <B><FONT color="#000080">char</FONT></B> * wrd;

 <B><FONT color="#000080">if</FONT></B>((wrd = par-&gt;NextWord()) != NULL)
 {
    awrd = wrd;
    <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> lval = 0l;
    <B><FONT color="#000080">if</FONT></B>(idat.IDict()-&gt;Exists(awrd) == -<FONT color="#800000">1</FONT>)  <I><FONT color="#008080">// word does not exist</FONT></I>
    {
         <B><FONT color="#000080">if</FONT></B>(!par-&gt;AllDigits(wrd))         <I><FONT color="#008080">// word is not a number</FONT></I>
         { 
           idat.BuildWithName(awrd); 
           STLVect * sv = (STLVect *) idat.MManager().AllocateType(MemInstDat::m_STLVect, <FONT color="#800000">0</FONT>);
           idat.NamedVects().Insert(awrd, sv);
           lval = (<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>) sv;
           idat.BuildAddElement(lval);  
         }
         <B><FONT color="#000080">else</FONT></B>
         {
            <I><FONT color="#008080">// trying to name a word with a number error</FONT></I>
            idat.ShowError(Errors::IS_NUMBER);
         }
    }
    <B><FONT color="#000080">else</FONT></B>
     {
        <I><FONT color="#008080">// word already exists error</FONT></I>
        idat.ShowError(Errors::WORD_EXISTS, awrd);
     }
 } 
 <B><FONT color="#000080">else</FONT></B>
 {
      <I><FONT color="#008080">// buffer end reached</FONT></I>
      idat.ShowError(Errors::BUFFER_END);
 }
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_STLMap(InterpreterData & idat)
{
  string awrd;
  Parser * par = idat.IParser();
  <B><FONT color="#000080">char</FONT></B> * wrd;

 <B><FONT color="#000080">if</FONT></B>((wrd = par-&gt;NextWord()) != NULL)
 {
    awrd = wrd;
    <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> lval = 0l;
    <B><FONT color="#000080">if</FONT></B>(idat.IDict()-&gt;Exists(awrd) == -<FONT color="#800000">1</FONT>)  <I><FONT color="#008080">// word does not exist</FONT></I>
    {
         <B><FONT color="#000080">if</FONT></B>(!par-&gt;AllDigits(wrd))         <I><FONT color="#008080">// word is not a number</FONT></I>
         { 
           idat.BuildWithName(awrd); 
           STLMap * sv = (STLMap *) idat.MManager().AllocateType(MemInstDat::m_STLMap, <FONT color="#800000">0</FONT>);
           idat.NamedMaps().Insert(awrd, sv);
           lval = (<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>) sv;
           idat.BuildAddElement(lval);  
         }
         <B><FONT color="#000080">else</FONT></B>
         {
            <I><FONT color="#008080">// trying to name a word with a number error</FONT></I>
            idat.ShowError(Errors::IS_NUMBER);
         }
    }
    <B><FONT color="#000080">else</FONT></B>
     {
        <I><FONT color="#008080">// word already exists error</FONT></I>
        idat.ShowError(Errors::WORD_EXISTS, awrd);
     }
 } 
 <B><FONT color="#000080">else</FONT></B>
 {
      <I><FONT color="#008080">// buffer end reached</FONT></I>
      idat.ShowError(Errors::BUFFER_END);
 }
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_STLVectIterator(InterpreterData & idat)
{
  string awrd;
  Parser * par = idat.IParser();
  <B><FONT color="#000080">char</FONT></B> * wrd;

 <B><FONT color="#000080">if</FONT></B>((wrd = par-&gt;NextWord()) != NULL)
 {
    awrd = wrd;
    <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> lval = 0l;
    <B><FONT color="#000080">if</FONT></B>(idat.IDict()-&gt;Exists(awrd) == -<FONT color="#800000">1</FONT>)  <I><FONT color="#008080">// word does not exist</FONT></I>
    {
         <B><FONT color="#000080">if</FONT></B>(!par-&gt;AllDigits(wrd))         <I><FONT color="#008080">// word is not a number</FONT></I>
         { 
           idat.BuildWithName(awrd); 
           STLVectIterator * sv = (STLVectIterator *) idat.MManager().AllocateType(MemInstDat::m_STLVectIterator, <FONT color="#800000">0</FONT>);
           lval = (<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>) sv;
           idat.BuildAddElement(lval);  
         }
         <B><FONT color="#000080">else</FONT></B>
         {
            <I><FONT color="#008080">// trying to name a word with a number error</FONT></I>
            idat.ShowError(Errors::IS_NUMBER);
         }
    }
    <B><FONT color="#000080">else</FONT></B>
     {
        <I><FONT color="#008080">// word already exists error</FONT></I>
        idat.ShowError(Errors::WORD_EXISTS, awrd);
     }
 } 
 <B><FONT color="#000080">else</FONT></B>
 {
      <I><FONT color="#008080">// buffer end reached</FONT></I>
      idat.ShowError(Errors::BUFFER_END);
 }
}


<B><FONT color="#000080">void</FONT></B> Primitives::L_STLMapIterator(InterpreterData & idat)
{
  string awrd;
  Parser * par = idat.IParser();
  <B><FONT color="#000080">char</FONT></B> * wrd;

 <B><FONT color="#000080">if</FONT></B>((wrd = par-&gt;NextWord()) != NULL)
 {
    awrd = wrd;
    <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> lval = 0l;
    <B><FONT color="#000080">if</FONT></B>(idat.IDict()-&gt;Exists(awrd) == -<FONT color="#800000">1</FONT>)  <I><FONT color="#008080">// word does not exist</FONT></I>
    {
         <B><FONT color="#000080">if</FONT></B>(!par-&gt;AllDigits(wrd))         <I><FONT color="#008080">// word is not a number</FONT></I>
         { 
           idat.BuildWithName(awrd); 
           STLMapIterator * sv = (STLMapIterator *) idat.MManager().AllocateType(MemInstDat::m_STLMapIterator, <FONT color="#800000">0</FONT>);
           lval = (<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>) sv;
           idat.BuildAddElement(lval);  
         }
         <B><FONT color="#000080">else</FONT></B>
         {
            <I><FONT color="#008080">// trying to name a word with a number error</FONT></I>
            idat.ShowError(Errors::IS_NUMBER);
         }
    }
    <B><FONT color="#000080">else</FONT></B>
     {
        <I><FONT color="#008080">// word already exists error</FONT></I>
        idat.ShowError(Errors::WORD_EXISTS);
     }
 } 
 <B><FONT color="#000080">else</FONT></B>
 {
      <I><FONT color="#008080">// buffer end reached</FONT></I>
      idat.ShowError(Errors::BUFFER_END);
 }
}


<I><FONT color="#008080">// Function name    : Primitives::L_STLInsert</FONT></I>
<I><FONT color="#008080">// Description      : for maps</FONT></I>
<I><FONT color="#008080">//                    ( ld key &stlobj --- true | false ) </FONT></I>
<I><FONT color="#008080">//                    for vectors</FONT></I>
<I><FONT color="#008080">//                    ( ld iterator &stlobj --- changed_iterator )</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_STLInsert(InterpreterData & idat)
{
  <B><FONT color="#000080">long</FONT></B> kv;
  <B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B> lv;
  STLVectIterator* li;
  <B><FONT color="#000080">void</FONT></B> * pl = (<B><FONT color="#000080">void</FONT></B> *) idat.PopD();
  <B><FONT color="#000080">int</FONT></B> ii = idat.MManager().Typeof(pl);
  STLMap * sp = NULL;
  STLVect * vp = NULL;
  <B><FONT color="#000080">bool</FONT></B> tf = false;

  <B><FONT color="#000080">switch</FONT></B>(ii)
  {
    <B><FONT color="#000080">case</FONT></B> MemInstDat::m_STLMap:
          sp = (STLMap *) pl; 
          kv =  idat.PopD();
          lv = idat.PopD();          
          tf = sp-&gt;Insert(kv, lv);
          idat.PushD((<B><FONT color="#000080">long</FONT></B>)tf);
        <B><FONT color="#000080">break</FONT></B>;
    <B><FONT color="#000080">case</FONT></B> MemInstDat::m_STLVect:
          vp = (STLVect *) pl; 
          li = (STLVectIterator*) idat.PopD();
          lv = idat.PopD();
          *li = vp-&gt;Insert(li-&gt;GetIt(), lv);
          idat.PushD((<B><FONT color="#000080">long</FONT></B>)li);
        <B><FONT color="#000080">break</FONT></B>;
    <B><FONT color="#000080">default</FONT></B>:
        idat.ShowError(Errors::STL_ERROR);
        <B><FONT color="#000080">break</FONT></B>;
  }
}

<I><FONT color="#008080">// Function name    : Primitives::L_STLFind</FONT></I>
<I><FONT color="#008080">// Description      : ( dat iterator &stlobj --- iterator true | false)</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_STLFind(InterpreterData & idat)
{
  <B><FONT color="#000080">long</FONT></B> dv;
  STLVectIterator* iv;
  STLMapIterator* jv;
  <B><FONT color="#000080">void</FONT></B> * pl = (<B><FONT color="#000080">void</FONT></B> *) idat.PopD();
  <B><FONT color="#000080">int</FONT></B> ii = idat.MManager().Typeof(pl);
  STLMap * sp = NULL;
  STLVect * vp = NULL;

  <B><FONT color="#000080">switch</FONT></B>(ii)
  {
    <B><FONT color="#000080">case</FONT></B> MemInstDat::m_STLMap:
          sp = (STLMap *) pl; 
          jv = (STLMapIterator*) idat.PopD();
          dv = idat.PopD(); 
          *jv = sp-&gt;Find(dv);
          <B><FONT color="#000080">if</FONT></B>((*jv) == sp-&gt;End())
          {
            idat.PushD((<B><FONT color="#000080">long</FONT></B>)false);
          }
          <B><FONT color="#000080">else</FONT></B>
          {
            idat.PushD((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>)(jv));
            idat.PushD(true);
          }
        <B><FONT color="#000080">break</FONT></B>;
    <B><FONT color="#000080">case</FONT></B> MemInstDat::m_STLVect:
          vp = (STLVect *) pl; 
          iv = (STLVectIterator*) idat.PopD();
          dv = idat.PopD();
          *iv = vp-&gt;Find(dv);
          <B><FONT color="#000080">if</FONT></B>((*iv) == vp-&gt;End())
          {
            idat.PushD((<B><FONT color="#000080">long</FONT></B>)false);
          }
          <B><FONT color="#000080">else</FONT></B>
          {
            idat.PushD((<B><FONT color="#000080">long</FONT></B>)iv);
            idat.PushD((<B><FONT color="#000080">long</FONT></B>)true);
          }

        <B><FONT color="#000080">break</FONT></B>;
    <B><FONT color="#000080">default</FONT></B>:
        idat.ShowError(Errors::STL_ERROR);
        <B><FONT color="#000080">break</FONT></B>;
  }
}


<I><FONT color="#008080">// Function name    : Primitives::L_STLBegin</FONT></I>
<I><FONT color="#008080">// Description      : (iterator &stlobj -- iterator)</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_STLBegin(InterpreterData & idat)
{
  STLVectIterator* iv;
  STLMapIterator* jv;
  <B><FONT color="#000080">void</FONT></B> * pl = (<B><FONT color="#000080">void</FONT></B> *) idat.PopD();
  <B><FONT color="#000080">int</FONT></B> ii = idat.MManager().Typeof(pl);
  STLMap * sp = NULL;
  STLVect * vp = NULL;

  <B><FONT color="#000080">switch</FONT></B>(ii)
  {
    <B><FONT color="#000080">case</FONT></B> MemInstDat::m_STLMap:
        {
          sp = (STLMap *) pl; 
          jv = (STLMapIterator*) idat.PopD();
          *jv = sp-&gt;Begin();
          idat.PushD((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>)(jv));
        }
        <B><FONT color="#000080">break</FONT></B>;
    <B><FONT color="#000080">case</FONT></B> MemInstDat::m_STLVect:
        {
          vp = (STLVect *) pl; 
          iv = (STLVectIterator*) idat.PopD();
          *iv = vp-&gt;Begin();
          idat.PushD((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>)(iv));
        }
        <B><FONT color="#000080">break</FONT></B>;
    <B><FONT color="#000080">default</FONT></B>:
        idat.ShowError(Errors::STL_ERROR);
        <B><FONT color="#000080">break</FONT></B>;
  }
}


<I><FONT color="#008080">// Function name    : Primitives::L_STLEnd</FONT></I>
<I><FONT color="#008080">// Description      : (iterator &stlobj -- iterator)</FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_STLEnd(InterpreterData & idat)
{
  STLVectIterator* iv;
  STLMapIterator* jv;
  <B><FONT color="#000080">void</FONT></B> * pl = (<B><FONT color="#000080">void</FONT></B> *) idat.PopD();
  <B><FONT color="#000080">int</FONT></B> ii = idat.MManager().Typeof(pl);
  STLMap * sp = NULL;
  STLVect * vp = NULL;

  <B><FONT color="#000080">switch</FONT></B>(ii)
  {
    <B><FONT color="#000080">case</FONT></B> MemInstDat::m_STLMap:
          sp = (STLMap *) pl; 
          jv = (STLMapIterator*) idat.PopD();
          *jv = sp-&gt;End();
          idat.PushD((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>)(jv));
        <B><FONT color="#000080">break</FONT></B>;
    <B><FONT color="#000080">case</FONT></B> MemInstDat::m_STLVect:
          vp = (STLVect *) pl; 
          iv = (STLVectIterator*) idat.PopD();
          *iv = vp-&gt;End();
          idat.PushD((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>)(iv));
        <B><FONT color="#000080">break</FONT></B>;
    <B><FONT color="#000080">default</FONT></B>:
        idat.ShowError(Errors::STL_ERROR);
        <B><FONT color="#000080">break</FONT></B>;
  }
}


<I><FONT color="#008080">// Function name    : Primitives::L_STLItfrom</FONT></I>
<I><FONT color="#008080">// Description      : </FONT></I>
<I><FONT color="#008080">// Return type      : void </FONT></I>
<I><FONT color="#008080">// Argument         : InterpreterData & idat</FONT></I>
<B><FONT color="#000080">void</FONT></B> Primitives::L_STLItFrom(InterpreterData & idat)
{
  <B><FONT color="#000080">long</FONT></B> lv;
  STLVectIterator* iv;
  STLMapIterator* jv;
  <B><FONT color="#000080">void</FONT></B> * pl = (<B><FONT color="#000080">void</FONT></B> *) idat.PopD();
  <B><FONT color="#000080">int</FONT></B> ii = idat.MManager().Typeof(pl);
 
  <B><FONT color="#000080">switch</FONT></B>(ii)
  {
    <B><FONT color="#000080">case</FONT></B> MemInstDat::m_STLMapIterator:
          jv = (STLMapIterator*) pl;
          lv = (*(jv-&gt;GetIt())).second;
          idat.PushD((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>)(lv));
        <B><FONT color="#000080">break</FONT></B>;
    <B><FONT color="#000080">case</FONT></B> MemInstDat::m_STLVectIterator:
          iv = (STLVectIterator*) pl;
          lv = *(iv-&gt;GetIt());
          idat.PushD((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>)(lv));
        <B><FONT color="#000080">break</FONT></B>;
    <B><FONT color="#000080">default</FONT></B>:
        idat.ShowError(Errors::STL_ERROR);
        <B><FONT color="#000080">break</FONT></B>;
  }
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_STLItInc(InterpreterData & idat)
{
  STLVectIterator* iv;
  STLMapIterator* jv;
  <B><FONT color="#000080">void</FONT></B> * pl = (<B><FONT color="#000080">void</FONT></B> *) idat.PopD();
  <B><FONT color="#000080">int</FONT></B> ii = idat.MManager().Typeof(pl);

  <B><FONT color="#000080">switch</FONT></B>(ii)
  {
    <B><FONT color="#000080">case</FONT></B> MemInstDat::m_STLMapIterator:
          jv = (STLMapIterator*) pl;
          (*jv).GetIt()++;
          idat.PushD((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>)(jv));
        <B><FONT color="#000080">break</FONT></B>;
    <B><FONT color="#000080">case</FONT></B> MemInstDat::m_STLVectIterator:
          iv = (STLVectIterator*) pl;
          (*iv).GetIt()++;
          idat.PushD((<B><FONT color="#000080">unsigned</FONT></B> <B><FONT color="#000080">long</FONT></B>)(iv));
        <B><FONT color="#000080">break</FONT></B>;
    <B><FONT color="#000080">default</FONT></B>:
        idat.ShowError(Errors::STL_ERROR);
        <B><FONT color="#000080">break</FONT></B>;
  }
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_STLItEquals(InterpreterData & idat)
{
  STLVectIterator* iv, *iv2;
  STLMapIterator* jv, *jv2;
  <B><FONT color="#000080">void</FONT></B> * pl = (<B><FONT color="#000080">void</FONT></B> *) idat.PopD();
  <B><FONT color="#000080">void</FONT></B> * rl = (<B><FONT color="#000080">void</FONT></B> *) idat.PopD();
  <B><FONT color="#000080">int</FONT></B> ii = idat.MManager().Typeof(pl);
  <B><FONT color="#000080">int</FONT></B> jj = idat.MManager().Typeof(rl);
  <B><FONT color="#000080">if</FONT></B>(ii != jj)
  {
    idat.ShowError(Errors::STL_ERROR);
    idat.PushD((<B><FONT color="#000080">long</FONT></B>)false);
    <B><FONT color="#000080">return</FONT></B>;
  }

  <B><FONT color="#000080">switch</FONT></B>(ii)
  {
    <B><FONT color="#000080">case</FONT></B> MemInstDat::m_STLMapIterator:
          jv = (STLMapIterator*) pl;
          jv2 = (STLMapIterator*) rl;
          <B><FONT color="#000080">if</FONT></B>((*jv).GetIt() == (*jv2).GetIt())
          {
            idat.PushD(true); 
            <B><FONT color="#000080">return</FONT></B>;
          }
        <B><FONT color="#000080">break</FONT></B>;
    <B><FONT color="#000080">case</FONT></B> MemInstDat::m_STLVectIterator:
          iv = (STLVectIterator*) pl;
          iv2 = (STLVectIterator*) rl;
          <B><FONT color="#000080">if</FONT></B>((*iv2).GetIt() == (*iv).GetIt())
          {
            idat.PushD(true);
            <B><FONT color="#000080">return</FONT></B>;
          }
        <B><FONT color="#000080">break</FONT></B>;
    <B><FONT color="#000080">default</FONT></B>:
        idat.ShowError(Errors::STL_ERROR);
        <B><FONT color="#000080">break</FONT></B>;
  }
  idat.PushD((<B><FONT color="#000080">long</FONT></B>)false);
}

<B><FONT color="#000080">void</FONT></B> Primitives::L_bye(InterpreterData & idat)
{
  _exit(<FONT color="#800000">0</FONT>);
}


<I><FONT color="#008080">// ------------------TO DO --------------</FONT></I>
<I><FONT color="#008080">//  vocs, forget </FONT></I>
<I><FONT color="#008080">//  [compile] words </FONT></I>
<I><FONT color="#008080">// u&lt;, u&gt; .r u.r erase state  move</FONT></I>
<I><FONT color="#008080">// abort abort" accept sliteral see evaluate get-current get-order ['] </FONT></I>
<I><FONT color="#008080">// search-wordlist set-current set-order wordlist only order previous </FONT></I>
<I><FONT color="#008080">// key? ekey&gt;char ekey?  2r@ 2r&gt; 2&gt;r compile, catch throw emit? ms </FONT></I>
<I><FONT color="#008080">// implement [char] source </FONT></I>
<I><FONT color="#008080">// /mod */ */mod c, </FONT></I>

<I><FONT color="#008080">// : gi5 begin dup 2 &gt; while dup 5 &lt; while dup 1+ repeat 123 else 345 then ;</FONT></I>

<I><FONT color="#008080">// bin close-file create-file delete-file file-position file-size include-file </FONT></I>
<I><FONT color="#008080">// included r/o open-file r/w read-file read-line reposition-file resize-file </FONT></I>
<I><FONT color="#008080">// source-id w/o write-file write-line file-status flush-file rename-file </FONT></I>


<I><FONT color="#008080">//#if _MSC_VER &lt;= 800   </FONT></I>
<I><FONT color="#008080">//extern char far *_pgmptr;   </FONT></I>
<I><FONT color="#008080">//#else   /#include &lt;stdlib.h&gt;</FONT></I>
<I><FONT color="#008080">//#endif</FONT></I>


</PRE>
