<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>scriptandoutputpage</title>
<meta name="GENERATOR" content="Microsoft FrontPage 3.0">


<meta name="Microsoft Theme" content="expeditn 001, default"><meta name="Microsoft Border" content="tlb, default"></head>

<body background="_themes/expeditn/exptextb.jpg" bgcolor="#FFFFFF" text="#000000" link="#006600" vlink="#669966" alink="#990000"><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td><!--mstheme--><font face="book antiqua, times new roman, times">

<h1>_Zen_Soft Forth Interpreter</h1>

<!--msthemeseparator--><p align="center"><img src="_themes/expeditn/exphorsd.gif" width="300" height="10"></p>
<!--mstheme--></font></td></tr><!--msnavigation--></table><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td valign="top" width="1%"><!--mstheme--><font face="book antiqua, times new roman, times">

<p>&nbsp;</p>
<!--mstheme--></font></td><td valign="top" width="24"></td><!--msnavigation--><td valign="top"><!--mstheme--><font face="book antiqua, times new roman, times">

<p><a href="state_machine_parser_documentati.htm">Back to Documentation page</a> </p>

<h3><!--mstheme--><font color="#996600"><font color="#000000">&quot;Test.sc&quot; is a state machine description script file</font><!--mstheme--></font></h3>

<!--msthemeseparator--><p align="center"><img src="_themes/expeditn/exphorsd.gif" width="300" height="10"></p>

<p><font color="#0000FF">Name: Test<br>
<br>
States{ opened, closed, locked }<br>
<br>
Events{ close, open, lock, unlock }<br>
<br>
Actions{ Unlock, Lock, Close, Open, Nop }<br>
<br>
Starting closed<br>
<br>
State: closed <br>
Event: open : Open : opened<br>
Event: unlock, close : Nop : closed<br>
Event: lock : Lock : locked<br>
Default: Nop : closed }<br>
<br>
State: opened // this is a comment<br>
Event: open, unlock, lock : Nop : opened<br>
Event: close : Close : closed<br>
Default: Nop : opened }<br>
<br>
State: locked<br>
Event: unlock : Unlock : closed<br>
// Event: open, close, lock : Nop : locked<br>
Default: Nop : locked }</font></p>

<!--msthemeseparator--><p align="center"><img src="_themes/expeditn/exphorsd.gif" width="300" height="10"></p>

<h3><!--mstheme--><font color="#996600"><font color="#000000">Test.h is the parser output from test.sc</font><!--mstheme--></font></h3>

<!--msthemeseparator--><p align="center"><img src="_themes/expeditn/exphorsd.gif" width="300" height="10"></p>

<p><font color="#008000">#ifndef INCLUDE_Test_H<br>
#define INCLUDE_Test_H<br>
<br>
<br>
//This file was generated by sparser.exe, a statemachine script parser<br>
// sparser.exe is copyright 1999 2000 by Saul Scudder<br>
// Persmision is granted for non-profit use of generated code when this copyright is left
intact.<br>
// Any for profit use requires registration and payment of a registration fee for use of
sparser.exe<br>
// // This copyright must remain intact when the software has been registered<br>
// No warranty is implied or given by this notice or by registration of sparser.exe as to
use <br>
// for any purpose whatsoever. Proper testing for or by users is assumed.<br>
// -<br>
// ------------This line and the address information below may be deleted ------------<br>
//To register for use of all _Zen_Soft Programers tools send $40 to <br>
//Saul Scudder <br>
//Attn: _Zen_Soft &quot;programers tools&quot;<br>
//5106 W Crocus Dr. Glendale AZ<br>
//email is scuddersaul@earthlink.net<br>
// Download updates at http://arizona.speedchoice.com/~scudders/Zen_Soft<br>
<br>
<br>
#include &lt;cmath&gt;<br>
#include &lt;cfloat&gt;<br>
#include &lt;ctime&gt;<br>
#pragma warning(disable: 4786)<br>
<br>
#include &lt;vector&gt;<br>
#include &lt;set&gt;<br>
#include &lt;list&gt;<br>
#include &lt;map&gt;<br>
#include &lt;stack&gt;<br>
#include &lt;algorithm&gt;<br>
#include &lt;string&gt;<br>
#include &lt;fstream&gt;<br>
#include &quot;newutility.h&quot;<br>
#include &quot;statemachine.h&quot;<br>
<br>
using namespace std;<br>
<br>
// Prototype the new state machine class<br>
class Test;<br>
<br>
// define a pointer to methods of the new class<br>
#ifndef pTestSF<br>
typedef bool (Test::*pTestSF)(void);<br>
#endif<br>
<br>
<br>
// define the state machine class<br>
class Test : public Machine<br>
{<br>
set&lt;Transition&lt;pTestSF&gt;, less&lt;Transition&lt;pTestSF&gt; &gt; &gt; trans;<br>
unsigned long ID;<br>
Event eventrunning;<br>
long currentstate;<br>
long currentevent;<br>
long nextstate;<br>
<br>
public:<br>
enum EventsForTest<br>
{<br>
&nbsp;&nbsp;&nbsp; EVENT_Default = 1,<br>
&nbsp;&nbsp;&nbsp; EVENT_close = 2,<br>
&nbsp;&nbsp;&nbsp; EVENT_lock = 3,<br>
&nbsp;&nbsp;&nbsp; EVENT_open = 4,<br>
&nbsp;&nbsp;&nbsp; EVENT_unlock = 5,<br>
};<br>
<br>
public:<br>
<br>
Test()<br>
{<br>
&nbsp;&nbsp;&nbsp; AddMachineName(&quot;Test&quot;);<br>
<br>
// register every class instance<br>
&nbsp;&nbsp;&nbsp; ID = (MRegistry())-&gt;NextInst();<br>
&nbsp;&nbsp;&nbsp; (MRegistry())-&gt;AddInst(ID, this);<br>
<br>
&nbsp;&nbsp;&nbsp; AddStateKey(&quot;closed&quot;);<br>
&nbsp;&nbsp;&nbsp; AddStateKey(&quot;locked&quot;);<br>
&nbsp;&nbsp;&nbsp; AddStateKey(&quot;opened&quot;);<br>
&nbsp;&nbsp;&nbsp; AddEventKey(&quot;Default&quot;, EVENT_Default);<br>
&nbsp;&nbsp;&nbsp; AddEventKey(&quot;close&quot;, EVENT_close);<br>
&nbsp;&nbsp;&nbsp; AddEventKey(&quot;lock&quot;, EVENT_lock);<br>
&nbsp;&nbsp;&nbsp; AddEventKey(&quot;open&quot;, EVENT_open);<br>
&nbsp;&nbsp;&nbsp; AddEventKey(&quot;unlock&quot;, EVENT_unlock);<br>
&nbsp;&nbsp;&nbsp; AddTransition(&quot;closed&quot;, &quot;opened&quot;, &quot;open&quot;,
Open);<br>
&nbsp;&nbsp;&nbsp; AddTransition(&quot;closed&quot;, &quot;closed&quot;,
&quot;close&quot;, Nop);<br>
&nbsp;&nbsp;&nbsp; AddTransition(&quot;closed&quot;, &quot;closed&quot;,
&quot;unlock&quot;, Nop);<br>
&nbsp;&nbsp;&nbsp; AddTransition(&quot;closed&quot;, &quot;locked&quot;, &quot;lock&quot;,
Lock);<br>
&nbsp;&nbsp;&nbsp; AddTransition(&quot;closed&quot;, &quot;closed&quot;,
&quot;Default:&quot;, Nop);<br>
&nbsp;&nbsp;&nbsp; AddTransition(&quot;opened&quot;, &quot;opened&quot;, &quot;lock&quot;,
Nop);<br>
&nbsp;&nbsp;&nbsp; AddTransition(&quot;opened&quot;, &quot;opened&quot;, &quot;open&quot;,
Nop);<br>
&nbsp;&nbsp;&nbsp; AddTransition(&quot;opened&quot;, &quot;opened&quot;,
&quot;unlock&quot;, Nop);<br>
&nbsp;&nbsp;&nbsp; AddTransition(&quot;opened&quot;, &quot;closed&quot;,
&quot;close&quot;, Close);<br>
&nbsp;&nbsp;&nbsp; AddTransition(&quot;opened&quot;, &quot;opened&quot;,
&quot;Default:&quot;, Nop);<br>
&nbsp;&nbsp;&nbsp; AddTransition(&quot;locked&quot;, &quot;closed&quot;,
&quot;unlock&quot;, Unlock);<br>
&nbsp;&nbsp;&nbsp; AddTransition(&quot;locked&quot;, &quot;locked&quot;,
&quot;Default:&quot;, Nop);<br>
&nbsp;&nbsp;&nbsp; SetStartState();<br>
}<br>
<br>
// Unregister from the Machine Registry in destructor<br>
~Test()<br>
{<br>
&nbsp;&nbsp;&nbsp; MRegistry()-&gt;DeleteInst(ID);<br>
}<br>
<br>
// This method is used by the constructor to establish state transitions<br>
// Do not modify this code<br>
void AddTransition(char *sst, char *fst, char *evt, pTestSF p)<br>
{<br>
&nbsp;&nbsp;&nbsp; Transition&lt;pTestSF&gt; atz;<br>
&nbsp;&nbsp;&nbsp; set&lt;Transition&lt;pTestSF&gt;, less&lt;Transition&lt;pTestSF&gt;
&gt; &gt;::iterator ti;<br>
<br>
&nbsp;&nbsp;&nbsp; atz.AddState(StateID(sst));<br>
&nbsp;&nbsp;&nbsp; atz.AddDest(StateID(fst));<br>
&nbsp;&nbsp;&nbsp; atz.AddEvent(EventID(evt));<br>
&nbsp;&nbsp;&nbsp; atz.AddAction(p);<br>
<br>
&nbsp;&nbsp;&nbsp; if((ti = trans.find(atz)) == trans.end())<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trans.insert(atz);<br>
&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; else<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (*ti).AddAction(p);<br>
&nbsp;&nbsp;&nbsp; }<br>
}<br>
<br>
// Will run the next event transition action(s)<br>
//NORMAL Events are run in the order queued, High priority Events are run in priority
order<br>
bool RunTransition(void)<br>
{<br>
&nbsp;&nbsp;&nbsp; if(NextEvent(eventrunning) == false)<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return(true);<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; Transition&lt;pTestSF&gt; atz;<br>
&nbsp;&nbsp;&nbsp; set&lt;Transition&lt;pTestSF&gt;, less&lt;Transition&lt;pTestSF&gt;
&gt; &gt;::iterator ti;<br>
<br>
&nbsp;&nbsp;&nbsp; atz.AddState(currentstate);<br>
&nbsp;&nbsp;&nbsp; currentevent = eventrunning.EventID();<br>
&nbsp;&nbsp;&nbsp; atz.AddEvent(currentevent);<br>
&nbsp;&nbsp;&nbsp; ti = trans.find(atz);<br>
<br>
&nbsp;&nbsp;&nbsp; if(ti != trans.end())<br>
&nbsp;&nbsp;&nbsp; {<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nextstate = (*ti).Destination();<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int ii = 0;ii &lt;
((*ti).Actions().size());ii++)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pTestSF Exf =
(*ti).AnAction(ii);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(((this-&gt;*Exf)())
== false)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return(false);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentstate = (*ti).Destination();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return(true);<br>
&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; else<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; atz.AddEvent(EVENT_Default);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ti = trans.find(atz);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(ti != trans.end())<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nextstate =
(*ti).Destination();<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int ii = 0;ii &lt;
((*ti).Actions().size());ii++)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
pTestSF Exf = (*ti).AnAction(ii);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if(((this-&gt;*Exf)()) == false)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return(false);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentstate =
(*ti).Destination();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return(true);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; return(false);<br>
}<br>
<br>
// This method returns the Machine Registry ID of this machine instance<br>
unsigned long GetID(void)<br>
{<br>
&nbsp;&nbsp;&nbsp; return(ID);<br>
}<br>
<br>
// ValidEvent is used to get an events long code and test its belonging to the machine<br>
bool ValidEvent(string &amp;s, long &amp; le)<br>
{<br>
&nbsp;&nbsp;&nbsp; return(AllEvents().OFind(s, le));<br>
}<br>
<br>
<br>
bool ValidEvent(char *cc, long &amp; le)<br>
{<br>
&nbsp;&nbsp;&nbsp; string gg = cc;<br>
&nbsp;&nbsp;&nbsp; return(AllEvents().OFind(gg, le));<br>
}<br>
<br>
// Sets the state machine to it's starting state<br>
bool SetStartState(void)<br>
{<br>
&nbsp;&nbsp;&nbsp; long lg;<br>
&nbsp;&nbsp;&nbsp; string sl = &quot;closed&quot;;<br>
&nbsp;&nbsp;&nbsp; if(AllStates().OFind(sl, lg))<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentstate = lg;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return(true);<br>
&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; return(false);<br>
}<br>
<br>
bool Close()<br>
{<br>
//testing code, comment out later<br>
&nbsp;&nbsp;&nbsp; string st, sf, ev;<br>
&nbsp;&nbsp;&nbsp; AllStates().IFind(currentstate, st);<br>
&nbsp;&nbsp;&nbsp; AllEvents().IFind(currentevent, ev);<br>
&nbsp;&nbsp;&nbsp; AllStates().IFind(nextstate, sf);<br>
<br>
&nbsp;&nbsp;&nbsp; printf(&quot;\nIn Test::Close() from %s and %s to %s\n&quot;,
st.c_str(), ev.c_str(), sf.c_str());<br>
// End testing code<br>
<br>
&nbsp;&nbsp;&nbsp; return(true);<br>
}<br>
<br>
bool Lock()<br>
{<br>
//testing code, comment out later<br>
&nbsp;&nbsp;&nbsp; string st, sf, ev;<br>
&nbsp;&nbsp;&nbsp; AllStates().IFind(currentstate, st);<br>
&nbsp;&nbsp;&nbsp; AllEvents().IFind(currentevent, ev);<br>
&nbsp;&nbsp;&nbsp; AllStates().IFind(nextstate, sf);<br>
<br>
&nbsp;&nbsp;&nbsp; printf(&quot;\nIn Test::Lock() from %s and %s to %s\n&quot;,
st.c_str(), ev.c_str(), sf.c_str());<br>
// End testing code<br>
<br>
return(true);<br>
}<br>
<br>
bool Nop()<br>
{<br>
//testing code, comment out later<br>
&nbsp;&nbsp;&nbsp; string st, sf, ev;<br>
&nbsp;&nbsp;&nbsp; AllStates().IFind(currentstate, st);<br>
&nbsp;&nbsp;&nbsp; AllEvents().IFind(currentevent, ev);<br>
&nbsp;&nbsp;&nbsp; AllStates().IFind(nextstate, sf);<br>
<br>
&nbsp;&nbsp;&nbsp; printf(&quot;\nIn Test::Nop() from %s and %s to %s\n&quot;, st.c_str(),
ev.c_str(), sf.c_str());<br>
// End testing code<br>
<br>
&nbsp;&nbsp;&nbsp; return(true);<br>
}<br>
<br>
bool Open()<br>
{<br>
//testing code, comment out later<br>
&nbsp;&nbsp;&nbsp; string st, sf, ev;<br>
&nbsp;&nbsp;&nbsp; AllStates().IFind(currentstate, st);<br>
&nbsp;&nbsp;&nbsp; AllEvents().IFind(currentevent, ev);<br>
&nbsp;&nbsp;&nbsp; AllStates().IFind(nextstate, sf);<br>
<br>
&nbsp;&nbsp;&nbsp; printf(&quot;\nIn Test::Open() from %s and %s to %s\n&quot;,
st.c_str(), ev.c_str(), sf.c_str());<br>
// End testing code<br>
<br>
return(true);<br>
}<br>
<br>
bool Unlock()<br>
{<br>
//testing code, comment out later<br>
&nbsp;&nbsp;&nbsp; string st, sf, ev;<br>
&nbsp;&nbsp;&nbsp; AllStates().IFind(currentstate, st);<br>
&nbsp;&nbsp;&nbsp; AllEvents().IFind(currentevent, ev);<br>
&nbsp;&nbsp;&nbsp; AllStates().IFind(nextstate, sf);<br>
<br>
&nbsp;&nbsp;&nbsp; printf(&quot;\nIn Test::Unlock() from %s and %s to %s\n&quot;,
st.c_str(), ev.c_str(), sf.c_str());<br>
// End testing code<br>
<br>
&nbsp;&nbsp;&nbsp; return(true);<br>
}<br>
};<br>
<br>
#endif</font><br>
<!--mstheme--></font><!--msnavigation--></td></tr><!--msnavigation--></table><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td><!--mstheme--><font face="book antiqua, times new roman, times">

<!--msthemeseparator--><p align="center"><img src="_themes/expeditn/exphorsd.gif" width="300" height="10"></p>

<h5><!--mstheme--><font color="#660033">[_Zen_Soft]&nbsp; is a trademark of [_Zen_Soft]. All other products mentioned are
registered trademarks or trademarks of their respective companies.<br>
<br>
Questions or problems regarding this web site should be directed to
[scuddersaul@earthlink.com].<br>
Copyright © 2000[_Zen_Soft]. All rights reserved.<br>
Last modified: Monday June 26, 2000.<!--mstheme--></font></h5>
<!--mstheme--></font></td></tr><!--msnavigation--></table></body>
</html>
